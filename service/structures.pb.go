// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structures.proto

package service

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CurrencyID int32

const (
	CNY CurrencyID = 0
	USD CurrencyID = 1
)

var CurrencyID_name = map[int32]string{
	0: "CNY",
	1: "USD",
}

var CurrencyID_value = map[string]int32{
	"CNY": 0,
	"USD": 1,
}

func (CurrencyID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{0}
}

type BusinessType int32

const (
	future BusinessType = 0
	stock  BusinessType = 1
)

var BusinessType_name = map[int32]string{
	0: "future",
	1: "stock",
}

var BusinessType_value = map[string]int32{
	"future": 0,
	"stock":  1,
}

func (BusinessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{1}
}

type HedgeFlag int32

const (
	speculation  HedgeFlag = 0
	arbitrage    HedgeFlag = 1
	hedge        HedgeFlag = 2
	market_maker HedgeFlag = 3
)

var HedgeFlag_name = map[int32]string{
	0: "speculation",
	1: "arbitrage",
	2: "hedge",
	3: "market_maker",
}

var HedgeFlag_value = map[string]int32{
	"speculation":  0,
	"arbitrage":    1,
	"hedge":        2,
	"market_maker": 3,
}

func (HedgeFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{2}
}

type Direction int32

const (
	buy   Direction = 0
	long  Direction = 0
	sell  Direction = 1
	short Direction = 1
)

var Direction_name = map[int32]string{
	0: "buy",
	// Duplicate value: 0: "long",
	1: "sell",
	// Duplicate value: 1: "short",
}

var Direction_value = map[string]int32{
	"buy":   0,
	"long":  0,
	"sell":  1,
	"short": 1,
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{3}
}

type OrderPriceType int32

const (
	any_price           OrderPriceType = 0
	limit_price         OrderPriceType = 1
	best_price          OrderPriceType = 2
	last_price          OrderPriceType = 3
	last_price_plus1    OrderPriceType = 4
	last_price_plus2    OrderPriceType = 5
	last_price_plus3    OrderPriceType = 6
	ask_price           OrderPriceType = 7
	ask_price_plus1     OrderPriceType = 8
	ask_price_plus2     OrderPriceType = 9
	ask_price_plus3     OrderPriceType = 10
	bid_price           OrderPriceType = 11
	bid_price_plus1     OrderPriceType = 12
	bid_price_plus2     OrderPriceType = 13
	bid_price_plus3     OrderPriceType = 14
	five_level_price    OrderPriceType = 15
	stop_loss_market    OrderPriceType = 16
	stop_loss_limit     OrderPriceType = 17
	gtc_limit           OrderPriceType = 18
	stock_lend          OrderPriceType = 19
	stock_financing_buy OrderPriceType = 20
	repay_stock_type    OrderPriceType = 21
	etf_purchase        OrderPriceType = 22
	etf_redemption      OrderPriceType = 23
)

var OrderPriceType_name = map[int32]string{
	0:  "any_price",
	1:  "limit_price",
	2:  "best_price",
	3:  "last_price",
	4:  "last_price_plus1",
	5:  "last_price_plus2",
	6:  "last_price_plus3",
	7:  "ask_price",
	8:  "ask_price_plus1",
	9:  "ask_price_plus2",
	10: "ask_price_plus3",
	11: "bid_price",
	12: "bid_price_plus1",
	13: "bid_price_plus2",
	14: "bid_price_plus3",
	15: "five_level_price",
	16: "stop_loss_market",
	17: "stop_loss_limit",
	18: "gtc_limit",
	19: "stock_lend",
	20: "stock_financing_buy",
	21: "repay_stock_type",
	22: "etf_purchase",
	23: "etf_redemption",
}

var OrderPriceType_value = map[string]int32{
	"any_price":           0,
	"limit_price":         1,
	"best_price":          2,
	"last_price":          3,
	"last_price_plus1":    4,
	"last_price_plus2":    5,
	"last_price_plus3":    6,
	"ask_price":           7,
	"ask_price_plus1":     8,
	"ask_price_plus2":     9,
	"ask_price_plus3":     10,
	"bid_price":           11,
	"bid_price_plus1":     12,
	"bid_price_plus2":     13,
	"bid_price_plus3":     14,
	"five_level_price":    15,
	"stop_loss_market":    16,
	"stop_loss_limit":     17,
	"gtc_limit":           18,
	"stock_lend":          19,
	"stock_financing_buy": 20,
	"repay_stock_type":    21,
	"etf_purchase":        22,
	"etf_redemption":      23,
}

func (OrderPriceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{4}
}

type TradingRole int32

const (
	broker TradingRole = 0
	host   TradingRole = 1
	maker  TradingRole = 2
)

var TradingRole_name = map[int32]string{
	0: "broker",
	1: "host",
	2: "maker",
}

var TradingRole_value = map[string]int32{
	"broker": 0,
	"host":   1,
	"maker":  2,
}

func (TradingRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{5}
}

type OffsetFlag int32

const (
	open            OffsetFlag = 0
	close           OffsetFlag = 1
	force_close     OffsetFlag = 2
	close_today     OffsetFlag = 3
	close_yesterday OffsetFlag = 4
	force_off       OffsetFlag = 5
	local_force_off OffsetFlag = 6
)

var OffsetFlag_name = map[int32]string{
	0: "open",
	1: "close",
	2: "force_close",
	3: "close_today",
	4: "close_yesterday",
	5: "force_off",
	6: "local_force_off",
}

var OffsetFlag_value = map[string]int32{
	"open":            0,
	"close":           1,
	"force_close":     2,
	"close_today":     3,
	"close_yesterday": 4,
	"force_off":       5,
	"local_force_off": 6,
}

func (OffsetFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{6}
}

type TradeType int32

const (
	split_combination   TradeType = 0
	common              TradeType = 1
	options_execution   TradeType = 2
	otc                 TradeType = 3
	efp_derived         TradeType = 4
	combination_derived TradeType = 5
	finacing_buy        TradeType = 6
	repay_stock_auto    TradeType = 7
	repay_stock_manual  TradeType = 8
)

var TradeType_name = map[int32]string{
	0: "split_combination",
	1: "common",
	2: "options_execution",
	3: "otc",
	4: "efp_derived",
	5: "combination_derived",
	6: "finacing_buy",
	7: "repay_stock_auto",
	8: "repay_stock_manual",
}

var TradeType_value = map[string]int32{
	"split_combination":   0,
	"common":              1,
	"options_execution":   2,
	"otc":                 3,
	"efp_derived":         4,
	"combination_derived": 5,
	"finacing_buy":        6,
	"repay_stock_auto":    7,
	"repay_stock_manual":  8,
}

func (TradeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{7}
}

type PriceSource int32

const (
	ps_last_price PriceSource = 0
	ps_buy        PriceSource = 1
	ps_sell       PriceSource = 2
)

var PriceSource_name = map[int32]string{
	0: "ps_last_price",
	1: "ps_buy",
	2: "ps_sell",
}

var PriceSource_value = map[string]int32{
	"ps_last_price": 0,
	"ps_buy":        1,
	"ps_sell":       2,
}

func (PriceSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{8}
}

type TradeSource int32

const (
	ts_normal TradeSource = 0
	ts_query  TradeSource = 1
)

var TradeSource_name = map[int32]string{
	0: "ts_normal",
	1: "ts_query",
}

var TradeSource_value = map[string]int32{
	"ts_normal": 0,
	"ts_query":  1,
}

func (TradeSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{9}
}

type AccountType int32

const (
	virtual    AccountType = 0
	real       AccountType = 1
	real_group AccountType = 2
)

var AccountType_name = map[int32]string{
	0: "virtual",
	1: "real",
	2: "real_group",
}

var AccountType_value = map[string]int32{
	"virtual":    0,
	"real":       1,
	"real_group": 2,
}

func (AccountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{10}
}

type SubInfoType int32

const (
	order SubInfoType = 0
	trade SubInfoType = 1
)

var SubInfoType_name = map[int32]string{
	0: "order",
	1: "trade",
}

var SubInfoType_value = map[string]int32{
	"order": 0,
	"trade": 1,
}

func (SubInfoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{11}
}

type TimeCondition int32

const (
	immediate_or_cancel TimeCondition = 0
	good_for_section    TimeCondition = 1
	good_for_day        TimeCondition = 2
	good_till_date      TimeCondition = 3
	good_till_canceled  TimeCondition = 4
	good_for_auction    TimeCondition = 5
)

var TimeCondition_name = map[int32]string{
	0: "immediate_or_cancel",
	1: "good_for_section",
	2: "good_for_day",
	3: "good_till_date",
	4: "good_till_canceled",
	5: "good_for_auction",
}

var TimeCondition_value = map[string]int32{
	"immediate_or_cancel": 0,
	"good_for_section":    1,
	"good_for_day":        2,
	"good_till_date":      3,
	"good_till_canceled":  4,
	"good_for_auction":    5,
}

func (TimeCondition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{12}
}

type VolumeCondition int32

const (
	any_volume VolumeCondition = 0
	min_volume VolumeCondition = 1
	all_volume VolumeCondition = 2
)

var VolumeCondition_name = map[int32]string{
	0: "any_volume",
	1: "min_volume",
	2: "all_volume",
}

var VolumeCondition_value = map[string]int32{
	"any_volume": 0,
	"min_volume": 1,
	"all_volume": 2,
}

func (VolumeCondition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{13}
}

type ContingentCondition int32

const (
	immediately                        ContingentCondition = 0
	touch                              ContingentCondition = 1
	touch_profit                       ContingentCondition = 2
	parked_order                       ContingentCondition = 3
	last_price_greate_than_stop_price  ContingentCondition = 4
	last_price_greate_equal_stop_price ContingentCondition = 5
	last_price_less_than_stop_price    ContingentCondition = 6
	last_price_less_equal_stop_price   ContingentCondition = 7
	ask_price_greate_than_stop_price   ContingentCondition = 8
	ask_price_greate_equal_stop_price  ContingentCondition = 9
	ask_price_less_than_stop_price     ContingentCondition = 10
	ask_price_less_equal_stop_price    ContingentCondition = 11
	bid_price_greate_than_stop_price   ContingentCondition = 12
	bid_price_greate_equal_stop_price  ContingentCondition = 13
	bid_price_less_than_stop_price     ContingentCondition = 14
	bid_price_less_equal_stop_price    ContingentCondition = 15
	close_yesterday_first              ContingentCondition = 16
)

var ContingentCondition_name = map[int32]string{
	0:  "immediately",
	1:  "touch",
	2:  "touch_profit",
	3:  "parked_order",
	4:  "last_price_greate_than_stop_price",
	5:  "last_price_greate_equal_stop_price",
	6:  "last_price_less_than_stop_price",
	7:  "last_price_less_equal_stop_price",
	8:  "ask_price_greate_than_stop_price",
	9:  "ask_price_greate_equal_stop_price",
	10: "ask_price_less_than_stop_price",
	11: "ask_price_less_equal_stop_price",
	12: "bid_price_greate_than_stop_price",
	13: "bid_price_greate_equal_stop_price",
	14: "bid_price_less_than_stop_price",
	15: "bid_price_less_equal_stop_price",
	16: "close_yesterday_first",
}

var ContingentCondition_value = map[string]int32{
	"immediately":                        0,
	"touch":                              1,
	"touch_profit":                       2,
	"parked_order":                       3,
	"last_price_greate_than_stop_price":  4,
	"last_price_greate_equal_stop_price": 5,
	"last_price_less_than_stop_price":    6,
	"last_price_less_equal_stop_price":   7,
	"ask_price_greate_than_stop_price":   8,
	"ask_price_greate_equal_stop_price":  9,
	"ask_price_less_than_stop_price":     10,
	"ask_price_less_equal_stop_price":    11,
	"bid_price_greate_than_stop_price":   12,
	"bid_price_greate_equal_stop_price":  13,
	"bid_price_less_than_stop_price":     14,
	"bid_price_less_equal_stop_price":    15,
	"close_yesterday_first":              16,
}

func (ContingentCondition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{14}
}

type ForceCloseReason int32

const (
	not_force_close            ForceCloseReason = 0
	lack_deposit               ForceCloseReason = 1
	client_over_position_limit ForceCloseReason = 2
	member_over_position_limit ForceCloseReason = 3
	not_multiple               ForceCloseReason = 4
	violation                  ForceCloseReason = 5
	other                      ForceCloseReason = 6
	person_deliv               ForceCloseReason = 7
)

var ForceCloseReason_name = map[int32]string{
	0: "not_force_close",
	1: "lack_deposit",
	2: "client_over_position_limit",
	3: "member_over_position_limit",
	4: "not_multiple",
	5: "violation",
	6: "other",
	7: "person_deliv",
}

var ForceCloseReason_value = map[string]int32{
	"not_force_close":            0,
	"lack_deposit":               1,
	"client_over_position_limit": 2,
	"member_over_position_limit": 3,
	"not_multiple":               4,
	"violation":                  5,
	"other":                      6,
	"person_deliv":               7,
}

func (ForceCloseReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{15}
}

type OrderSubmitStatus int32

const (
	insert_submitted OrderSubmitStatus = 0
	cancel_submitted OrderSubmitStatus = 1
	modify_submitted OrderSubmitStatus = 2
	accepted         OrderSubmitStatus = 3
	insert_rejected  OrderSubmitStatus = 4
	cancel_rejected  OrderSubmitStatus = 5
	modify_rejected  OrderSubmitStatus = 6
)

var OrderSubmitStatus_name = map[int32]string{
	0: "insert_submitted",
	1: "cancel_submitted",
	2: "modify_submitted",
	3: "accepted",
	4: "insert_rejected",
	5: "cancel_rejected",
	6: "modify_rejected",
}

var OrderSubmitStatus_value = map[string]int32{
	"insert_submitted": 0,
	"cancel_submitted": 1,
	"modify_submitted": 2,
	"accepted":         3,
	"insert_rejected":  4,
	"cancel_rejected":  5,
	"modify_rejected":  6,
}

func (OrderSubmitStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{16}
}

type OrderSource int32

const (
	participant                OrderSource = 0
	administrator              OrderSource = 1
	query_order                OrderSource = 2
	monitor_force_order        OrderSource = 3
	risk_force_order           OrderSource = 4
	monitor_third_order        OrderSource = 5
	real_obj_third_order       OrderSource = 6
	server_condition_order     OrderSource = 7
	server_loss_order          OrderSource = 8
	server_profit_order        OrderSource = 9
	server_loss_ensure_order   OrderSource = 10
	server_profit_ensure_order OrderSource = 11
	server_parked_order        OrderSource = 12
)

var OrderSource_name = map[int32]string{
	0:  "participant",
	1:  "administrator",
	2:  "query_order",
	3:  "monitor_force_order",
	4:  "risk_force_order",
	5:  "monitor_third_order",
	6:  "real_obj_third_order",
	7:  "server_condition_order",
	8:  "server_loss_order",
	9:  "server_profit_order",
	10: "server_loss_ensure_order",
	11: "server_profit_ensure_order",
	12: "server_parked_order",
}

var OrderSource_value = map[string]int32{
	"participant":                0,
	"administrator":              1,
	"query_order":                2,
	"monitor_force_order":        3,
	"risk_force_order":           4,
	"monitor_third_order":        5,
	"real_obj_third_order":       6,
	"server_condition_order":     7,
	"server_loss_order":          8,
	"server_profit_order":        9,
	"server_loss_ensure_order":   10,
	"server_profit_ensure_order": 11,
	"server_parked_order":        12,
}

func (OrderSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{17}
}

type OrderStatus int32

const (
	all_traded               OrderStatus = 0
	part_traded_queueing     OrderStatus = 1
	part_traded_not_queueing OrderStatus = 2
	no_trade_queueing        OrderStatus = 3
	no_trade_not_queueing    OrderStatus = 4
	canceled                 OrderStatus = 5
	unknown                  OrderStatus = 6
	not_touched              OrderStatus = 7
	touched                  OrderStatus = 8
	submitted                OrderStatus = 9
	amending                 OrderStatus = 10
)

var OrderStatus_name = map[int32]string{
	0:  "all_traded",
	1:  "part_traded_queueing",
	2:  "part_traded_not_queueing",
	3:  "no_trade_queueing",
	4:  "no_trade_not_queueing",
	5:  "canceled",
	6:  "unknown",
	7:  "not_touched",
	8:  "touched",
	9:  "submitted",
	10: "amending",
}

var OrderStatus_value = map[string]int32{
	"all_traded":               0,
	"part_traded_queueing":     1,
	"part_traded_not_queueing": 2,
	"no_trade_queueing":        3,
	"no_trade_not_queueing":    4,
	"canceled":                 5,
	"unknown":                  6,
	"not_touched":              7,
	"touched":                  8,
	"submitted":                9,
	"amending":                 10,
}

func (OrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{18}
}

type OrderType int32

const (
	normal                  OrderType = 0
	derive_from_quote       OrderType = 1
	derive_from_combination OrderType = 2
	combination             OrderType = 3
	conditional_order       OrderType = 4
	swap                    OrderType = 5
	financing_buy           OrderType = 6
	sell_repay_money        OrderType = 7
	finacing_sell           OrderType = 8
	repay_stock             OrderType = 9
)

var OrderType_name = map[int32]string{
	0: "normal",
	1: "derive_from_quote",
	2: "derive_from_combination",
	3: "combination",
	4: "conditional_order",
	5: "swap",
	6: "financing_buy",
	7: "sell_repay_money",
	8: "finacing_sell",
	9: "repay_stock",
}

var OrderType_value = map[string]int32{
	"normal":                  0,
	"derive_from_quote":       1,
	"derive_from_combination": 2,
	"combination":             3,
	"conditional_order":       4,
	"swap":                    5,
	"financing_buy":           6,
	"sell_repay_money":        7,
	"finacing_sell":           8,
	"repay_stock":             9,
}

func (OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{19}
}

type PrivilegeType int32

const (
	admin PrivilegeType = 0
	user  PrivilegeType = 1
)

var PrivilegeType_name = map[int32]string{
	0: "admin",
	1: "user",
}

var PrivilegeType_value = map[string]int32{
	"admin": 0,
	"user":  1,
}

func (PrivilegeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{20}
}

type RspInfo struct {
	ErrorId  int32  `protobuf:"varint,1,opt,name=error_id,json=errorId,proto3" json:"error_id,omitempty"`
	ErrorMsg string `protobuf:"bytes,2,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
}

func (m *RspInfo) Reset()      { *m = RspInfo{} }
func (*RspInfo) ProtoMessage() {}
func (*RspInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{0}
}
func (m *RspInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspInfo.Merge(m, src)
}
func (m *RspInfo) XXX_Size() int {
	return m.Size()
}
func (m *RspInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RspInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RspInfo proto.InternalMessageInfo

func (m *RspInfo) GetErrorId() int32 {
	if m != nil {
		return m.ErrorId
	}
	return 0
}

func (m *RspInfo) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type Investor struct {
	BrokerId   string `protobuf:"bytes,1,opt,name=broker_id,json=brokerId,proto3" json:"broker_id,omitempty"`
	InvestorId string `protobuf:"bytes,2,opt,name=investor_id,json=investorId,proto3" json:"investor_id,omitempty"`
}

func (m *Investor) Reset()      { *m = Investor{} }
func (*Investor) ProtoMessage() {}
func (*Investor) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{1}
}
func (m *Investor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Investor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Investor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Investor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Investor.Merge(m, src)
}
func (m *Investor) XXX_Size() int {
	return m.Size()
}
func (m *Investor) XXX_DiscardUnknown() {
	xxx_messageInfo_Investor.DiscardUnknown(m)
}

var xxx_messageInfo_Investor proto.InternalMessageInfo

func (m *Investor) GetBrokerId() string {
	if m != nil {
		return m.BrokerId
	}
	return ""
}

func (m *Investor) GetInvestorId() string {
	if m != nil {
		return m.InvestorId
	}
	return ""
}

type FundMortgage struct {
	PreIn       float64 `protobuf:"fixed64,1,opt,name=pre_in,json=preIn,proto3" json:"pre_in,omitempty"`
	PreOut      float64 `protobuf:"fixed64,2,opt,name=pre_out,json=preOut,proto3" json:"pre_out,omitempty"`
	PreMortgage float64 `protobuf:"fixed64,3,opt,name=pre_mortgage,json=preMortgage,proto3" json:"pre_mortgage,omitempty"`
	CurrentIn   float64 `protobuf:"fixed64,4,opt,name=current_in,json=currentIn,proto3" json:"current_in,omitempty"`
	CurrentOut  float64 `protobuf:"fixed64,5,opt,name=current_out,json=currentOut,proto3" json:"current_out,omitempty"`
	Mortgage    float64 `protobuf:"fixed64,6,opt,name=mortgage,proto3" json:"mortgage,omitempty"`
	Available   float64 `protobuf:"fixed64,7,opt,name=available,proto3" json:"available,omitempty"`
	Mortgagable float64 `protobuf:"fixed64,8,opt,name=mortgagable,proto3" json:"mortgagable,omitempty"`
}

func (m *FundMortgage) Reset()      { *m = FundMortgage{} }
func (*FundMortgage) ProtoMessage() {}
func (*FundMortgage) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{2}
}
func (m *FundMortgage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundMortgage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundMortgage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundMortgage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundMortgage.Merge(m, src)
}
func (m *FundMortgage) XXX_Size() int {
	return m.Size()
}
func (m *FundMortgage) XXX_DiscardUnknown() {
	xxx_messageInfo_FundMortgage.DiscardUnknown(m)
}

var xxx_messageInfo_FundMortgage proto.InternalMessageInfo

func (m *FundMortgage) GetPreIn() float64 {
	if m != nil {
		return m.PreIn
	}
	return 0
}

func (m *FundMortgage) GetPreOut() float64 {
	if m != nil {
		return m.PreOut
	}
	return 0
}

func (m *FundMortgage) GetPreMortgage() float64 {
	if m != nil {
		return m.PreMortgage
	}
	return 0
}

func (m *FundMortgage) GetCurrentIn() float64 {
	if m != nil {
		return m.CurrentIn
	}
	return 0
}

func (m *FundMortgage) GetCurrentOut() float64 {
	if m != nil {
		return m.CurrentOut
	}
	return 0
}

func (m *FundMortgage) GetMortgage() float64 {
	if m != nil {
		return m.Mortgage
	}
	return 0
}

func (m *FundMortgage) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *FundMortgage) GetMortgagable() float64 {
	if m != nil {
		return m.Mortgagable
	}
	return 0
}

type SpecProduct struct {
	Margin              float64 `protobuf:"fixed64,1,opt,name=margin,proto3" json:"margin,omitempty"`
	FrozenMargin        float64 `protobuf:"fixed64,2,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozen_margin,omitempty"`
	Commission          float64 `protobuf:"fixed64,3,opt,name=commission,proto3" json:"commission,omitempty"`
	FrozenCommission    float64 `protobuf:"fixed64,4,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozen_commission,omitempty"`
	PositionProfit      float64 `protobuf:"fixed64,5,opt,name=position_profit,json=positionProfit,proto3" json:"position_profit,omitempty"`
	CloseProfit         float64 `protobuf:"fixed64,6,opt,name=close_profit,json=closeProfit,proto3" json:"close_profit,omitempty"`
	PositionProfitByAlg float64 `protobuf:"fixed64,7,opt,name=position_profit_by_alg,json=positionProfitByAlg,proto3" json:"position_profit_by_alg,omitempty"`
	ExchangeMargin      float64 `protobuf:"fixed64,8,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchange_margin,omitempty"`
}

func (m *SpecProduct) Reset()      { *m = SpecProduct{} }
func (*SpecProduct) ProtoMessage() {}
func (*SpecProduct) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{3}
}
func (m *SpecProduct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecProduct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecProduct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecProduct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecProduct.Merge(m, src)
}
func (m *SpecProduct) XXX_Size() int {
	return m.Size()
}
func (m *SpecProduct) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecProduct.DiscardUnknown(m)
}

var xxx_messageInfo_SpecProduct proto.InternalMessageInfo

func (m *SpecProduct) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *SpecProduct) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *SpecProduct) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *SpecProduct) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *SpecProduct) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *SpecProduct) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *SpecProduct) GetPositionProfitByAlg() float64 {
	if m != nil {
		return m.PositionProfitByAlg
	}
	return 0
}

func (m *SpecProduct) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

type Account struct {
	Investor               *Investor     `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	PreCredit              float64       `protobuf:"fixed64,2,opt,name=pre_credit,json=preCredit,proto3" json:"pre_credit,omitempty"`
	PreDeposit             float64       `protobuf:"fixed64,3,opt,name=pre_deposit,json=preDeposit,proto3" json:"pre_deposit,omitempty"`
	PreBalance             float64       `protobuf:"fixed64,4,opt,name=pre_balance,json=preBalance,proto3" json:"pre_balance,omitempty"`
	PreMargin              float64       `protobuf:"fixed64,5,opt,name=pre_margin,json=preMargin,proto3" json:"pre_margin,omitempty"`
	InterestBase           float64       `protobuf:"fixed64,6,opt,name=interest_base,json=interestBase,proto3" json:"interest_base,omitempty"`
	Interest               float64       `protobuf:"fixed64,7,opt,name=interest,proto3" json:"interest,omitempty"`
	Deposit                float64       `protobuf:"fixed64,8,opt,name=deposit,proto3" json:"deposit,omitempty"`
	Withdraw               float64       `protobuf:"fixed64,9,opt,name=withdraw,proto3" json:"withdraw,omitempty"`
	FrozenMargin           float64       `protobuf:"fixed64,10,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozen_margin,omitempty"`
	FrozenCash             float64       `protobuf:"fixed64,11,opt,name=frozen_cash,json=frozenCash,proto3" json:"frozen_cash,omitempty"`
	FrozenCommission       float64       `protobuf:"fixed64,12,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozen_commission,omitempty"`
	CurrentMargin          float64       `protobuf:"fixed64,13,opt,name=current_margin,json=currentMargin,proto3" json:"current_margin,omitempty"`
	CashIn                 float64       `protobuf:"fixed64,14,opt,name=cash_in,json=cashIn,proto3" json:"cash_in,omitempty"`
	Commission             float64       `protobuf:"fixed64,15,opt,name=commission,proto3" json:"commission,omitempty"`
	CloseProfit            float64       `protobuf:"fixed64,16,opt,name=close_profit,json=closeProfit,proto3" json:"close_profit,omitempty"`
	PositionProfit         float64       `protobuf:"fixed64,17,opt,name=position_profit,json=positionProfit,proto3" json:"position_profit,omitempty"`
	Balance                float64       `protobuf:"fixed64,18,opt,name=balance,proto3" json:"balance,omitempty"`
	Available              float64       `protobuf:"fixed64,19,opt,name=available,proto3" json:"available,omitempty"`
	WithdrawQuota          float64       `protobuf:"fixed64,20,opt,name=withdraw_quota,json=withdrawQuota,proto3" json:"withdraw_quota,omitempty"`
	Reserve                float64       `protobuf:"fixed64,21,opt,name=reserve,proto3" json:"reserve,omitempty"`
	TradingDay             string        `protobuf:"bytes,22,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	SettlementId           int32         `protobuf:"varint,23,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	Credit                 float64       `protobuf:"fixed64,24,opt,name=credit,proto3" json:"credit,omitempty"`
	ExchangeMargin         float64       `protobuf:"fixed64,25,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchange_margin,omitempty"`
	DeliveryMargin         float64       `protobuf:"fixed64,26,opt,name=delivery_margin,json=deliveryMargin,proto3" json:"delivery_margin,omitempty"`
	ExchangeDeliveryMargin float64       `protobuf:"fixed64,27,opt,name=exchange_delivery_margin,json=exchangeDeliveryMargin,proto3" json:"exchange_delivery_margin,omitempty"`
	ReserveBalance         float64       `protobuf:"fixed64,28,opt,name=reserve_balance,json=reserveBalance,proto3" json:"reserve_balance,omitempty"`
	CurrencyId             CurrencyID    `protobuf:"varint,29,opt,name=currency_id,json=currencyId,proto3,enum=service.CurrencyID" json:"currency_id,omitempty"`
	MortgageInfo           *FundMortgage `protobuf:"bytes,30,opt,name=mortgage_info,json=mortgageInfo,proto3" json:"mortgage_info,omitempty"`
	SpecProductInfo        *SpecProduct  `protobuf:"bytes,31,opt,name=spec_product_info,json=specProductInfo,proto3" json:"spec_product_info,omitempty"`
	BusinessType           BusinessType  `protobuf:"varint,32,opt,name=business_type,json=businessType,proto3,enum=service.BusinessType" json:"business_type,omitempty"`
	FrozenSwap             float64       `protobuf:"fixed64,33,opt,name=frozen_swap,json=frozenSwap,proto3" json:"frozen_swap,omitempty"`
	RemainSwap             float64       `protobuf:"fixed64,34,opt,name=remain_swap,json=remainSwap,proto3" json:"remain_swap,omitempty"`
	StockMarketValue       float64       `protobuf:"fixed64,35,opt,name=stock_market_value,json=stockMarketValue,proto3" json:"stock_market_value,omitempty"`
	OptionMarketValue      float64       `protobuf:"fixed64,36,opt,name=option_market_value,json=optionMarketValue,proto3" json:"option_market_value,omitempty"`
	DynamicMoney           float64       `protobuf:"fixed64,37,opt,name=dynamic_money,json=dynamicMoney,proto3" json:"dynamic_money,omitempty"`
	Premium                float64       `protobuf:"fixed64,38,opt,name=premium,proto3" json:"premium,omitempty"`
	MarketValueEquity      float64       `protobuf:"fixed64,39,opt,name=market_value_equity,json=marketValueEquity,proto3" json:"market_value_equity,omitempty"`
}

func (m *Account) Reset()      { *m = Account{} }
func (*Account) ProtoMessage() {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{4}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Account) GetPreCredit() float64 {
	if m != nil {
		return m.PreCredit
	}
	return 0
}

func (m *Account) GetPreDeposit() float64 {
	if m != nil {
		return m.PreDeposit
	}
	return 0
}

func (m *Account) GetPreBalance() float64 {
	if m != nil {
		return m.PreBalance
	}
	return 0
}

func (m *Account) GetPreMargin() float64 {
	if m != nil {
		return m.PreMargin
	}
	return 0
}

func (m *Account) GetInterestBase() float64 {
	if m != nil {
		return m.InterestBase
	}
	return 0
}

func (m *Account) GetInterest() float64 {
	if m != nil {
		return m.Interest
	}
	return 0
}

func (m *Account) GetDeposit() float64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

func (m *Account) GetWithdraw() float64 {
	if m != nil {
		return m.Withdraw
	}
	return 0
}

func (m *Account) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *Account) GetFrozenCash() float64 {
	if m != nil {
		return m.FrozenCash
	}
	return 0
}

func (m *Account) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *Account) GetCurrentMargin() float64 {
	if m != nil {
		return m.CurrentMargin
	}
	return 0
}

func (m *Account) GetCashIn() float64 {
	if m != nil {
		return m.CashIn
	}
	return 0
}

func (m *Account) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *Account) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *Account) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *Account) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *Account) GetWithdrawQuota() float64 {
	if m != nil {
		return m.WithdrawQuota
	}
	return 0
}

func (m *Account) GetReserve() float64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *Account) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *Account) GetSettlementId() int32 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Account) GetCredit() float64 {
	if m != nil {
		return m.Credit
	}
	return 0
}

func (m *Account) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

func (m *Account) GetDeliveryMargin() float64 {
	if m != nil {
		return m.DeliveryMargin
	}
	return 0
}

func (m *Account) GetExchangeDeliveryMargin() float64 {
	if m != nil {
		return m.ExchangeDeliveryMargin
	}
	return 0
}

func (m *Account) GetReserveBalance() float64 {
	if m != nil {
		return m.ReserveBalance
	}
	return 0
}

func (m *Account) GetCurrencyId() CurrencyID {
	if m != nil {
		return m.CurrencyId
	}
	return CNY
}

func (m *Account) GetMortgageInfo() *FundMortgage {
	if m != nil {
		return m.MortgageInfo
	}
	return nil
}

func (m *Account) GetSpecProductInfo() *SpecProduct {
	if m != nil {
		return m.SpecProductInfo
	}
	return nil
}

func (m *Account) GetBusinessType() BusinessType {
	if m != nil {
		return m.BusinessType
	}
	return future
}

func (m *Account) GetFrozenSwap() float64 {
	if m != nil {
		return m.FrozenSwap
	}
	return 0
}

func (m *Account) GetRemainSwap() float64 {
	if m != nil {
		return m.RemainSwap
	}
	return 0
}

func (m *Account) GetStockMarketValue() float64 {
	if m != nil {
		return m.StockMarketValue
	}
	return 0
}

func (m *Account) GetOptionMarketValue() float64 {
	if m != nil {
		return m.OptionMarketValue
	}
	return 0
}

func (m *Account) GetDynamicMoney() float64 {
	if m != nil {
		return m.DynamicMoney
	}
	return 0
}

func (m *Account) GetPremium() float64 {
	if m != nil {
		return m.Premium
	}
	return 0
}

func (m *Account) GetMarketValueEquity() float64 {
	if m != nil {
		return m.MarketValueEquity
	}
	return 0
}

type Position struct {
	Investor          *Investor `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	ProductId         string    `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	InstrumentId      string    `protobuf:"bytes,3,opt,name=instrument_id,json=instrumentId,proto3" json:"instrument_id,omitempty"`
	HedgeFlag         HedgeFlag `protobuf:"varint,4,opt,name=hedge_flag,json=hedgeFlag,proto3,enum=service.HedgeFlag" json:"hedge_flag,omitempty"`
	Direction         Direction `protobuf:"varint,5,opt,name=direction,proto3,enum=service.Direction" json:"direction,omitempty"`
	Volume            int32     `protobuf:"varint,6,opt,name=volume,proto3" json:"volume,omitempty"`
	Margin            float64   `protobuf:"fixed64,7,opt,name=margin,proto3" json:"margin,omitempty"`
	AvgOpenPriceByVol float64   `protobuf:"fixed64,8,opt,name=avg_open_price_by_vol,json=avgOpenPriceByVol,proto3" json:"avg_open_price_by_vol,omitempty"`
	AvgOpenPrice      float64   `protobuf:"fixed64,9,opt,name=avg_open_price,json=avgOpenPrice,proto3" json:"avg_open_price,omitempty"`
	TodayVolume       int32     `protobuf:"varint,10,opt,name=today_volume,json=todayVolume,proto3" json:"today_volume,omitempty"`
	FrozenVolume      int32     `protobuf:"varint,11,opt,name=frozen_volume,json=frozenVolume,proto3" json:"frozen_volume,omitempty"`
	EntryType         uint32    `protobuf:"varint,12,opt,name=entry_type,json=entryType,proto3" json:"entry_type,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{5}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Position) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Position) GetInstrumentId() string {
	if m != nil {
		return m.InstrumentId
	}
	return ""
}

func (m *Position) GetHedgeFlag() HedgeFlag {
	if m != nil {
		return m.HedgeFlag
	}
	return speculation
}

func (m *Position) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return buy
}

func (m *Position) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Position) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *Position) GetAvgOpenPriceByVol() float64 {
	if m != nil {
		return m.AvgOpenPriceByVol
	}
	return 0
}

func (m *Position) GetAvgOpenPrice() float64 {
	if m != nil {
		return m.AvgOpenPrice
	}
	return 0
}

func (m *Position) GetTodayVolume() int32 {
	if m != nil {
		return m.TodayVolume
	}
	return 0
}

func (m *Position) GetFrozenVolume() int32 {
	if m != nil {
		return m.FrozenVolume
	}
	return 0
}

func (m *Position) GetEntryType() uint32 {
	if m != nil {
		return m.EntryType
	}
	return 0
}

type Trade struct {
	Investor             *Investor   `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	InstrumentId         string      `protobuf:"bytes,2,opt,name=instrument_id,json=instrumentId,proto3" json:"instrument_id,omitempty"`
	OrderRef             string      `protobuf:"bytes,3,opt,name=order_ref,json=orderRef,proto3" json:"order_ref,omitempty"`
	UserId               string      `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ExchangeId           string      `protobuf:"bytes,5,opt,name=exchange_id,json=exchangeId,proto3" json:"exchange_id,omitempty"`
	TradeId              string      `protobuf:"bytes,6,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	Direction            Direction   `protobuf:"varint,7,opt,name=direction,proto3,enum=service.Direction" json:"direction,omitempty"`
	OrderSysId           string      `protobuf:"bytes,8,opt,name=order_sys_id,json=orderSysId,proto3" json:"order_sys_id,omitempty"`
	ParticipantId        string      `protobuf:"bytes,9,opt,name=participant_id,json=participantId,proto3" json:"participant_id,omitempty"`
	ClientId             string      `protobuf:"bytes,10,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	TradingRole          TradingRole `protobuf:"varint,11,opt,name=trading_role,json=tradingRole,proto3,enum=service.TradingRole" json:"trading_role,omitempty"`
	ExchangeInstrumentId string      `protobuf:"bytes,12,opt,name=exchange_instrument_id,json=exchangeInstrumentId,proto3" json:"exchange_instrument_id,omitempty"`
	OffsetFlag           OffsetFlag  `protobuf:"varint,13,opt,name=offset_flag,json=offsetFlag,proto3,enum=service.OffsetFlag" json:"offset_flag,omitempty"`
	HedgeFlag            HedgeFlag   `protobuf:"varint,14,opt,name=hedge_flag,json=hedgeFlag,proto3,enum=service.HedgeFlag" json:"hedge_flag,omitempty"`
	Price                float64     `protobuf:"fixed64,15,opt,name=price,proto3" json:"price,omitempty"`
	Volume               int32       `protobuf:"varint,16,opt,name=volume,proto3" json:"volume,omitempty"`
	TradeDate            string      `protobuf:"bytes,17,opt,name=trade_date,json=tradeDate,proto3" json:"trade_date,omitempty"`
	TradeTime            string      `protobuf:"bytes,18,opt,name=trade_time,json=tradeTime,proto3" json:"trade_time,omitempty"`
	TradeType            TradeType   `protobuf:"varint,19,opt,name=trade_type,json=tradeType,proto3,enum=service.TradeType" json:"trade_type,omitempty"`
	PriceSource          PriceSource `protobuf:"varint,20,opt,name=price_source,json=priceSource,proto3,enum=service.PriceSource" json:"price_source,omitempty"`
	TraderId             string      `protobuf:"bytes,21,opt,name=trader_id,json=traderId,proto3" json:"trader_id,omitempty"`
	OrderLocalId         string      `protobuf:"bytes,22,opt,name=order_local_id,json=orderLocalId,proto3" json:"order_local_id,omitempty"`
	ClearingPartId       string      `protobuf:"bytes,23,opt,name=clearing_part_id,json=clearingPartId,proto3" json:"clearing_part_id,omitempty"`
	BusinessUnit         string      `protobuf:"bytes,24,opt,name=business_unit,json=businessUnit,proto3" json:"business_unit,omitempty"`
	SequenceNo           int32       `protobuf:"varint,25,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	TradingDay           string      `protobuf:"bytes,26,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	SettlementId         int32       `protobuf:"varint,27,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	BrokerOrderSeqence   int32       `protobuf:"varint,28,opt,name=broker_order_seqence,json=brokerOrderSeqence,proto3" json:"broker_order_seqence,omitempty"`
	TradeSource          TradeSource `protobuf:"varint,29,opt,name=trade_source,json=tradeSource,proto3,enum=service.TradeSource" json:"trade_source,omitempty"`
	InvestorUnitId       string      `protobuf:"bytes,30,opt,name=investor_unit_id,json=investorUnitId,proto3" json:"investor_unit_id,omitempty"`
}

func (m *Trade) Reset()      { *m = Trade{} }
func (*Trade) ProtoMessage() {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{6}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Trade) GetInstrumentId() string {
	if m != nil {
		return m.InstrumentId
	}
	return ""
}

func (m *Trade) GetOrderRef() string {
	if m != nil {
		return m.OrderRef
	}
	return ""
}

func (m *Trade) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Trade) GetExchangeId() string {
	if m != nil {
		return m.ExchangeId
	}
	return ""
}

func (m *Trade) GetTradeId() string {
	if m != nil {
		return m.TradeId
	}
	return ""
}

func (m *Trade) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return buy
}

func (m *Trade) GetOrderSysId() string {
	if m != nil {
		return m.OrderSysId
	}
	return ""
}

func (m *Trade) GetParticipantId() string {
	if m != nil {
		return m.ParticipantId
	}
	return ""
}

func (m *Trade) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Trade) GetTradingRole() TradingRole {
	if m != nil {
		return m.TradingRole
	}
	return broker
}

func (m *Trade) GetExchangeInstrumentId() string {
	if m != nil {
		return m.ExchangeInstrumentId
	}
	return ""
}

func (m *Trade) GetOffsetFlag() OffsetFlag {
	if m != nil {
		return m.OffsetFlag
	}
	return open
}

func (m *Trade) GetHedgeFlag() HedgeFlag {
	if m != nil {
		return m.HedgeFlag
	}
	return speculation
}

func (m *Trade) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Trade) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Trade) GetTradeDate() string {
	if m != nil {
		return m.TradeDate
	}
	return ""
}

func (m *Trade) GetTradeTime() string {
	if m != nil {
		return m.TradeTime
	}
	return ""
}

func (m *Trade) GetTradeType() TradeType {
	if m != nil {
		return m.TradeType
	}
	return split_combination
}

func (m *Trade) GetPriceSource() PriceSource {
	if m != nil {
		return m.PriceSource
	}
	return ps_last_price
}

func (m *Trade) GetTraderId() string {
	if m != nil {
		return m.TraderId
	}
	return ""
}

func (m *Trade) GetOrderLocalId() string {
	if m != nil {
		return m.OrderLocalId
	}
	return ""
}

func (m *Trade) GetClearingPartId() string {
	if m != nil {
		return m.ClearingPartId
	}
	return ""
}

func (m *Trade) GetBusinessUnit() string {
	if m != nil {
		return m.BusinessUnit
	}
	return ""
}

func (m *Trade) GetSequenceNo() int32 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *Trade) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *Trade) GetSettlementId() int32 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Trade) GetBrokerOrderSeqence() int32 {
	if m != nil {
		return m.BrokerOrderSeqence
	}
	return 0
}

func (m *Trade) GetTradeSource() TradeSource {
	if m != nil {
		return m.TradeSource
	}
	return ts_normal
}

func (m *Trade) GetInvestorUnitId() string {
	if m != nil {
		return m.InvestorUnitId
	}
	return ""
}

type SubInfo struct {
	Investor    *Investor   `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	AccountType AccountType `protobuf:"varint,2,opt,name=account_type,json=accountType,proto3,enum=service.AccountType" json:"account_type,omitempty"`
	SubInfoType SubInfoType `protobuf:"varint,3,opt,name=sub_info_type,json=subInfoType,proto3,enum=service.SubInfoType" json:"sub_info_type,omitempty"`
}

func (m *SubInfo) Reset()      { *m = SubInfo{} }
func (*SubInfo) ProtoMessage() {}
func (*SubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{7}
}
func (m *SubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubInfo.Merge(m, src)
}
func (m *SubInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubInfo proto.InternalMessageInfo

func (m *SubInfo) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *SubInfo) GetAccountType() AccountType {
	if m != nil {
		return m.AccountType
	}
	return virtual
}

func (m *SubInfo) GetSubInfoType() SubInfoType {
	if m != nil {
		return m.SubInfoType
	}
	return order
}

type Order struct {
	Investor             *Investor           `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	InstrumentId         string              `protobuf:"bytes,2,opt,name=instrument_id,json=instrumentId,proto3" json:"instrument_id,omitempty"`
	OrderRef             string              `protobuf:"bytes,3,opt,name=order_ref,json=orderRef,proto3" json:"order_ref,omitempty"`
	PriceType            OrderPriceType      `protobuf:"varint,4,opt,name=price_type,json=priceType,proto3,enum=service.OrderPriceType" json:"price_type,omitempty"`
	Direction            Direction           `protobuf:"varint,5,opt,name=direction,proto3,enum=service.Direction" json:"direction,omitempty"`
	LimitPrice           float64             `protobuf:"fixed64,8,opt,name=limit_price,json=limitPrice,proto3" json:"limit_price,omitempty"`
	VolumeTotalOrigin    int32               `protobuf:"varint,9,opt,name=volume_total_origin,json=volumeTotalOrigin,proto3" json:"volume_total_origin,omitempty"`
	TimeCondition        TimeCondition       `protobuf:"varint,10,opt,name=time_condition,json=timeCondition,proto3,enum=service.TimeCondition" json:"time_condition,omitempty"`
	GtdDate              string              `protobuf:"bytes,11,opt,name=gtd_date,json=gtdDate,proto3" json:"gtd_date,omitempty"`
	VolumeCondition      VolumeCondition     `protobuf:"varint,12,opt,name=volume_condition,json=volumeCondition,proto3,enum=service.VolumeCondition" json:"volume_condition,omitempty"`
	MinVolume            int32               `protobuf:"varint,13,opt,name=min_volume,json=minVolume,proto3" json:"min_volume,omitempty"`
	ContingentCondition  ContingentCondition `protobuf:"varint,14,opt,name=contingent_condition,json=contingentCondition,proto3,enum=service.ContingentCondition" json:"contingent_condition,omitempty"`
	StopPrice            float64             `protobuf:"fixed64,15,opt,name=stop_price,json=stopPrice,proto3" json:"stop_price,omitempty"`
	ForceCloseReason     ForceCloseReason    `protobuf:"varint,17,opt,name=force_close_reason,json=forceCloseReason,proto3,enum=service.ForceCloseReason" json:"force_close_reason,omitempty"`
	IsAutoSuspend        bool                `protobuf:"varint,18,opt,name=is_auto_suspend,json=isAutoSuspend,proto3" json:"is_auto_suspend,omitempty"`
	BusinessUnit         string              `protobuf:"bytes,19,opt,name=business_unit,json=businessUnit,proto3" json:"business_unit,omitempty"`
	RequestId            int64               `protobuf:"varint,20,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	OrderLocalId         string              `protobuf:"bytes,21,opt,name=order_local_id,json=orderLocalId,proto3" json:"order_local_id,omitempty"`
	ExchangeId           string              `protobuf:"bytes,22,opt,name=exchange_id,json=exchangeId,proto3" json:"exchange_id,omitempty"`
	ParticipantId        string              `protobuf:"bytes,23,opt,name=participant_id,json=participantId,proto3" json:"participant_id,omitempty"`
	ClientId             string              `protobuf:"bytes,24,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	ExchangeInstrumentId string              `protobuf:"bytes,25,opt,name=exchange_instrument_id,json=exchangeInstrumentId,proto3" json:"exchange_instrument_id,omitempty"`
	TraderId             string              `protobuf:"bytes,26,opt,name=trader_id,json=traderId,proto3" json:"trader_id,omitempty"`
	InstallId            int32               `protobuf:"varint,27,opt,name=install_id,json=installId,proto3" json:"install_id,omitempty"`
	OrderSubmitStatus    OrderSubmitStatus   `protobuf:"varint,28,opt,name=order_submit_status,json=orderSubmitStatus,proto3,enum=service.OrderSubmitStatus" json:"order_submit_status,omitempty"`
	NotifySequence       int32               `protobuf:"varint,29,opt,name=notify_sequence,json=notifySequence,proto3" json:"notify_sequence,omitempty"`
	TradingDay           string              `protobuf:"bytes,30,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	SettlementId         int32               `protobuf:"varint,31,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	OrderSysId           string              `protobuf:"bytes,32,opt,name=order_sys_id,json=orderSysId,proto3" json:"order_sys_id,omitempty"`
	OrderSource          OrderSource         `protobuf:"varint,33,opt,name=order_source,json=orderSource,proto3,enum=service.OrderSource" json:"order_source,omitempty"`
	OrderStatus          OrderStatus         `protobuf:"varint,34,opt,name=order_status,json=orderStatus,proto3,enum=service.OrderStatus" json:"order_status,omitempty"`
	OrderType            OrderType           `protobuf:"varint,35,opt,name=order_type,json=orderType,proto3,enum=service.OrderType" json:"order_type,omitempty"`
	VolumeTraded         int32               `protobuf:"varint,36,opt,name=volume_traded,json=volumeTraded,proto3" json:"volume_traded,omitempty"`
	VolumeTotal          int32               `protobuf:"varint,37,opt,name=volume_total,json=volumeTotal,proto3" json:"volume_total,omitempty"`
	InsertDate           string              `protobuf:"bytes,38,opt,name=insert_date,json=insertDate,proto3" json:"insert_date,omitempty"`
	InsertTime           string              `protobuf:"bytes,39,opt,name=insert_time,json=insertTime,proto3" json:"insert_time,omitempty"`
	ActiveTime           string              `protobuf:"bytes,40,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	SuspendTime          string              `protobuf:"bytes,41,opt,name=suspend_time,json=suspendTime,proto3" json:"suspend_time,omitempty"`
	UpdateTime           string              `protobuf:"bytes,42,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	CancelTime           string              `protobuf:"bytes,43,opt,name=cancel_time,json=cancelTime,proto3" json:"cancel_time,omitempty"`
	ActiveTraderId       string              `protobuf:"bytes,44,opt,name=active_trader_id,json=activeTraderId,proto3" json:"active_trader_id,omitempty"`
	ClearingPartId       string              `protobuf:"bytes,45,opt,name=clearing_part_id,json=clearingPartId,proto3" json:"clearing_part_id,omitempty"`
	SequenceNo           int32               `protobuf:"varint,46,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	FrontId              int32               `protobuf:"varint,47,opt,name=front_id,json=frontId,proto3" json:"front_id,omitempty"`
	SessionId            int32               `protobuf:"varint,48,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	UserProductInfo      string              `protobuf:"bytes,49,opt,name=user_product_info,json=userProductInfo,proto3" json:"user_product_info,omitempty"`
	StatusMessage        string              `protobuf:"bytes,50,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"`
	UserForceClose       bool                `protobuf:"varint,51,opt,name=user_force_close,json=userForceClose,proto3" json:"user_force_close,omitempty"`
	ActiveUserId         string              `protobuf:"bytes,52,opt,name=active_user_id,json=activeUserId,proto3" json:"active_user_id,omitempty"`
	BrokerOrderSequence  int32               `protobuf:"varint,53,opt,name=broker_order_sequence,json=brokerOrderSequence,proto3" json:"broker_order_sequence,omitempty"`
	RelativeOrderSysId   string              `protobuf:"bytes,54,opt,name=relative_order_sys_id,json=relativeOrderSysId,proto3" json:"relative_order_sys_id,omitempty"`
	ZceTotalTradedVolume int32               `protobuf:"varint,55,opt,name=zce_total_traded_volume,json=zceTotalTradedVolume,proto3" json:"zce_total_traded_volume,omitempty"`
	IsSwapOrder          bool                `protobuf:"varint,56,opt,name=is_swap_order,json=isSwapOrder,proto3" json:"is_swap_order,omitempty"`
	BranchId             string              `protobuf:"bytes,57,opt,name=branch_id,json=branchId,proto3" json:"branch_id,omitempty"`
	InvestUnitId         string              `protobuf:"bytes,58,opt,name=invest_unit_id,json=investUnitId,proto3" json:"invest_unit_id,omitempty"`
	AccountId            string              `protobuf:"bytes,59,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	CurrencyId           CurrencyID          `protobuf:"varint,60,opt,name=currency_id,json=currencyId,proto3,enum=service.CurrencyID" json:"currency_id,omitempty"`
	IpAddress            string              `protobuf:"bytes,61,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	MacAddress           string              `protobuf:"bytes,62,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{8}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Order) GetInstrumentId() string {
	if m != nil {
		return m.InstrumentId
	}
	return ""
}

func (m *Order) GetOrderRef() string {
	if m != nil {
		return m.OrderRef
	}
	return ""
}

func (m *Order) GetPriceType() OrderPriceType {
	if m != nil {
		return m.PriceType
	}
	return any_price
}

func (m *Order) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return buy
}

func (m *Order) GetLimitPrice() float64 {
	if m != nil {
		return m.LimitPrice
	}
	return 0
}

func (m *Order) GetVolumeTotalOrigin() int32 {
	if m != nil {
		return m.VolumeTotalOrigin
	}
	return 0
}

func (m *Order) GetTimeCondition() TimeCondition {
	if m != nil {
		return m.TimeCondition
	}
	return immediate_or_cancel
}

func (m *Order) GetGtdDate() string {
	if m != nil {
		return m.GtdDate
	}
	return ""
}

func (m *Order) GetVolumeCondition() VolumeCondition {
	if m != nil {
		return m.VolumeCondition
	}
	return any_volume
}

func (m *Order) GetMinVolume() int32 {
	if m != nil {
		return m.MinVolume
	}
	return 0
}

func (m *Order) GetContingentCondition() ContingentCondition {
	if m != nil {
		return m.ContingentCondition
	}
	return immediately
}

func (m *Order) GetStopPrice() float64 {
	if m != nil {
		return m.StopPrice
	}
	return 0
}

func (m *Order) GetForceCloseReason() ForceCloseReason {
	if m != nil {
		return m.ForceCloseReason
	}
	return not_force_close
}

func (m *Order) GetIsAutoSuspend() bool {
	if m != nil {
		return m.IsAutoSuspend
	}
	return false
}

func (m *Order) GetBusinessUnit() string {
	if m != nil {
		return m.BusinessUnit
	}
	return ""
}

func (m *Order) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *Order) GetOrderLocalId() string {
	if m != nil {
		return m.OrderLocalId
	}
	return ""
}

func (m *Order) GetExchangeId() string {
	if m != nil {
		return m.ExchangeId
	}
	return ""
}

func (m *Order) GetParticipantId() string {
	if m != nil {
		return m.ParticipantId
	}
	return ""
}

func (m *Order) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Order) GetExchangeInstrumentId() string {
	if m != nil {
		return m.ExchangeInstrumentId
	}
	return ""
}

func (m *Order) GetTraderId() string {
	if m != nil {
		return m.TraderId
	}
	return ""
}

func (m *Order) GetInstallId() int32 {
	if m != nil {
		return m.InstallId
	}
	return 0
}

func (m *Order) GetOrderSubmitStatus() OrderSubmitStatus {
	if m != nil {
		return m.OrderSubmitStatus
	}
	return insert_submitted
}

func (m *Order) GetNotifySequence() int32 {
	if m != nil {
		return m.NotifySequence
	}
	return 0
}

func (m *Order) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *Order) GetSettlementId() int32 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Order) GetOrderSysId() string {
	if m != nil {
		return m.OrderSysId
	}
	return ""
}

func (m *Order) GetOrderSource() OrderSource {
	if m != nil {
		return m.OrderSource
	}
	return participant
}

func (m *Order) GetOrderStatus() OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return all_traded
}

func (m *Order) GetOrderType() OrderType {
	if m != nil {
		return m.OrderType
	}
	return normal
}

func (m *Order) GetVolumeTraded() int32 {
	if m != nil {
		return m.VolumeTraded
	}
	return 0
}

func (m *Order) GetVolumeTotal() int32 {
	if m != nil {
		return m.VolumeTotal
	}
	return 0
}

func (m *Order) GetInsertDate() string {
	if m != nil {
		return m.InsertDate
	}
	return ""
}

func (m *Order) GetInsertTime() string {
	if m != nil {
		return m.InsertTime
	}
	return ""
}

func (m *Order) GetActiveTime() string {
	if m != nil {
		return m.ActiveTime
	}
	return ""
}

func (m *Order) GetSuspendTime() string {
	if m != nil {
		return m.SuspendTime
	}
	return ""
}

func (m *Order) GetUpdateTime() string {
	if m != nil {
		return m.UpdateTime
	}
	return ""
}

func (m *Order) GetCancelTime() string {
	if m != nil {
		return m.CancelTime
	}
	return ""
}

func (m *Order) GetActiveTraderId() string {
	if m != nil {
		return m.ActiveTraderId
	}
	return ""
}

func (m *Order) GetClearingPartId() string {
	if m != nil {
		return m.ClearingPartId
	}
	return ""
}

func (m *Order) GetSequenceNo() int32 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *Order) GetFrontId() int32 {
	if m != nil {
		return m.FrontId
	}
	return 0
}

func (m *Order) GetSessionId() int32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *Order) GetUserProductInfo() string {
	if m != nil {
		return m.UserProductInfo
	}
	return ""
}

func (m *Order) GetStatusMessage() string {
	if m != nil {
		return m.StatusMessage
	}
	return ""
}

func (m *Order) GetUserForceClose() bool {
	if m != nil {
		return m.UserForceClose
	}
	return false
}

func (m *Order) GetActiveUserId() string {
	if m != nil {
		return m.ActiveUserId
	}
	return ""
}

func (m *Order) GetBrokerOrderSequence() int32 {
	if m != nil {
		return m.BrokerOrderSequence
	}
	return 0
}

func (m *Order) GetRelativeOrderSysId() string {
	if m != nil {
		return m.RelativeOrderSysId
	}
	return ""
}

func (m *Order) GetZceTotalTradedVolume() int32 {
	if m != nil {
		return m.ZceTotalTradedVolume
	}
	return 0
}

func (m *Order) GetIsSwapOrder() bool {
	if m != nil {
		return m.IsSwapOrder
	}
	return false
}

func (m *Order) GetBranchId() string {
	if m != nil {
		return m.BranchId
	}
	return ""
}

func (m *Order) GetInvestUnitId() string {
	if m != nil {
		return m.InvestUnitId
	}
	return ""
}

func (m *Order) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *Order) GetCurrencyId() CurrencyID {
	if m != nil {
		return m.CurrencyId
	}
	return CNY
}

func (m *Order) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *Order) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

type RiskUser struct {
	UserId   string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	MacAddr  string `protobuf:"bytes,3,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
}

func (m *RiskUser) Reset()      { *m = RiskUser{} }
func (*RiskUser) ProtoMessage() {}
func (*RiskUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{9}
}
func (m *RiskUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RiskUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RiskUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RiskUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RiskUser.Merge(m, src)
}
func (m *RiskUser) XXX_Size() int {
	return m.Size()
}
func (m *RiskUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RiskUser.DiscardUnknown(m)
}

var xxx_messageInfo_RiskUser proto.InternalMessageInfo

func (m *RiskUser) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *RiskUser) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RiskUser) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

type RspUserLogin struct {
	UserId        string            `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	TradingDay    string            `protobuf:"bytes,2,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	LoginTime     string            `protobuf:"bytes,3,opt,name=login_time,json=loginTime,proto3" json:"login_time,omitempty"`
	PrivilegeType PrivilegeType     `protobuf:"varint,4,opt,name=privilege_type,json=privilegeType,proto3,enum=service.PrivilegeType" json:"privilege_type,omitempty"`
	PrivilegeInfo map[string]string `protobuf:"bytes,5,rep,name=privilege_info,json=privilegeInfo,proto3" json:"privilege_info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RspUserLogin) Reset()      { *m = RspUserLogin{} }
func (*RspUserLogin) ProtoMessage() {}
func (*RspUserLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{10}
}
func (m *RspUserLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspUserLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspUserLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspUserLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspUserLogin.Merge(m, src)
}
func (m *RspUserLogin) XXX_Size() int {
	return m.Size()
}
func (m *RspUserLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_RspUserLogin.DiscardUnknown(m)
}

var xxx_messageInfo_RspUserLogin proto.InternalMessageInfo

func (m *RspUserLogin) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *RspUserLogin) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *RspUserLogin) GetLoginTime() string {
	if m != nil {
		return m.LoginTime
	}
	return ""
}

func (m *RspUserLogin) GetPrivilegeType() PrivilegeType {
	if m != nil {
		return m.PrivilegeType
	}
	return admin
}

func (m *RspUserLogin) GetPrivilegeInfo() map[string]string {
	if m != nil {
		return m.PrivilegeInfo
	}
	return nil
}

type RspUserLogout struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *RspUserLogout) Reset()      { *m = RspUserLogout{} }
func (*RspUserLogout) ProtoMessage() {}
func (*RspUserLogout) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{11}
}
func (m *RspUserLogout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspUserLogout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspUserLogout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspUserLogout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspUserLogout.Merge(m, src)
}
func (m *RspUserLogout) XXX_Size() int {
	return m.Size()
}
func (m *RspUserLogout) XXX_DiscardUnknown() {
	xxx_messageInfo_RspUserLogout.DiscardUnknown(m)
}

var xxx_messageInfo_RspUserLogout proto.InternalMessageInfo

func (m *RspUserLogout) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func init() {
	proto.RegisterEnum("service.CurrencyID", CurrencyID_name, CurrencyID_value)
	proto.RegisterEnum("service.BusinessType", BusinessType_name, BusinessType_value)
	proto.RegisterEnum("service.HedgeFlag", HedgeFlag_name, HedgeFlag_value)
	proto.RegisterEnum("service.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("service.OrderPriceType", OrderPriceType_name, OrderPriceType_value)
	proto.RegisterEnum("service.TradingRole", TradingRole_name, TradingRole_value)
	proto.RegisterEnum("service.OffsetFlag", OffsetFlag_name, OffsetFlag_value)
	proto.RegisterEnum("service.TradeType", TradeType_name, TradeType_value)
	proto.RegisterEnum("service.PriceSource", PriceSource_name, PriceSource_value)
	proto.RegisterEnum("service.TradeSource", TradeSource_name, TradeSource_value)
	proto.RegisterEnum("service.AccountType", AccountType_name, AccountType_value)
	proto.RegisterEnum("service.SubInfoType", SubInfoType_name, SubInfoType_value)
	proto.RegisterEnum("service.TimeCondition", TimeCondition_name, TimeCondition_value)
	proto.RegisterEnum("service.VolumeCondition", VolumeCondition_name, VolumeCondition_value)
	proto.RegisterEnum("service.ContingentCondition", ContingentCondition_name, ContingentCondition_value)
	proto.RegisterEnum("service.ForceCloseReason", ForceCloseReason_name, ForceCloseReason_value)
	proto.RegisterEnum("service.OrderSubmitStatus", OrderSubmitStatus_name, OrderSubmitStatus_value)
	proto.RegisterEnum("service.OrderSource", OrderSource_name, OrderSource_value)
	proto.RegisterEnum("service.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterEnum("service.OrderType", OrderType_name, OrderType_value)
	proto.RegisterEnum("service.PrivilegeType", PrivilegeType_name, PrivilegeType_value)
	proto.RegisterType((*RspInfo)(nil), "service.RspInfo")
	proto.RegisterType((*Investor)(nil), "service.Investor")
	proto.RegisterType((*FundMortgage)(nil), "service.FundMortgage")
	proto.RegisterType((*SpecProduct)(nil), "service.SpecProduct")
	proto.RegisterType((*Account)(nil), "service.Account")
	proto.RegisterType((*Position)(nil), "service.Position")
	proto.RegisterType((*Trade)(nil), "service.Trade")
	proto.RegisterType((*SubInfo)(nil), "service.SubInfo")
	proto.RegisterType((*Order)(nil), "service.Order")
	proto.RegisterType((*RiskUser)(nil), "service.RiskUser")
	proto.RegisterType((*RspUserLogin)(nil), "service.RspUserLogin")
	proto.RegisterMapType((map[string]string)(nil), "service.RspUserLogin.PrivilegeInfoEntry")
	proto.RegisterType((*RspUserLogout)(nil), "service.RspUserLogout")
}

func init() { proto.RegisterFile("structures.proto", fileDescriptor_66ea84bc81126bff) }

var fileDescriptor_66ea84bc81126bff = []byte{
	// 3973 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0x4b, 0x93, 0x1b, 0xc9,
	0x71, 0x1e, 0x60, 0x06, 0x03, 0x20, 0xf1, 0x98, 0x9e, 0x9e, 0x07, 0xc1, 0xe1, 0x12, 0x24, 0x87,
	0xcb, 0x5d, 0x1a, 0x92, 0xe8, 0xe5, 0x90, 0x12, 0x57, 0x6b, 0xcb, 0x21, 0x3e, 0x24, 0x2f, 0x1c,
	0xa2, 0x48, 0x63, 0xb8, 0x1b, 0x61, 0x5f, 0x3a, 0x7a, 0xba, 0x0b, 0x98, 0xd6, 0x74, 0x77, 0x35,
	0xab, 0xbb, 0x87, 0xc2, 0x86, 0x0f, 0xfe, 0x09, 0xb6, 0x7f, 0x82, 0x7d, 0x71, 0x84, 0xef, 0x7e,
	0x1c, 0x7d, 0xb2, 0xc3, 0xa7, 0xf5, 0x4d, 0x3e, 0x38, 0xc2, 0xcb, 0xbd, 0xf8, 0xa8, 0x3f, 0xe0,
	0x08, 0x47, 0x66, 0x56, 0x75, 0x37, 0x1e, 0xf4, 0xae, 0x74, 0xf0, 0xad, 0xeb, 0xcb, 0xac, 0xac,
	0x57, 0xe6, 0x97, 0x59, 0x05, 0x80, 0x95, 0x66, 0x2a, 0xf7, 0xb2, 0x5c, 0x89, 0xf4, 0x5e, 0xa2,
	0x64, 0x26, 0xed, 0x66, 0x2a, 0xd4, 0x65, 0xe0, 0x89, 0xe3, 0xc7, 0xd0, 0x9c, 0xa4, 0xc9, 0x38,
	0x9e, 0x4a, 0xfb, 0x2a, 0xb4, 0x84, 0x52, 0x52, 0x39, 0x81, 0x3f, 0xa8, 0xdd, 0xac, 0xdd, 0x6d,
	0x4c, 0x9a, 0xd4, 0x1e, 0xfb, 0xf6, 0x35, 0x68, 0xb3, 0x28, 0x4a, 0x67, 0x83, 0xfa, 0xcd, 0xda,
	0xdd, 0xf6, 0x84, 0x75, 0x9f, 0xa7, 0xb3, 0xe3, 0x4f, 0xa1, 0x35, 0x8e, 0x2f, 0x45, 0x9a, 0x49,
	0x85, 0x8a, 0x67, 0x4a, 0x5e, 0x88, 0xc2, 0x48, 0x7b, 0xd2, 0x62, 0x60, 0xec, 0xdb, 0x37, 0xa0,
	0x13, 0x68, 0x45, 0x14, 0xb3, 0x1d, 0x30, 0xd0, 0xd8, 0x3f, 0xfe, 0x9f, 0x1a, 0x74, 0x7f, 0x9a,
	0xc7, 0xfe, 0x73, 0xa9, 0xb2, 0x99, 0x3b, 0x13, 0xf6, 0x01, 0x6c, 0x27, 0x4a, 0x38, 0x41, 0x4c,
	0xb6, 0x6a, 0x93, 0x46, 0xa2, 0xc4, 0x38, 0xb6, 0xaf, 0x40, 0x13, 0x61, 0x99, 0x67, 0x64, 0xa4,
	0x36, 0x41, 0xad, 0x17, 0x79, 0x66, 0xdf, 0x82, 0x2e, 0x0a, 0x22, 0xdd, 0x7f, 0xb0, 0x49, 0xd2,
	0x4e, 0xa2, 0x44, 0x61, 0xf2, 0x3a, 0x80, 0x97, 0x2b, 0x25, 0xe2, 0x0c, 0xcd, 0x6e, 0x91, 0x42,
	0x5b, 0x23, 0xe3, 0x18, 0xe7, 0x68, 0xc4, 0x68, 0xbe, 0x41, 0x72, 0xd3, 0x03, 0x87, 0x38, 0x82,
	0x56, 0x61, 0x7e, 0x9b, 0xa4, 0x45, 0xdb, 0x7e, 0x0f, 0xda, 0xee, 0xa5, 0x1b, 0x84, 0xee, 0x59,
	0x28, 0x06, 0x4d, 0x36, 0x5d, 0x00, 0xf6, 0x4d, 0xe8, 0x68, 0x4d, 0x92, 0xb7, 0x78, 0x6e, 0x15,
	0xe8, 0xf8, 0x9f, 0xeb, 0xd0, 0x39, 0x4d, 0x84, 0xf7, 0x52, 0x49, 0x3f, 0xf7, 0x32, 0xfb, 0x10,
	0xb6, 0x23, 0x57, 0xcd, 0x8a, 0xe5, 0xeb, 0x96, 0x7d, 0x1b, 0x7a, 0x53, 0x25, 0xbf, 0x10, 0xb1,
	0xa3, 0xc5, 0xbc, 0x0b, 0x5d, 0x06, 0x9f, 0xb3, 0xd2, 0x10, 0xc0, 0x93, 0x51, 0x14, 0xa4, 0x69,
	0x20, 0x63, 0xbd, 0x13, 0x15, 0xc4, 0xfe, 0x0e, 0xec, 0x6a, 0x23, 0x15, 0x35, 0xde, 0x0f, 0x8b,
	0x05, 0x4f, 0x4b, 0xe5, 0x0f, 0x61, 0x27, 0x91, 0x69, 0x90, 0x05, 0x32, 0x76, 0x12, 0x25, 0xa7,
	0x81, 0xd9, 0x9a, 0xbe, 0x81, 0x5f, 0x12, 0x8a, 0x27, 0xe0, 0x85, 0x32, 0x15, 0x46, 0x8b, 0xb7,
	0xa8, 0x43, 0x98, 0x56, 0x79, 0x00, 0x87, 0x4b, 0xb6, 0x9c, 0xb3, 0xb9, 0xe3, 0x86, 0x33, 0xbd,
	0x65, 0x7b, 0x8b, 0x26, 0x9f, 0xcc, 0x1f, 0x87, 0x33, 0x9c, 0x80, 0xf8, 0xa5, 0x77, 0xee, 0xc6,
	0x33, 0x61, 0x16, 0xcd, 0x1b, 0xd8, 0x37, 0x30, 0x2f, 0xfb, 0xf8, 0x3f, 0x3a, 0xd0, 0x7c, 0xec,
	0x79, 0x32, 0x8f, 0x33, 0xfb, 0x7b, 0xd0, 0x32, 0xde, 0x45, 0x3b, 0xd8, 0x39, 0xd9, 0xbd, 0xa7,
	0x1d, 0xff, 0x9e, 0x71, 0xd9, 0x49, 0xa1, 0x82, 0xae, 0x81, 0xde, 0xe3, 0x29, 0xe1, 0x07, 0xc6,
	0xb3, 0xda, 0x89, 0x12, 0x4f, 0x09, 0x40, 0xd7, 0x40, 0xb1, 0x2f, 0x68, 0x7e, 0x66, 0x47, 0x13,
	0x25, 0x9e, 0x31, 0x62, 0x14, 0xce, 0xdc, 0xd0, 0x8d, 0x3d, 0xa1, 0xf7, 0x12, 0x15, 0x9e, 0x30,
	0x62, 0x06, 0xd0, 0xf3, 0x6f, 0x14, 0x03, 0x3c, 0x2f, 0x8e, 0x35, 0x88, 0x33, 0xa1, 0x44, 0x9a,
	0x39, 0x67, 0x6e, 0x6a, 0xfc, 0xab, 0x6b, 0xc0, 0x27, 0x6e, 0x2a, 0xd0, 0xff, 0x4c, 0x5b, 0xef,
	0x57, 0xd1, 0xb6, 0x07, 0xd0, 0x34, 0xb3, 0xe3, 0xcd, 0x31, 0x4d, 0xec, 0xf5, 0x26, 0xc8, 0xce,
	0x7d, 0xe5, 0xbe, 0x19, 0xb4, 0xb9, 0x97, 0x69, 0xaf, 0x7a, 0x13, 0xac, 0xf1, 0xa6, 0x1b, 0xd0,
	0x31, 0xde, 0xe2, 0xa6, 0xe7, 0x83, 0x0e, 0xaf, 0x4d, 0xfb, 0x89, 0x9b, 0x9e, 0xaf, 0x77, 0xa7,
	0xee, 0x3b, 0xdc, 0xe9, 0x0e, 0xf4, 0x4d, 0x94, 0xe9, 0x31, 0x7b, 0xa4, 0xd9, 0xd3, 0xa8, 0x1e,
	0xf4, 0x0a, 0x34, 0x71, 0x34, 0x0c, 0xd4, 0x3e, 0x07, 0x00, 0x36, 0xc7, 0xcb, 0xbe, 0xbd, 0xb3,
	0xe2, 0xdb, 0xcb, 0x5e, 0x68, 0xad, 0x7a, 0xe1, 0x1a, 0x8f, 0xde, 0x5d, 0xeb, 0xd1, 0x03, 0x68,
	0x9a, 0x13, 0xb5, 0x79, 0x53, 0x75, 0x73, 0x31, 0xdc, 0xf7, 0x96, 0xc3, 0xfd, 0x0e, 0xf4, 0xcd,
	0x16, 0x3b, 0xaf, 0x73, 0x99, 0xb9, 0x83, 0x7d, 0x5e, 0xa3, 0x41, 0xff, 0x18, 0x41, 0x34, 0xaf,
	0x04, 0x3a, 0xa5, 0x18, 0x1c, 0xb0, 0x79, 0xdd, 0xc4, 0x2d, 0xcf, 0x94, 0xeb, 0x07, 0xf1, 0xcc,
	0xf1, 0xdd, 0xf9, 0xe0, 0x90, 0xe9, 0x52, 0x43, 0xcf, 0xdc, 0x39, 0x1e, 0x5c, 0x2a, 0xb2, 0x2c,
	0x14, 0x11, 0xb1, 0x99, 0x3f, 0xb8, 0x42, 0xac, 0xdd, 0x2d, 0xc1, 0xb1, 0x8f, 0x1c, 0xa2, 0x1d,
	0x7a, 0xa0, 0xb7, 0x90, 0xbd, 0x79, 0x4d, 0x40, 0x5d, 0x5d, 0x17, 0x50, 0xa8, 0xe8, 0x8b, 0x30,
	0xb8, 0x14, 0x6a, 0x6e, 0x14, 0x8f, 0x58, 0xd1, 0xc0, 0x5a, 0xf1, 0x63, 0x18, 0x14, 0x16, 0x97,
	0x7b, 0x5c, 0xa3, 0x1e, 0x87, 0x46, 0xfe, 0x6c, 0xb1, 0xe7, 0x87, 0xb0, 0xa3, 0x17, 0x5d, 0x04,
	0xcf, 0x7b, 0x3c, 0x84, 0x86, 0x4d, 0x00, 0x3d, 0x34, 0xec, 0xec, 0xcd, 0x71, 0xbd, 0xd7, 0x6f,
	0xd6, 0xee, 0xf6, 0x4f, 0xf6, 0x8a, 0x98, 0x7e, 0xaa, 0x65, 0xe3, 0x67, 0x86, 0xb2, 0xbd, 0xf9,
	0xd8, 0xb7, 0x3f, 0x81, 0x9e, 0xa1, 0x68, 0x27, 0x88, 0xa7, 0x72, 0x30, 0x24, 0x2e, 0x38, 0x28,
	0xfa, 0x55, 0x73, 0xce, 0xa4, 0x6b, 0x74, 0x29, 0x29, 0xfe, 0x18, 0x76, 0xd3, 0x44, 0x78, 0xe8,
	0x22, 0x48, 0xc9, 0xdc, 0xff, 0x06, 0xf5, 0xdf, 0x2f, 0xfa, 0x57, 0x38, 0x7b, 0xb2, 0x93, 0x96,
	0x0d, 0xb2, 0xf0, 0x09, 0xf4, 0xce, 0xf2, 0x34, 0x88, 0x45, 0x9a, 0x3a, 0xd9, 0x3c, 0x11, 0x83,
	0x9b, 0x34, 0xeb, 0x72, 0xf4, 0x27, 0x5a, 0xfa, 0x6a, 0x9e, 0x88, 0x49, 0xf7, 0xac, 0xd2, 0xaa,
	0x44, 0x5d, 0xfa, 0xc6, 0x4d, 0x06, 0xb7, 0xaa, 0x51, 0x77, 0xfa, 0xc6, 0x4d, 0x50, 0x41, 0x89,
	0xc8, 0x0d, 0xb4, 0xc2, 0x31, 0x2b, 0x30, 0x44, 0x0a, 0xdf, 0x05, 0x3b, 0xcd, 0xa4, 0x77, 0x81,
	0x07, 0x71, 0x21, 0x32, 0xe7, 0xd2, 0x0d, 0x73, 0x31, 0xb8, 0xcd, 0x71, 0x49, 0x92, 0xe7, 0x24,
	0xf8, 0x1c, 0x71, 0xfb, 0x1e, 0xec, 0xc9, 0x84, 0x42, 0x62, 0x41, 0xfd, 0x7d, 0x52, 0xdf, 0x65,
	0x51, 0x55, 0xff, 0x36, 0xf4, 0xfc, 0x79, 0xec, 0x46, 0x81, 0xe7, 0x44, 0x32, 0x16, 0xf3, 0xc1,
	0x1d, 0xa6, 0x0e, 0x0d, 0x3e, 0x47, 0x0c, 0x3d, 0x3c, 0x51, 0x22, 0x0a, 0xf2, 0x68, 0xf0, 0x01,
	0x7b, 0xb8, 0x6e, 0xe2, 0x70, 0xd5, 0x71, 0x1c, 0xf1, 0x3a, 0x0f, 0xb2, 0xf9, 0xe0, 0x43, 0x1e,
	0x2e, 0x2a, 0x07, 0xfa, 0x09, 0x09, 0x8e, 0xff, 0x7d, 0x13, 0x5a, 0x2f, 0x75, 0x74, 0xfe, 0x56,
	0xe4, 0xae, 0xcf, 0xd0, 0xd4, 0x1e, 0x6d, 0x8d, 0x8c, 0x7d, 0xe6, 0x5e, 0x2c, 0x93, 0x4c, 0x2c,
	0x6d, 0x92, 0x46, 0xb7, 0x04, 0xc7, 0xbe, 0x7d, 0x1f, 0xe0, 0x5c, 0xf8, 0x33, 0xe1, 0x4c, 0x43,
	0x77, 0x46, 0xfc, 0xde, 0x3f, 0xb1, 0x8b, 0x41, 0x3f, 0x45, 0xd1, 0x4f, 0x43, 0x77, 0x36, 0x69,
	0x9f, 0x9b, 0x4f, 0xfb, 0x23, 0x68, 0xfb, 0x81, 0x12, 0x1e, 0x4e, 0x99, 0x18, 0xbf, 0xda, 0xe3,
	0x99, 0x91, 0x4c, 0x4a, 0x25, 0x0c, 0xd8, 0x4b, 0x19, 0xe6, 0x11, 0xd3, 0x7f, 0x63, 0xa2, 0x5b,
	0x95, 0x62, 0xa0, 0xb9, 0x50, 0x0c, 0x7c, 0x04, 0x07, 0xee, 0xe5, 0xcc, 0x91, 0x89, 0x40, 0x22,
	0x0b, 0x3c, 0x81, 0xd9, 0xf4, 0x52, 0x86, 0x3a, 0x05, 0xec, 0xba, 0x97, 0xb3, 0x17, 0x89, 0x88,
	0x5f, 0xa2, 0xe8, 0xc9, 0xfc, 0x73, 0x19, 0xda, 0xef, 0x43, 0x7f, 0xb1, 0x87, 0x4e, 0x09, 0xdd,
	0xaa, 0x2a, 0x72, 0x68, 0x26, 0x7d, 0x97, 0x6c, 0xe1, 0x6c, 0x80, 0x66, 0xd3, 0x21, 0xec, 0x73,
	0x9e, 0x52, 0x99, 0x39, 0xb4, 0x4e, 0x87, 0x09, 0x88, 0x41, 0xad, 0x74, 0x1d, 0x40, 0xc4, 0x99,
	0x9a, 0xb3, 0xf3, 0x63, 0x46, 0xe8, 0x4d, 0xda, 0x84, 0xa0, 0x8b, 0x1f, 0xff, 0x4d, 0x1b, 0x1a,
	0xaf, 0x94, 0xeb, 0x8b, 0xdf, 0xf4, 0x40, 0x57, 0x4e, 0xac, 0xbe, 0xe6, 0xc4, 0xae, 0x41, 0x5b,
	0x2a, 0x5f, 0x28, 0x47, 0x89, 0xa9, 0x3e, 0xd2, 0x16, 0x01, 0x13, 0x31, 0xc5, 0xf4, 0x92, 0xa7,
	0x5c, 0xaa, 0x6e, 0x91, 0x68, 0x1b, 0x9b, 0x5c, 0xa8, 0x16, 0x4c, 0x16, 0xf8, 0x74, 0x6c, 0xed,
	0x09, 0x18, 0x68, 0xec, 0x63, 0xa9, 0x8c, 0x3c, 0x4c, 0xd2, 0x6d, 0x92, 0x36, 0xa9, 0x3d, 0xf6,
	0x17, 0x0f, 0xbc, 0xf9, 0x6d, 0x0e, 0xfc, 0x26, 0x74, 0x79, 0x8e, 0xe9, 0x3c, 0x45, 0x83, 0x2d,
	0x1e, 0x8e, 0xb0, 0xd3, 0x79, 0x3a, 0xf6, 0x31, 0x95, 0x24, 0xae, 0xca, 0x02, 0x2f, 0x48, 0x5c,
	0x5e, 0x6b, 0x9b, 0x74, 0x7a, 0x15, 0x94, 0x17, 0xeb, 0x85, 0x81, 0xde, 0x0d, 0xe0, 0xc5, 0x32,
	0x30, 0xf6, 0xed, 0x47, 0xd0, 0x35, 0xd9, 0x44, 0xc9, 0x90, 0x8f, 0xaa, 0x5f, 0xe1, 0xb0, 0x57,
	0x2c, 0x9c, 0xc8, 0x50, 0x4c, 0x4c, 0xde, 0xc1, 0x86, 0xfd, 0x10, 0x0e, 0xcb, 0xcd, 0x58, 0xd8,
	0xf0, 0x2e, 0x0d, 0xb1, 0x5f, 0xec, 0x4b, 0x75, 0xe3, 0x1f, 0x42, 0x47, 0x4e, 0xa7, 0xa9, 0xc8,
	0x38, 0x56, 0x7a, 0x4b, 0x4c, 0xfd, 0x82, 0x64, 0x14, 0x2c, 0x20, 0x8b, 0xef, 0xa5, 0x00, 0xeb,
	0x7f, 0x9b, 0x00, 0xdb, 0x87, 0x06, 0xfb, 0xf0, 0x8e, 0xb9, 0x21, 0xa0, 0xf3, 0x96, 0x41, 0x64,
	0x2d, 0x04, 0xd1, 0x75, 0x00, 0x3e, 0x38, 0xdf, 0xcd, 0x04, 0x25, 0xfc, 0xf6, 0xa4, 0x4d, 0xc8,
	0x33, 0x37, 0xab, 0x88, 0xb3, 0x20, 0xe2, 0x74, 0x6f, 0xc4, 0xaf, 0x82, 0x48, 0xe0, 0xf4, 0xb4,
	0x18, 0x5d, 0x79, 0x6f, 0x69, 0x7a, 0xe4, 0xc5, 0x44, 0xe2, 0xba, 0x0b, 0x32, 0xf8, 0x23, 0xbc,
	0x91, 0x60, 0x50, 0xa6, 0x32, 0x57, 0x9e, 0xa0, 0x1a, 0xa0, 0xba, 0xed, 0x14, 0x6b, 0xa7, 0x24,
	0xc3, 0x7b, 0x4a, 0xd1, 0xc0, 0xc3, 0x24, 0x2b, 0xe4, 0x9e, 0x07, 0x7c, 0x98, 0x0c, 0x8c, 0x7d,
	0x8c, 0x60, 0x76, 0x99, 0x50, 0x7a, 0x6e, 0x88, 0x1a, 0x5c, 0x1d, 0xb0, 0x23, 0xfd, 0x0c, 0xc1,
	0xb1, 0x6f, 0xdf, 0x05, 0xcb, 0x0b, 0x85, 0xab, 0xf0, 0xcc, 0xd1, 0x53, 0x4c, 0x89, 0xd0, 0x9e,
	0xf4, 0x0d, 0xfe, 0xd2, 0x55, 0x9a, 0xfd, 0x8a, 0x1c, 0x95, 0xc7, 0xba, 0x56, 0x68, 0x97, 0xc9,
	0xe8, 0xb3, 0x98, 0xcb, 0xdb, 0x54, 0xbc, 0xce, 0x45, 0xec, 0x09, 0x27, 0x96, 0x54, 0x2d, 0x34,
	0x26, 0x60, 0xa0, 0x9f, 0xcb, 0xe5, 0x82, 0xe5, 0xe8, 0x9b, 0x0b, 0x96, 0x6b, 0x6b, 0x0a, 0x96,
	0x8f, 0x60, 0x5f, 0x5f, 0x21, 0x75, 0x54, 0x88, 0xd7, 0xc2, 0x54, 0x04, 0x8d, 0x89, 0xcd, 0xb2,
	0x17, 0x14, 0x1c, 0x2c, 0x31, 0xae, 0x5d, 0xec, 0xf1, 0xf5, 0x35, 0xae, 0x5d, 0xec, 0x71, 0x56,
	0x36, 0x70, 0x83, 0x8a, 0x0b, 0x29, 0x2e, 0x1b, 0xa7, 0x34, 0xe4, 0x0d, 0x32, 0x38, 0xae, 0x7c,
	0xec, 0x1f, 0xff, 0x5d, 0x0d, 0x9a, 0xa7, 0xf9, 0x19, 0x25, 0xf4, 0xdf, 0x90, 0xa7, 0x1e, 0x41,
	0xd7, 0xe5, 0xfb, 0x08, 0xbb, 0x4d, 0x7d, 0x69, 0x76, 0xfa, 0xb2, 0x42, 0x8e, 0xd3, 0x71, 0xcb,
	0x86, 0xfd, 0x31, 0xf4, 0xd2, 0xfc, 0x8c, 0x2a, 0x0e, 0xee, 0xb9, 0xb9, 0xd4, 0x53, 0x4f, 0x88,
	0x7b, 0xa6, 0x65, 0xe3, 0xf8, 0x2f, 0xf7, 0xa0, 0x41, 0x3b, 0xf4, 0xff, 0xcf, 0xa9, 0x3f, 0xc0,
	0x34, 0x8b, 0xfe, 0x4e, 0x33, 0xe6, 0x14, 0x79, 0xa5, 0x0c, 0x7b, 0x54, 0x23, 0x97, 0xe7, 0x38,
	0x49, 0xcc, 0xe7, 0x6f, 0x91, 0x27, 0x6f, 0x40, 0x27, 0x0c, 0xa2, 0x20, 0xd3, 0x29, 0x8c, 0xb3,
	0x1d, 0x10, 0xc4, 0x09, 0xec, 0x1e, 0xec, 0x71, 0xd4, 0x3b, 0x99, 0xcc, 0xdc, 0xd0, 0x91, 0x2a,
	0xc0, 0xec, 0xd9, 0x26, 0x3f, 0xda, 0x65, 0xd1, 0x2b, 0x94, 0xbc, 0x20, 0x81, 0xfd, 0x23, 0xe8,
	0x63, 0xd8, 0x3b, 0x9e, 0x8c, 0x7d, 0x2a, 0x31, 0x88, 0x43, 0xfb, 0x27, 0x87, 0xa5, 0x23, 0x05,
	0x91, 0x78, 0x6a, 0xa4, 0x93, 0x5e, 0x56, 0x6d, 0x62, 0x4e, 0x98, 0x65, 0x3e, 0x13, 0x4b, 0x87,
	0x73, 0xc2, 0x2c, 0xf3, 0x89, 0x56, 0x9e, 0x82, 0xa5, 0x67, 0x52, 0xda, 0xee, 0x92, 0xed, 0x41,
	0x61, 0x9b, 0xb3, 0x65, 0x69, 0x7d, 0xe7, 0x72, 0x11, 0x40, 0x6e, 0x8a, 0x82, 0x22, 0xd3, 0xf6,
	0x68, 0x15, 0xed, 0x28, 0x30, 0x69, 0xf6, 0x05, 0xec, 0x7b, 0x32, 0xce, 0x82, 0x78, 0x86, 0x47,
	0x57, 0x8e, 0xc3, 0x24, 0xfa, 0x5e, 0x59, 0x23, 0x17, 0x4a, 0xe5, 0x58, 0x7b, 0xde, 0x2a, 0x88,
	0xe3, 0xa5, 0x99, 0x4c, 0x9c, 0x2a, 0xbb, 0xb6, 0x11, 0xe1, 0xdd, 0xfd, 0x43, 0xb0, 0xa7, 0x52,
	0x79, 0xc2, 0xe1, 0x8b, 0x96, 0x12, 0x6e, 0x2a, 0x63, 0x62, 0xd4, 0xfe, 0xc9, 0xd5, 0xb2, 0xb2,
	0x46, 0x95, 0xa7, 0xa8, 0x31, 0x21, 0x85, 0x89, 0x35, 0x5d, 0x42, 0xec, 0x0f, 0x60, 0x27, 0x48,
	0x1d, 0x37, 0xcf, 0xa4, 0x93, 0xe6, 0x69, 0x22, 0x62, 0x9f, 0x88, 0xb7, 0x35, 0xe9, 0x05, 0xe9,
	0xe3, 0x3c, 0x93, 0xa7, 0x0c, 0xae, 0x72, 0xd4, 0xde, 0x1a, 0x8e, 0xba, 0x0e, 0xa0, 0x90, 0x90,
	0x52, 0xf2, 0x5e, 0x24, 0xdb, 0xcd, 0x49, 0x5b, 0x23, 0x6b, 0x79, 0xf3, 0x60, 0x0d, 0x6f, 0x2e,
	0xa5, 0xff, 0xc3, 0x95, 0xf4, 0xbf, 0x9a, 0x8f, 0xaf, 0x7c, 0x63, 0x3e, 0x1e, 0x2c, 0xe5, 0xe3,
	0x77, 0xa7, 0xd5, 0xab, 0xff, 0x47, 0x5a, 0x5d, 0xc8, 0x0a, 0x47, 0x4b, 0x59, 0xe1, 0x3a, 0x00,
	0x5a, 0x72, 0xc3, 0xb0, 0xe4, 0xd6, 0xb6, 0x46, 0xc6, 0xbe, 0xfd, 0x47, 0xb0, 0xa7, 0x19, 0x35,
	0x3f, 0xc3, 0xb8, 0x49, 0x33, 0x37, 0xcb, 0x53, 0xe2, 0xd5, 0xfe, 0xc9, 0xd1, 0x62, 0x8c, 0x9e,
	0x92, 0xca, 0x29, 0x69, 0x4c, 0x76, 0xe5, 0x32, 0x84, 0x37, 0xb6, 0x58, 0x66, 0xc1, 0x74, 0xee,
	0x18, 0xfe, 0x27, 0xd6, 0x6d, 0x4c, 0xfa, 0x0c, 0x9f, 0x6a, 0x74, 0x39, 0x27, 0x0c, 0xbf, 0x39,
	0x27, 0xdc, 0x58, 0x93, 0x13, 0x96, 0x4b, 0xa4, 0x9b, 0x2b, 0x25, 0xd2, 0xa3, 0x42, 0x83, 0x73,
	0xc0, 0xad, 0x25, 0xae, 0xe4, 0x55, 0xe9, 0x1c, 0x20, 0xcb, 0x46, 0xa5, 0x23, 0x6f, 0xc7, 0xf1,
	0xda, 0x8e, 0xbc, 0x11, 0xba, 0x23, 0x6f, 0xc1, 0x7d, 0xe0, 0xf1, 0x99, 0xe9, 0x6e, 0x2f, 0x51,
	0x16, 0x75, 0x63, 0x92, 0x93, 0xe6, 0x13, 0xd7, 0x6a, 0x18, 0x09, 0xcf, 0xcc, 0xa7, 0x8b, 0x55,
	0x63, 0xd2, 0xd5, 0x5c, 0x44, 0x18, 0xd6, 0xdd, 0x55, 0xda, 0xa2, 0x2b, 0x55, 0x63, 0xd2, 0xa9,
	0xf0, 0x15, 0x3f, 0xa4, 0xa6, 0x42, 0x65, 0xcc, 0x36, 0x1f, 0x98, 0x87, 0x54, 0x84, 0x88, 0x70,
	0x4a, 0x05, 0x2a, 0x64, 0x3e, 0xac, 0x2a, 0x50, 0x25, 0x73, 0x03, 0x3a, 0xae, 0x97, 0x05, 0x97,
	0xba, 0xd2, 0xb9, 0xcb, 0x0a, 0x0c, 0x91, 0xc2, 0x2d, 0xe8, 0xea, 0x68, 0x64, 0x8d, 0xdf, 0x21,
	0x8d, 0x8e, 0xc6, 0x8c, 0x8d, 0x3c, 0xc1, 0x09, 0xb0, 0xc6, 0x88, 0x6d, 0x30, 0x64, 0x14, 0x3c,
	0xbc, 0xb6, 0x87, 0xac, 0xf0, 0x1d, 0x56, 0x60, 0x88, 0x14, 0xee, 0x82, 0x65, 0x66, 0x51, 0x38,
	0xf5, 0x77, 0x39, 0xff, 0xea, 0xa9, 0x18, 0xd7, 0x5e, 0x57, 0xca, 0x7c, 0x6f, 0x6d, 0x29, 0xb3,
	0x54, 0xa5, 0xdc, 0x5b, 0xa9, 0x52, 0xae, 0x42, 0x6b, 0xaa, 0x24, 0xfb, 0xda, 0xef, 0xf2, 0x33,
	0x37, 0xb5, 0x39, 0x80, 0x52, 0x41, 0x2f, 0x48, 0x28, 0xfc, 0x88, 0x03, 0x48, 0x23, 0x63, 0xdf,
	0x1e, 0xc1, 0x2e, 0xdd, 0x17, 0x16, 0xde, 0x02, 0xee, 0xd3, 0x2c, 0x76, 0x50, 0x50, 0xbd, 0xf5,
	0xdf, 0x81, 0x3e, 0x3b, 0x94, 0x13, 0x89, 0x34, 0x75, 0x67, 0x62, 0x70, 0xc2, 0x14, 0xc1, 0xe8,
	0x73, 0x06, 0x71, 0x5d, 0x64, 0xb2, 0x42, 0xa5, 0x83, 0x07, 0xc4, 0x7e, 0x7d, 0xc4, 0x4b, 0xfa,
	0xa4, 0x4b, 0x1b, 0xef, 0x95, 0xb9, 0xb3, 0x3c, 0x64, 0xea, 0x62, 0xf4, 0x33, 0xbe, 0xb9, 0x9c,
	0xc0, 0xc1, 0x72, 0xf1, 0xc4, 0xd1, 0xf9, 0x7d, 0x5a, 0xcc, 0xde, 0x62, 0xf5, 0xc4, 0x21, 0x7a,
	0x1f, 0x0e, 0x94, 0x08, 0x5d, 0xb2, 0xbd, 0x10, 0x65, 0x3f, 0xa0, 0x01, 0x6c, 0x23, 0x7c, 0x51,
	0x46, 0xdb, 0xf7, 0xe1, 0xca, 0x17, 0x9e, 0xc9, 0xab, 0xec, 0xcb, 0x26, 0x31, 0x3d, 0xa2, 0x81,
	0xf6, 0xbf, 0xf0, 0xd8, 0x57, 0xd9, 0xa9, 0x75, 0x8e, 0x3a, 0x86, 0x5e, 0x90, 0xd2, 0x4b, 0x05,
	0x0f, 0x34, 0xf8, 0x98, 0x96, 0xda, 0x09, 0xd2, 0xd3, 0x37, 0x6e, 0xc2, 0x15, 0x0b, 0xfd, 0x82,
	0xe0, 0xc6, 0xde, 0x39, 0xce, 0xe0, 0x87, 0xe6, 0x17, 0x04, 0x04, 0x98, 0xbf, 0xb9, 0x56, 0x29,
	0xca, 0xb5, 0x4f, 0x4c, 0x81, 0x82, 0x28, 0x17, 0x6b, 0x78, 0x8c, 0xa6, 0xe2, 0x0a, 0xfc, 0xc1,
	0xef, 0x71, 0x15, 0xaf, 0x11, 0xbe, 0x9a, 0x54, 0x1f, 0x91, 0x7e, 0xff, 0xdb, 0x3d, 0x22, 0x21,
	0xb9, 0x26, 0x8e, 0xeb, 0xfb, 0x4a, 0xa4, 0xe9, 0xe0, 0x47, 0x6c, 0x34, 0x48, 0x1e, 0x33, 0x80,
	0x6e, 0x17, 0xb9, 0x5e, 0x21, 0xff, 0x03, 0xf6, 0xf5, 0xc8, 0xf5, 0xb4, 0xc2, 0xf1, 0x9f, 0x42,
	0x6b, 0x12, 0xa4, 0x17, 0x78, 0x4e, 0xd5, 0x8b, 0x67, 0x6d, 0xe1, 0xe2, 0x79, 0x04, 0xad, 0xc4,
	0x4d, 0xd3, 0x37, 0x52, 0x99, 0xd2, 0xab, 0x68, 0xa3, 0xdf, 0x9a, 0x11, 0x74, 0xd5, 0xd5, 0xd4,
	0xe6, 0x8f, 0xff, 0xa9, 0x0e, 0xdd, 0x49, 0x9a, 0xa0, 0xed, 0x9f, 0x49, 0xfd, 0x70, 0xba, 0x7e,
	0x80, 0x25, 0x3a, 0xae, 0xaf, 0xd0, 0xf1, 0x75, 0x80, 0x10, 0x4d, 0x70, 0xc8, 0xf2, 0x38, 0x6d,
	0x42, 0x28, 0x62, 0x7f, 0x04, 0xfd, 0x44, 0x05, 0x97, 0x41, 0x28, 0x66, 0x0b, 0x25, 0xde, 0x61,
	0xf5, 0x42, 0xc3, 0x62, 0x22, 0xbf, 0x5e, 0x52, 0x6d, 0xda, 0x2f, 0xaa, 0xdd, 0x29, 0x7c, 0x1a,
	0x37, 0x37, 0xef, 0x76, 0x4e, 0xee, 0x16, 0xdd, 0xab, 0xcb, 0x28, 0x6d, 0x61, 0x48, 0xfd, 0x24,
	0xce, 0xd4, 0xbc, 0x62, 0x10, 0xb1, 0xa3, 0x1f, 0x83, 0xbd, 0xaa, 0x64, 0x5b, 0xb0, 0x79, 0x21,
	0xe6, 0x7a, 0xe9, 0xf8, 0x89, 0xb7, 0x44, 0x7e, 0xca, 0xe2, 0x15, 0x73, 0xe3, 0x93, 0xfa, 0xc7,
	0xb5, 0xe3, 0xbb, 0xd0, 0x2b, 0xc7, 0x94, 0x79, 0xf6, 0xce, 0xbd, 0x1b, 0x0d, 0x01, 0x4a, 0xdf,
	0xb0, 0x9b, 0xb0, 0xf9, 0xf4, 0xe7, 0x7f, 0x62, 0x6d, 0xe0, 0xc7, 0x67, 0xa7, 0xcf, 0xac, 0xda,
	0xe8, 0x0e, 0x74, 0xab, 0x4f, 0x79, 0x36, 0xc0, 0xf6, 0x34, 0xcf, 0x72, 0x25, 0xac, 0x0d, 0xbb,
	0x0d, 0x0d, 0x7a, 0x6c, 0xb3, 0x6a, 0xa3, 0x4f, 0xa1, 0x5d, 0x5c, 0x64, 0xed, 0x1d, 0xe8, 0xa4,
	0x89, 0xf0, 0x72, 0x8c, 0x30, 0x19, 0x5b, 0x1b, 0x76, 0x0f, 0xda, 0xae, 0x3a, 0x0b, 0x32, 0xe5,
	0xce, 0x84, 0x55, 0xc3, 0x7e, 0x74, 0xd5, 0xb5, 0xea, 0xb6, 0x05, 0x5d, 0xfd, 0x58, 0x16, 0xb9,
	0x17, 0x42, 0x59, 0x9b, 0xa3, 0x47, 0xd0, 0x2e, 0x2a, 0x63, 0x9c, 0xc6, 0x59, 0x3e, 0xb7, 0x36,
	0xec, 0x16, 0x6c, 0x85, 0x32, 0x9e, 0xf1, 0x57, 0x2a, 0xc2, 0x90, 0xcd, 0xa4, 0xe7, 0x52, 0x65,
	0x56, 0xed, 0xa8, 0x6e, 0xd5, 0x46, 0x5f, 0x6f, 0x42, 0x7f, 0xb1, 0x14, 0xa7, 0x71, 0xe3, 0x39,
	0x17, 0x7b, 0xd6, 0x06, 0xce, 0xab, 0x52, 0x5c, 0x5b, 0x35, 0xbb, 0x0f, 0x70, 0x86, 0x71, 0xc7,
	0xed, 0x3a, 0xb6, 0x43, 0xb7, 0x68, 0x6f, 0xda, 0xfb, 0x60, 0x95, 0x6d, 0x27, 0x09, 0xf3, 0xf4,
	0xbe, 0xb5, 0xb5, 0x06, 0x3d, 0xb1, 0x1a, 0x6b, 0xd0, 0x07, 0xd6, 0x36, 0xcd, 0x20, 0xbd, 0xd0,
	0x06, 0x9b, 0xf6, 0x1e, 0xec, 0x14, 0x4d, 0x6d, 0xaf, 0xb5, 0x0a, 0x9e, 0x58, 0xed, 0x55, 0xf0,
	0x81, 0x05, 0x68, 0xed, 0x2c, 0xf0, 0xb5, 0xb5, 0x0e, 0xea, 0x14, 0x4d, 0x6d, 0xad, 0xbb, 0x0a,
	0x9e, 0x58, 0xbd, 0x55, 0xf0, 0x81, 0xd5, 0xc7, 0x19, 0x4f, 0x91, 0x1e, 0x43, 0x71, 0x29, 0x42,
	0x6d, 0x74, 0x07, 0x51, 0xaa, 0x90, 0x43, 0x99, 0xa6, 0xfa, 0xc1, 0xd4, 0xb2, 0xd0, 0x40, 0x89,
	0xd2, 0x26, 0x5a, 0xbb, 0x38, 0x9d, 0x59, 0xe6, 0xe9, 0xa6, 0x8d, 0xbb, 0xc7, 0xaf, 0xb2, 0xa1,
	0x88, 0x7d, 0x6b, 0xcf, 0xbe, 0x02, 0x7b, 0xdc, 0x9e, 0x06, 0xb1, 0x1b, 0x7b, 0x18, 0x9e, 0x78,
	0x98, 0xfb, 0x38, 0x84, 0x12, 0x89, 0x3b, 0x77, 0x58, 0x8c, 0x11, 0x67, 0x1d, 0xa0, 0x2b, 0x88,
	0x6c, 0xea, 0x24, 0xb9, 0xf2, 0xce, 0xdd, 0x54, 0x58, 0x87, 0xb6, 0x0d, 0x7d, 0x44, 0x94, 0xf0,
	0x45, 0x44, 0xaf, 0xb4, 0xd6, 0x95, 0xd1, 0x3d, 0xe8, 0x54, 0x1e, 0x75, 0xd0, 0x1d, 0x99, 0xfd,
	0xd9, 0x33, 0xce, 0x65, 0x9a, 0xb1, 0x67, 0xb0, 0x3b, 0xd5, 0x47, 0x7f, 0x06, 0x50, 0x3e, 0xcb,
	0xa0, 0x8a, 0x4c, 0x44, 0xcc, 0xbe, 0x4b, 0x89, 0xc9, 0xaa, 0xa1, 0x5b, 0x54, 0x32, 0x95, 0x55,
	0x47, 0x80, 0xeb, 0x7f, 0x7a, 0x16, 0xb4, 0x36, 0x71, 0xf5, 0x0c, 0xcc, 0x45, 0x9a, 0x09, 0x85,
	0xe0, 0x16, 0xae, 0x9e, 0xbb, 0xc9, 0xe9, 0xd4, 0x6a, 0xa0, 0x0e, 0xd7, 0xdf, 0x25, 0xb8, 0x3d,
	0xfa, 0xc7, 0x1a, 0xb4, 0x8b, 0x17, 0x14, 0xfb, 0x00, 0x76, 0xd3, 0x24, 0x0c, 0xf0, 0x22, 0x13,
	0x9d, 0x05, 0xb1, 0x89, 0x0e, 0x80, 0x6d, 0x4f, 0x46, 0x91, 0x8c, 0xad, 0x1a, 0xaa, 0xf0, 0x83,
	0x74, 0xea, 0x88, 0x5f, 0x0a, 0x2f, 0x27, 0x95, 0x3a, 0xc6, 0x81, 0xcc, 0x3c, 0x6b, 0x13, 0xa7,
	0x26, 0xa6, 0x89, 0xe3, 0x0b, 0x15, 0x5c, 0x0a, 0xdf, 0xda, 0xc2, 0x4d, 0xae, 0x58, 0x2b, 0x04,
	0x0d, 0xdc, 0x4e, 0xdc, 0xf7, 0x62, 0xdb, 0xb7, 0x97, 0xb7, 0x1d, 0x2f, 0x27, 0x56, 0xd3, 0x3e,
	0x04, 0xbb, 0x8a, 0x46, 0x6e, 0x9c, 0xbb, 0xa1, 0xd5, 0x1a, 0xfd, 0x10, 0x3a, 0x95, 0x67, 0x1c,
	0x7b, 0x17, 0x7a, 0x49, 0xea, 0x54, 0xa2, 0x83, 0xe6, 0x9d, 0xa4, 0x64, 0xbb, 0x66, 0x77, 0xa0,
	0x99, 0xa4, 0x0e, 0x05, 0x66, 0x7d, 0x34, 0xe2, 0x33, 0x32, 0x5d, 0x7b, 0xd0, 0xce, 0x52, 0x27,
	0x96, 0x2a, 0x72, 0x43, 0x6b, 0xc3, 0xee, 0x42, 0x2b, 0x4b, 0x9d, 0xd7, 0xb9, 0x50, 0x73, 0xab,
	0x36, 0x7a, 0x08, 0x9d, 0xca, 0x5b, 0x01, 0xda, 0xb9, 0x0c, 0x54, 0x96, 0x93, 0x66, 0x0b, 0xb6,
	0x94, 0x70, 0x43, 0x0e, 0x54, 0xfc, 0x72, 0x66, 0x4a, 0xe6, 0x89, 0x55, 0x1f, 0xdd, 0x86, 0x4e,
	0xe5, 0x9d, 0x00, 0x0f, 0x93, 0x52, 0x2f, 0x9f, 0x2b, 0xa5, 0x6e, 0xab, 0x36, 0xfa, 0xab, 0x1a,
	0xf4, 0x16, 0x2e, 0xb7, 0xb8, 0x59, 0x41, 0x14, 0x09, 0x3f, 0xc0, 0xfa, 0x4e, 0x2a, 0x87, 0xab,
	0x36, 0x6b, 0x03, 0xb7, 0x66, 0x26, 0xa5, 0x8f, 0x67, 0xe7, 0xa4, 0xcc, 0x3d, 0x56, 0x0d, 0xb7,
	0xb0, 0x40, 0xf1, 0xcc, 0xeb, 0xe8, 0x91, 0x84, 0x64, 0x41, 0x18, 0x52, 0x99, 0x6a, 0x6d, 0xe2,
	0x06, 0x96, 0x18, 0x5b, 0xa4, 0x93, 0xa9, 0xda, 0x74, 0x73, 0xb6, 0xd9, 0x18, 0x3d, 0x86, 0x9d,
	0xa5, 0x4b, 0x31, 0x2e, 0x0e, 0x59, 0x8a, 0x4b, 0x0d, 0x6b, 0x03, 0xdb, 0xe5, 0x9d, 0x98, 0x17,
	0x8f, 0xb7, 0x1f, 0xdd, 0xae, 0x8f, 0xfe, 0x7e, 0x0b, 0xf6, 0xd6, 0x5c, 0x78, 0xd1, 0x37, 0x8a,
	0xd5, 0x85, 0x73, 0xbd, 0x17, 0x32, 0xf7, 0xce, 0x79, 0x29, 0xf4, 0xa9, 0x7f, 0x15, 0x64, 0xe6,
	0x4d, 0x30, 0xba, 0x7d, 0xae, 0x5a, 0xac, 0x4d, 0xfb, 0x0e, 0xdc, 0xaa, 0x30, 0xd8, 0x4c, 0x09,
	0xaa, 0x82, 0xcf, 0xdd, 0xd8, 0x29, 0xaf, 0xcc, 0xd6, 0x96, 0xfd, 0x01, 0x1c, 0xaf, 0xaa, 0x89,
	0xd7, 0xb9, 0x1b, 0x56, 0xf5, 0x1a, 0xf6, 0x6d, 0xb8, 0x51, 0xd1, 0x0b, 0xe9, 0x97, 0xa2, 0x25,
	0x63, 0xdb, 0xf6, 0xfb, 0x70, 0x73, 0x59, 0x69, 0xc5, 0x54, 0x13, 0xb5, 0x4a, 0x32, 0x7c, 0xc7,
	0xc4, 0x5a, 0x38, 0xff, 0x15, 0xad, 0x15, 0x63, 0x6d, 0xfb, 0x18, 0x86, 0xa5, 0xda, 0xda, 0x69,
	0x01, 0xce, 0x7d, 0x49, 0x67, 0xc5, 0x50, 0x07, 0x67, 0x55, 0x92, 0xea, 0x3b, 0x66, 0xd5, 0xc5,
	0x59, 0xad, 0x68, 0xad, 0x18, 0xeb, 0xe1, 0xac, 0x4a, 0xb5, 0xb5, 0xb3, 0xea, 0xe3, 0xac, 0x96,
	0x74, 0x56, 0x0c, 0xed, 0xd8, 0x57, 0xe1, 0x60, 0x89, 0xab, 0x9c, 0x69, 0xa0, 0xd2, 0xcc, 0xb2,
	0x46, 0xff, 0x50, 0x03, 0x6b, 0xf9, 0xed, 0x02, 0x79, 0x2b, 0x96, 0x59, 0xb5, 0x56, 0xb7, 0x36,
	0xd0, 0x39, 0x42, 0xd7, 0xbb, 0x30, 0x7f, 0x0b, 0xb0, 0x6a, 0xf6, 0x10, 0x8e, 0xf4, 0xb5, 0x5f,
	0x5e, 0xe2, 0x6d, 0xc1, 0xfc, 0xca, 0xcc, 0xe4, 0x5f, 0x47, 0x79, 0x24, 0xa2, 0x33, 0xac, 0xd1,
	0xd7, 0xc8, 0x37, 0xd1, 0x22, 0x0e, 0x13, 0xe5, 0x61, 0x16, 0x24, 0xa1, 0x60, 0xfe, 0xbc, 0x0c,
	0xa4, 0xae, 0x11, 0x1a, 0x14, 0xc3, 0xd9, 0xb9, 0x50, 0xd6, 0x36, 0xb9, 0xa6, 0x50, 0x29, 0xd1,
	0x59, 0x18, 0x5c, 0x5a, 0xcd, 0xd1, 0x5f, 0xd7, 0x60, 0x77, 0xe5, 0x0a, 0x8f, 0x11, 0xa6, 0x2f,
	0x84, 0x7c, 0xf9, 0xcf, 0x84, 0xcf, 0xb1, 0xac, 0x2f, 0x68, 0x25, 0x5a, 0x43, 0x34, 0x92, 0x3e,
	0xdd, 0xed, 0x0b, 0xb4, 0x8e, 0x5c, 0xe4, 0x7a, 0x9e, 0x48, 0xb0, 0x45, 0x34, 0xaf, 0xed, 0x29,
	0xf1, 0x0b, 0xe1, 0x65, 0x14, 0xc6, 0xc8, 0xfd, 0x6c, 0xae, 0x00, 0x89, 0xec, 0xb5, 0xb5, 0x02,
	0xdc, 0x1e, 0xfd, 0x4b, 0x1d, 0x3a, 0x95, 0x1b, 0x39, 0xc6, 0x63, 0xe5, 0xe9, 0xc4, 0xda, 0x40,
	0x0e, 0x75, 0xfd, 0x28, 0x88, 0x83, 0x34, 0x53, 0x6e, 0x26, 0x15, 0xe7, 0x1e, 0x62, 0x42, 0x1d,
	0x84, 0x75, 0xa4, 0xa8, 0x48, 0xc6, 0x41, 0x26, 0xcd, 0xf5, 0xc9, 0x44, 0x27, 0xb2, 0x77, 0x90,
	0x5e, 0x2c, 0xa0, 0x5b, 0x55, 0xf5, 0xec, 0x3c, 0x50, 0x26, 0x98, 0x1b, 0xf6, 0x00, 0xf6, 0x89,
	0x31, 0xe5, 0xd9, 0x2f, 0x16, 0x24, 0xdb, 0xf6, 0x11, 0x1c, 0xd2, 0xcf, 0xcf, 0xaa, 0x7c, 0x4f,
	0xd3, 0xb2, 0x26, 0x65, 0x28, 0x96, 0x51, 0xa2, 0x67, 0xb8, 0x45, 0x99, 0x9c, 0x61, 0xfd, 0xd7,
	0x16, 0x16, 0xb4, 0xed, 0xf7, 0x60, 0x50, 0xd5, 0x17, 0x71, 0x9a, 0x2b, 0x33, 0x39, 0x40, 0x9f,
	0x58, 0xec, 0xb6, 0x20, 0xef, 0x54, 0xcd, 0x56, 0x99, 0xa8, 0x3b, 0xfa, 0xcf, 0x9a, 0xd9, 0x49,
	0x3e, 0x68, 0xcd, 0x80, 0x7c, 0x27, 0xb3, 0x36, 0x70, 0x71, 0x74, 0x5f, 0xd6, 0x97, 0xb4, 0xd7,
	0xb9, 0xc8, 0x45, 0x10, 0xcf, 0xac, 0x1a, 0x4e, 0xa8, 0x2a, 0x41, 0x97, 0x2b, 0xa4, 0x75, 0x5c,
	0x5e, 0x2c, 0x59, 0x56, 0xc2, 0x9b, 0x18, 0x32, 0x05, 0xbc, 0xd0, 0x63, 0x0b, 0x1d, 0xa4, 0xa0,
	0xf4, 0x06, 0x66, 0xa7, 0x3c, 0xbe, 0x88, 0xe5, 0x9b, 0xd8, 0xda, 0xc6, 0xa3, 0x43, 0x65, 0xa2,
	0x55, 0xe1, 0x5b, 0x4d, 0x94, 0x9a, 0x46, 0x0b, 0xbd, 0xbb, 0x74, 0xb4, 0x36, 0x39, 0x5a, 0x24,
	0x62, 0xac, 0x5b, 0x2c, 0x18, 0xfd, 0x5b, 0x0d, 0xda, 0xc5, 0x5b, 0x0a, 0xe6, 0xd1, 0x22, 0x39,
	0x1e, 0xc0, 0x2e, 0xa7, 0x70, 0x67, 0xaa, 0x64, 0x44, 0x7f, 0xb1, 0xc0, 0x14, 0x70, 0x0d, 0xae,
	0x54, 0xe1, 0x6a, 0xfd, 0xc0, 0xe5, 0x4a, 0x05, 0xd8, 0x44, 0x23, 0xc5, 0xd1, 0xd2, 0x13, 0x31,
	0xfb, 0x0a, 0x56, 0xce, 0x6f, 0xdc, 0xc4, 0x6a, 0xa0, 0x23, 0x2e, 0xd6, 0x64, 0x54, 0x1c, 0x60,
	0xf6, 0x76, 0xb8, 0x16, 0xa0, 0xdf, 0xbd, 0xad, 0xa6, 0x51, 0x24, 0x3d, 0x4a, 0xee, 0x2d, 0x1c,
	0xad, 0x52, 0x2f, 0x58, 0xed, 0xd1, 0xfb, 0xd0, 0x5b, 0xb8, 0x1e, 0x61, 0x24, 0x93, 0x9b, 0x73,
	0x06, 0xc7, 0x7b, 0x86, 0x55, 0x7b, 0xf2, 0xf0, 0xcb, 0xaf, 0x86, 0x1b, 0xbf, 0xfa, 0x6a, 0xb8,
	0xf1, 0xeb, 0xaf, 0x86, 0xb5, 0x3f, 0x7f, 0x3b, 0xac, 0xfd, 0xed, 0xdb, 0x61, 0xed, 0x5f, 0xdf,
	0x0e, 0x6b, 0x5f, 0xbe, 0x1d, 0xd6, 0xfe, 0xeb, 0xed, 0xb0, 0xf6, 0xdf, 0x6f, 0x87, 0x1b, 0xbf,
	0x7e, 0x3b, 0xac, 0xfd, 0xc5, 0xd7, 0xc3, 0x8d, 0x2f, 0xbf, 0x1e, 0x6e, 0xfc, 0xea, 0xeb, 0xe1,
	0xc6, 0xd9, 0x36, 0xfd, 0xb1, 0xef, 0xc1, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x43, 0xcf, 0xc3,
	0x1e, 0xec, 0x27, 0x00, 0x00,
}

func (x CurrencyID) String() string {
	s, ok := CurrencyID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BusinessType) String() string {
	s, ok := BusinessType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HedgeFlag) String() string {
	s, ok := HedgeFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Direction) String() string {
	s, ok := Direction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderPriceType) String() string {
	s, ok := OrderPriceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradingRole) String() string {
	s, ok := TradingRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OffsetFlag) String() string {
	s, ok := OffsetFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradeType) String() string {
	s, ok := TradeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PriceSource) String() string {
	s, ok := PriceSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradeSource) String() string {
	s, ok := TradeSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccountType) String() string {
	s, ok := AccountType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SubInfoType) String() string {
	s, ok := SubInfoType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TimeCondition) String() string {
	s, ok := TimeCondition_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VolumeCondition) String() string {
	s, ok := VolumeCondition_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContingentCondition) String() string {
	s, ok := ContingentCondition_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ForceCloseReason) String() string {
	s, ok := ForceCloseReason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderSubmitStatus) String() string {
	s, ok := OrderSubmitStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderSource) String() string {
	s, ok := OrderSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderStatus) String() string {
	s, ok := OrderStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderType) String() string {
	s, ok := OrderType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PrivilegeType) String() string {
	s, ok := PrivilegeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *RspInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspInfo)
	if !ok {
		that2, ok := that.(RspInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ErrorId != that1.ErrorId {
		return false
	}
	if this.ErrorMsg != that1.ErrorMsg {
		return false
	}
	return true
}
func (this *Investor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Investor)
	if !ok {
		that2, ok := that.(Investor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BrokerId != that1.BrokerId {
		return false
	}
	if this.InvestorId != that1.InvestorId {
		return false
	}
	return true
}
func (this *FundMortgage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FundMortgage)
	if !ok {
		that2, ok := that.(FundMortgage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PreIn != that1.PreIn {
		return false
	}
	if this.PreOut != that1.PreOut {
		return false
	}
	if this.PreMortgage != that1.PreMortgage {
		return false
	}
	if this.CurrentIn != that1.CurrentIn {
		return false
	}
	if this.CurrentOut != that1.CurrentOut {
		return false
	}
	if this.Mortgage != that1.Mortgage {
		return false
	}
	if this.Available != that1.Available {
		return false
	}
	if this.Mortgagable != that1.Mortgagable {
		return false
	}
	return true
}
func (this *SpecProduct) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecProduct)
	if !ok {
		that2, ok := that.(SpecProduct)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Margin != that1.Margin {
		return false
	}
	if this.FrozenMargin != that1.FrozenMargin {
		return false
	}
	if this.Commission != that1.Commission {
		return false
	}
	if this.FrozenCommission != that1.FrozenCommission {
		return false
	}
	if this.PositionProfit != that1.PositionProfit {
		return false
	}
	if this.CloseProfit != that1.CloseProfit {
		return false
	}
	if this.PositionProfitByAlg != that1.PositionProfitByAlg {
		return false
	}
	if this.ExchangeMargin != that1.ExchangeMargin {
		return false
	}
	return true
}
func (this *Account) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Account)
	if !ok {
		that2, ok := that.(Account)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.PreCredit != that1.PreCredit {
		return false
	}
	if this.PreDeposit != that1.PreDeposit {
		return false
	}
	if this.PreBalance != that1.PreBalance {
		return false
	}
	if this.PreMargin != that1.PreMargin {
		return false
	}
	if this.InterestBase != that1.InterestBase {
		return false
	}
	if this.Interest != that1.Interest {
		return false
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	if this.Withdraw != that1.Withdraw {
		return false
	}
	if this.FrozenMargin != that1.FrozenMargin {
		return false
	}
	if this.FrozenCash != that1.FrozenCash {
		return false
	}
	if this.FrozenCommission != that1.FrozenCommission {
		return false
	}
	if this.CurrentMargin != that1.CurrentMargin {
		return false
	}
	if this.CashIn != that1.CashIn {
		return false
	}
	if this.Commission != that1.Commission {
		return false
	}
	if this.CloseProfit != that1.CloseProfit {
		return false
	}
	if this.PositionProfit != that1.PositionProfit {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if this.Available != that1.Available {
		return false
	}
	if this.WithdrawQuota != that1.WithdrawQuota {
		return false
	}
	if this.Reserve != that1.Reserve {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.SettlementId != that1.SettlementId {
		return false
	}
	if this.Credit != that1.Credit {
		return false
	}
	if this.ExchangeMargin != that1.ExchangeMargin {
		return false
	}
	if this.DeliveryMargin != that1.DeliveryMargin {
		return false
	}
	if this.ExchangeDeliveryMargin != that1.ExchangeDeliveryMargin {
		return false
	}
	if this.ReserveBalance != that1.ReserveBalance {
		return false
	}
	if this.CurrencyId != that1.CurrencyId {
		return false
	}
	if !this.MortgageInfo.Equal(that1.MortgageInfo) {
		return false
	}
	if !this.SpecProductInfo.Equal(that1.SpecProductInfo) {
		return false
	}
	if this.BusinessType != that1.BusinessType {
		return false
	}
	if this.FrozenSwap != that1.FrozenSwap {
		return false
	}
	if this.RemainSwap != that1.RemainSwap {
		return false
	}
	if this.StockMarketValue != that1.StockMarketValue {
		return false
	}
	if this.OptionMarketValue != that1.OptionMarketValue {
		return false
	}
	if this.DynamicMoney != that1.DynamicMoney {
		return false
	}
	if this.Premium != that1.Premium {
		return false
	}
	if this.MarketValueEquity != that1.MarketValueEquity {
		return false
	}
	return true
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.InstrumentId != that1.InstrumentId {
		return false
	}
	if this.HedgeFlag != that1.HedgeFlag {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Margin != that1.Margin {
		return false
	}
	if this.AvgOpenPriceByVol != that1.AvgOpenPriceByVol {
		return false
	}
	if this.AvgOpenPrice != that1.AvgOpenPrice {
		return false
	}
	if this.TodayVolume != that1.TodayVolume {
		return false
	}
	if this.FrozenVolume != that1.FrozenVolume {
		return false
	}
	if this.EntryType != that1.EntryType {
		return false
	}
	return true
}
func (this *Trade) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Trade)
	if !ok {
		that2, ok := that.(Trade)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.InstrumentId != that1.InstrumentId {
		return false
	}
	if this.OrderRef != that1.OrderRef {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.ExchangeId != that1.ExchangeId {
		return false
	}
	if this.TradeId != that1.TradeId {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.OrderSysId != that1.OrderSysId {
		return false
	}
	if this.ParticipantId != that1.ParticipantId {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if this.TradingRole != that1.TradingRole {
		return false
	}
	if this.ExchangeInstrumentId != that1.ExchangeInstrumentId {
		return false
	}
	if this.OffsetFlag != that1.OffsetFlag {
		return false
	}
	if this.HedgeFlag != that1.HedgeFlag {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.TradeDate != that1.TradeDate {
		return false
	}
	if this.TradeTime != that1.TradeTime {
		return false
	}
	if this.TradeType != that1.TradeType {
		return false
	}
	if this.PriceSource != that1.PriceSource {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.OrderLocalId != that1.OrderLocalId {
		return false
	}
	if this.ClearingPartId != that1.ClearingPartId {
		return false
	}
	if this.BusinessUnit != that1.BusinessUnit {
		return false
	}
	if this.SequenceNo != that1.SequenceNo {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.SettlementId != that1.SettlementId {
		return false
	}
	if this.BrokerOrderSeqence != that1.BrokerOrderSeqence {
		return false
	}
	if this.TradeSource != that1.TradeSource {
		return false
	}
	if this.InvestorUnitId != that1.InvestorUnitId {
		return false
	}
	return true
}
func (this *SubInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubInfo)
	if !ok {
		that2, ok := that.(SubInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.AccountType != that1.AccountType {
		return false
	}
	if this.SubInfoType != that1.SubInfoType {
		return false
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.InstrumentId != that1.InstrumentId {
		return false
	}
	if this.OrderRef != that1.OrderRef {
		return false
	}
	if this.PriceType != that1.PriceType {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.LimitPrice != that1.LimitPrice {
		return false
	}
	if this.VolumeTotalOrigin != that1.VolumeTotalOrigin {
		return false
	}
	if this.TimeCondition != that1.TimeCondition {
		return false
	}
	if this.GtdDate != that1.GtdDate {
		return false
	}
	if this.VolumeCondition != that1.VolumeCondition {
		return false
	}
	if this.MinVolume != that1.MinVolume {
		return false
	}
	if this.ContingentCondition != that1.ContingentCondition {
		return false
	}
	if this.StopPrice != that1.StopPrice {
		return false
	}
	if this.ForceCloseReason != that1.ForceCloseReason {
		return false
	}
	if this.IsAutoSuspend != that1.IsAutoSuspend {
		return false
	}
	if this.BusinessUnit != that1.BusinessUnit {
		return false
	}
	if this.RequestId != that1.RequestId {
		return false
	}
	if this.OrderLocalId != that1.OrderLocalId {
		return false
	}
	if this.ExchangeId != that1.ExchangeId {
		return false
	}
	if this.ParticipantId != that1.ParticipantId {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if this.ExchangeInstrumentId != that1.ExchangeInstrumentId {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.InstallId != that1.InstallId {
		return false
	}
	if this.OrderSubmitStatus != that1.OrderSubmitStatus {
		return false
	}
	if this.NotifySequence != that1.NotifySequence {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.SettlementId != that1.SettlementId {
		return false
	}
	if this.OrderSysId != that1.OrderSysId {
		return false
	}
	if this.OrderSource != that1.OrderSource {
		return false
	}
	if this.OrderStatus != that1.OrderStatus {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if this.VolumeTraded != that1.VolumeTraded {
		return false
	}
	if this.VolumeTotal != that1.VolumeTotal {
		return false
	}
	if this.InsertDate != that1.InsertDate {
		return false
	}
	if this.InsertTime != that1.InsertTime {
		return false
	}
	if this.ActiveTime != that1.ActiveTime {
		return false
	}
	if this.SuspendTime != that1.SuspendTime {
		return false
	}
	if this.UpdateTime != that1.UpdateTime {
		return false
	}
	if this.CancelTime != that1.CancelTime {
		return false
	}
	if this.ActiveTraderId != that1.ActiveTraderId {
		return false
	}
	if this.ClearingPartId != that1.ClearingPartId {
		return false
	}
	if this.SequenceNo != that1.SequenceNo {
		return false
	}
	if this.FrontId != that1.FrontId {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	if this.UserProductInfo != that1.UserProductInfo {
		return false
	}
	if this.StatusMessage != that1.StatusMessage {
		return false
	}
	if this.UserForceClose != that1.UserForceClose {
		return false
	}
	if this.ActiveUserId != that1.ActiveUserId {
		return false
	}
	if this.BrokerOrderSequence != that1.BrokerOrderSequence {
		return false
	}
	if this.RelativeOrderSysId != that1.RelativeOrderSysId {
		return false
	}
	if this.ZceTotalTradedVolume != that1.ZceTotalTradedVolume {
		return false
	}
	if this.IsSwapOrder != that1.IsSwapOrder {
		return false
	}
	if this.BranchId != that1.BranchId {
		return false
	}
	if this.InvestUnitId != that1.InvestUnitId {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	if this.CurrencyId != that1.CurrencyId {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	if this.MacAddress != that1.MacAddress {
		return false
	}
	return true
}
func (this *RiskUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RiskUser)
	if !ok {
		that2, ok := that.(RiskUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.MacAddr != that1.MacAddr {
		return false
	}
	return true
}
func (this *RspUserLogin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspUserLogin)
	if !ok {
		that2, ok := that.(RspUserLogin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.LoginTime != that1.LoginTime {
		return false
	}
	if this.PrivilegeType != that1.PrivilegeType {
		return false
	}
	if len(this.PrivilegeInfo) != len(that1.PrivilegeInfo) {
		return false
	}
	for i := range this.PrivilegeInfo {
		if this.PrivilegeInfo[i] != that1.PrivilegeInfo[i] {
			return false
		}
	}
	return true
}
func (this *RspUserLogout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspUserLogout)
	if !ok {
		that2, ok := that.(RspUserLogout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	return true
}
func (this *RspInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service.RspInfo{")
	s = append(s, "ErrorId: "+fmt.Sprintf("%#v", this.ErrorId)+",\n")
	s = append(s, "ErrorMsg: "+fmt.Sprintf("%#v", this.ErrorMsg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Investor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service.Investor{")
	s = append(s, "BrokerId: "+fmt.Sprintf("%#v", this.BrokerId)+",\n")
	s = append(s, "InvestorId: "+fmt.Sprintf("%#v", this.InvestorId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FundMortgage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&service.FundMortgage{")
	s = append(s, "PreIn: "+fmt.Sprintf("%#v", this.PreIn)+",\n")
	s = append(s, "PreOut: "+fmt.Sprintf("%#v", this.PreOut)+",\n")
	s = append(s, "PreMortgage: "+fmt.Sprintf("%#v", this.PreMortgage)+",\n")
	s = append(s, "CurrentIn: "+fmt.Sprintf("%#v", this.CurrentIn)+",\n")
	s = append(s, "CurrentOut: "+fmt.Sprintf("%#v", this.CurrentOut)+",\n")
	s = append(s, "Mortgage: "+fmt.Sprintf("%#v", this.Mortgage)+",\n")
	s = append(s, "Available: "+fmt.Sprintf("%#v", this.Available)+",\n")
	s = append(s, "Mortgagable: "+fmt.Sprintf("%#v", this.Mortgagable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecProduct) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&service.SpecProduct{")
	s = append(s, "Margin: "+fmt.Sprintf("%#v", this.Margin)+",\n")
	s = append(s, "FrozenMargin: "+fmt.Sprintf("%#v", this.FrozenMargin)+",\n")
	s = append(s, "Commission: "+fmt.Sprintf("%#v", this.Commission)+",\n")
	s = append(s, "FrozenCommission: "+fmt.Sprintf("%#v", this.FrozenCommission)+",\n")
	s = append(s, "PositionProfit: "+fmt.Sprintf("%#v", this.PositionProfit)+",\n")
	s = append(s, "CloseProfit: "+fmt.Sprintf("%#v", this.CloseProfit)+",\n")
	s = append(s, "PositionProfitByAlg: "+fmt.Sprintf("%#v", this.PositionProfitByAlg)+",\n")
	s = append(s, "ExchangeMargin: "+fmt.Sprintf("%#v", this.ExchangeMargin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Account) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 43)
	s = append(s, "&service.Account{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "PreCredit: "+fmt.Sprintf("%#v", this.PreCredit)+",\n")
	s = append(s, "PreDeposit: "+fmt.Sprintf("%#v", this.PreDeposit)+",\n")
	s = append(s, "PreBalance: "+fmt.Sprintf("%#v", this.PreBalance)+",\n")
	s = append(s, "PreMargin: "+fmt.Sprintf("%#v", this.PreMargin)+",\n")
	s = append(s, "InterestBase: "+fmt.Sprintf("%#v", this.InterestBase)+",\n")
	s = append(s, "Interest: "+fmt.Sprintf("%#v", this.Interest)+",\n")
	s = append(s, "Deposit: "+fmt.Sprintf("%#v", this.Deposit)+",\n")
	s = append(s, "Withdraw: "+fmt.Sprintf("%#v", this.Withdraw)+",\n")
	s = append(s, "FrozenMargin: "+fmt.Sprintf("%#v", this.FrozenMargin)+",\n")
	s = append(s, "FrozenCash: "+fmt.Sprintf("%#v", this.FrozenCash)+",\n")
	s = append(s, "FrozenCommission: "+fmt.Sprintf("%#v", this.FrozenCommission)+",\n")
	s = append(s, "CurrentMargin: "+fmt.Sprintf("%#v", this.CurrentMargin)+",\n")
	s = append(s, "CashIn: "+fmt.Sprintf("%#v", this.CashIn)+",\n")
	s = append(s, "Commission: "+fmt.Sprintf("%#v", this.Commission)+",\n")
	s = append(s, "CloseProfit: "+fmt.Sprintf("%#v", this.CloseProfit)+",\n")
	s = append(s, "PositionProfit: "+fmt.Sprintf("%#v", this.PositionProfit)+",\n")
	s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	s = append(s, "Available: "+fmt.Sprintf("%#v", this.Available)+",\n")
	s = append(s, "WithdrawQuota: "+fmt.Sprintf("%#v", this.WithdrawQuota)+",\n")
	s = append(s, "Reserve: "+fmt.Sprintf("%#v", this.Reserve)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "SettlementId: "+fmt.Sprintf("%#v", this.SettlementId)+",\n")
	s = append(s, "Credit: "+fmt.Sprintf("%#v", this.Credit)+",\n")
	s = append(s, "ExchangeMargin: "+fmt.Sprintf("%#v", this.ExchangeMargin)+",\n")
	s = append(s, "DeliveryMargin: "+fmt.Sprintf("%#v", this.DeliveryMargin)+",\n")
	s = append(s, "ExchangeDeliveryMargin: "+fmt.Sprintf("%#v", this.ExchangeDeliveryMargin)+",\n")
	s = append(s, "ReserveBalance: "+fmt.Sprintf("%#v", this.ReserveBalance)+",\n")
	s = append(s, "CurrencyId: "+fmt.Sprintf("%#v", this.CurrencyId)+",\n")
	if this.MortgageInfo != nil {
		s = append(s, "MortgageInfo: "+fmt.Sprintf("%#v", this.MortgageInfo)+",\n")
	}
	if this.SpecProductInfo != nil {
		s = append(s, "SpecProductInfo: "+fmt.Sprintf("%#v", this.SpecProductInfo)+",\n")
	}
	s = append(s, "BusinessType: "+fmt.Sprintf("%#v", this.BusinessType)+",\n")
	s = append(s, "FrozenSwap: "+fmt.Sprintf("%#v", this.FrozenSwap)+",\n")
	s = append(s, "RemainSwap: "+fmt.Sprintf("%#v", this.RemainSwap)+",\n")
	s = append(s, "StockMarketValue: "+fmt.Sprintf("%#v", this.StockMarketValue)+",\n")
	s = append(s, "OptionMarketValue: "+fmt.Sprintf("%#v", this.OptionMarketValue)+",\n")
	s = append(s, "DynamicMoney: "+fmt.Sprintf("%#v", this.DynamicMoney)+",\n")
	s = append(s, "Premium: "+fmt.Sprintf("%#v", this.Premium)+",\n")
	s = append(s, "MarketValueEquity: "+fmt.Sprintf("%#v", this.MarketValueEquity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&service.Position{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "InstrumentId: "+fmt.Sprintf("%#v", this.InstrumentId)+",\n")
	s = append(s, "HedgeFlag: "+fmt.Sprintf("%#v", this.HedgeFlag)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Margin: "+fmt.Sprintf("%#v", this.Margin)+",\n")
	s = append(s, "AvgOpenPriceByVol: "+fmt.Sprintf("%#v", this.AvgOpenPriceByVol)+",\n")
	s = append(s, "AvgOpenPrice: "+fmt.Sprintf("%#v", this.AvgOpenPrice)+",\n")
	s = append(s, "TodayVolume: "+fmt.Sprintf("%#v", this.TodayVolume)+",\n")
	s = append(s, "FrozenVolume: "+fmt.Sprintf("%#v", this.FrozenVolume)+",\n")
	s = append(s, "EntryType: "+fmt.Sprintf("%#v", this.EntryType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Trade) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 34)
	s = append(s, "&service.Trade{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "InstrumentId: "+fmt.Sprintf("%#v", this.InstrumentId)+",\n")
	s = append(s, "OrderRef: "+fmt.Sprintf("%#v", this.OrderRef)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ExchangeId: "+fmt.Sprintf("%#v", this.ExchangeId)+",\n")
	s = append(s, "TradeId: "+fmt.Sprintf("%#v", this.TradeId)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "OrderSysId: "+fmt.Sprintf("%#v", this.OrderSysId)+",\n")
	s = append(s, "ParticipantId: "+fmt.Sprintf("%#v", this.ParticipantId)+",\n")
	s = append(s, "ClientId: "+fmt.Sprintf("%#v", this.ClientId)+",\n")
	s = append(s, "TradingRole: "+fmt.Sprintf("%#v", this.TradingRole)+",\n")
	s = append(s, "ExchangeInstrumentId: "+fmt.Sprintf("%#v", this.ExchangeInstrumentId)+",\n")
	s = append(s, "OffsetFlag: "+fmt.Sprintf("%#v", this.OffsetFlag)+",\n")
	s = append(s, "HedgeFlag: "+fmt.Sprintf("%#v", this.HedgeFlag)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "TradeDate: "+fmt.Sprintf("%#v", this.TradeDate)+",\n")
	s = append(s, "TradeTime: "+fmt.Sprintf("%#v", this.TradeTime)+",\n")
	s = append(s, "TradeType: "+fmt.Sprintf("%#v", this.TradeType)+",\n")
	s = append(s, "PriceSource: "+fmt.Sprintf("%#v", this.PriceSource)+",\n")
	s = append(s, "TraderId: "+fmt.Sprintf("%#v", this.TraderId)+",\n")
	s = append(s, "OrderLocalId: "+fmt.Sprintf("%#v", this.OrderLocalId)+",\n")
	s = append(s, "ClearingPartId: "+fmt.Sprintf("%#v", this.ClearingPartId)+",\n")
	s = append(s, "BusinessUnit: "+fmt.Sprintf("%#v", this.BusinessUnit)+",\n")
	s = append(s, "SequenceNo: "+fmt.Sprintf("%#v", this.SequenceNo)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "SettlementId: "+fmt.Sprintf("%#v", this.SettlementId)+",\n")
	s = append(s, "BrokerOrderSeqence: "+fmt.Sprintf("%#v", this.BrokerOrderSeqence)+",\n")
	s = append(s, "TradeSource: "+fmt.Sprintf("%#v", this.TradeSource)+",\n")
	s = append(s, "InvestorUnitId: "+fmt.Sprintf("%#v", this.InvestorUnitId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&service.SubInfo{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "AccountType: "+fmt.Sprintf("%#v", this.AccountType)+",\n")
	s = append(s, "SubInfoType: "+fmt.Sprintf("%#v", this.SubInfoType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 63)
	s = append(s, "&service.Order{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "InstrumentId: "+fmt.Sprintf("%#v", this.InstrumentId)+",\n")
	s = append(s, "OrderRef: "+fmt.Sprintf("%#v", this.OrderRef)+",\n")
	s = append(s, "PriceType: "+fmt.Sprintf("%#v", this.PriceType)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "LimitPrice: "+fmt.Sprintf("%#v", this.LimitPrice)+",\n")
	s = append(s, "VolumeTotalOrigin: "+fmt.Sprintf("%#v", this.VolumeTotalOrigin)+",\n")
	s = append(s, "TimeCondition: "+fmt.Sprintf("%#v", this.TimeCondition)+",\n")
	s = append(s, "GtdDate: "+fmt.Sprintf("%#v", this.GtdDate)+",\n")
	s = append(s, "VolumeCondition: "+fmt.Sprintf("%#v", this.VolumeCondition)+",\n")
	s = append(s, "MinVolume: "+fmt.Sprintf("%#v", this.MinVolume)+",\n")
	s = append(s, "ContingentCondition: "+fmt.Sprintf("%#v", this.ContingentCondition)+",\n")
	s = append(s, "StopPrice: "+fmt.Sprintf("%#v", this.StopPrice)+",\n")
	s = append(s, "ForceCloseReason: "+fmt.Sprintf("%#v", this.ForceCloseReason)+",\n")
	s = append(s, "IsAutoSuspend: "+fmt.Sprintf("%#v", this.IsAutoSuspend)+",\n")
	s = append(s, "BusinessUnit: "+fmt.Sprintf("%#v", this.BusinessUnit)+",\n")
	s = append(s, "RequestId: "+fmt.Sprintf("%#v", this.RequestId)+",\n")
	s = append(s, "OrderLocalId: "+fmt.Sprintf("%#v", this.OrderLocalId)+",\n")
	s = append(s, "ExchangeId: "+fmt.Sprintf("%#v", this.ExchangeId)+",\n")
	s = append(s, "ParticipantId: "+fmt.Sprintf("%#v", this.ParticipantId)+",\n")
	s = append(s, "ClientId: "+fmt.Sprintf("%#v", this.ClientId)+",\n")
	s = append(s, "ExchangeInstrumentId: "+fmt.Sprintf("%#v", this.ExchangeInstrumentId)+",\n")
	s = append(s, "TraderId: "+fmt.Sprintf("%#v", this.TraderId)+",\n")
	s = append(s, "InstallId: "+fmt.Sprintf("%#v", this.InstallId)+",\n")
	s = append(s, "OrderSubmitStatus: "+fmt.Sprintf("%#v", this.OrderSubmitStatus)+",\n")
	s = append(s, "NotifySequence: "+fmt.Sprintf("%#v", this.NotifySequence)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "SettlementId: "+fmt.Sprintf("%#v", this.SettlementId)+",\n")
	s = append(s, "OrderSysId: "+fmt.Sprintf("%#v", this.OrderSysId)+",\n")
	s = append(s, "OrderSource: "+fmt.Sprintf("%#v", this.OrderSource)+",\n")
	s = append(s, "OrderStatus: "+fmt.Sprintf("%#v", this.OrderStatus)+",\n")
	s = append(s, "OrderType: "+fmt.Sprintf("%#v", this.OrderType)+",\n")
	s = append(s, "VolumeTraded: "+fmt.Sprintf("%#v", this.VolumeTraded)+",\n")
	s = append(s, "VolumeTotal: "+fmt.Sprintf("%#v", this.VolumeTotal)+",\n")
	s = append(s, "InsertDate: "+fmt.Sprintf("%#v", this.InsertDate)+",\n")
	s = append(s, "InsertTime: "+fmt.Sprintf("%#v", this.InsertTime)+",\n")
	s = append(s, "ActiveTime: "+fmt.Sprintf("%#v", this.ActiveTime)+",\n")
	s = append(s, "SuspendTime: "+fmt.Sprintf("%#v", this.SuspendTime)+",\n")
	s = append(s, "UpdateTime: "+fmt.Sprintf("%#v", this.UpdateTime)+",\n")
	s = append(s, "CancelTime: "+fmt.Sprintf("%#v", this.CancelTime)+",\n")
	s = append(s, "ActiveTraderId: "+fmt.Sprintf("%#v", this.ActiveTraderId)+",\n")
	s = append(s, "ClearingPartId: "+fmt.Sprintf("%#v", this.ClearingPartId)+",\n")
	s = append(s, "SequenceNo: "+fmt.Sprintf("%#v", this.SequenceNo)+",\n")
	s = append(s, "FrontId: "+fmt.Sprintf("%#v", this.FrontId)+",\n")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",\n")
	s = append(s, "UserProductInfo: "+fmt.Sprintf("%#v", this.UserProductInfo)+",\n")
	s = append(s, "StatusMessage: "+fmt.Sprintf("%#v", this.StatusMessage)+",\n")
	s = append(s, "UserForceClose: "+fmt.Sprintf("%#v", this.UserForceClose)+",\n")
	s = append(s, "ActiveUserId: "+fmt.Sprintf("%#v", this.ActiveUserId)+",\n")
	s = append(s, "BrokerOrderSequence: "+fmt.Sprintf("%#v", this.BrokerOrderSequence)+",\n")
	s = append(s, "RelativeOrderSysId: "+fmt.Sprintf("%#v", this.RelativeOrderSysId)+",\n")
	s = append(s, "ZceTotalTradedVolume: "+fmt.Sprintf("%#v", this.ZceTotalTradedVolume)+",\n")
	s = append(s, "IsSwapOrder: "+fmt.Sprintf("%#v", this.IsSwapOrder)+",\n")
	s = append(s, "BranchId: "+fmt.Sprintf("%#v", this.BranchId)+",\n")
	s = append(s, "InvestUnitId: "+fmt.Sprintf("%#v", this.InvestUnitId)+",\n")
	s = append(s, "AccountId: "+fmt.Sprintf("%#v", this.AccountId)+",\n")
	s = append(s, "CurrencyId: "+fmt.Sprintf("%#v", this.CurrencyId)+",\n")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "MacAddress: "+fmt.Sprintf("%#v", this.MacAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RiskUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&service.RiskUser{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "MacAddr: "+fmt.Sprintf("%#v", this.MacAddr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RspUserLogin) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&service.RspUserLogin{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "LoginTime: "+fmt.Sprintf("%#v", this.LoginTime)+",\n")
	s = append(s, "PrivilegeType: "+fmt.Sprintf("%#v", this.PrivilegeType)+",\n")
	keysForPrivilegeInfo := make([]string, 0, len(this.PrivilegeInfo))
	for k, _ := range this.PrivilegeInfo {
		keysForPrivilegeInfo = append(keysForPrivilegeInfo, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPrivilegeInfo)
	mapStringForPrivilegeInfo := "map[string]string{"
	for _, k := range keysForPrivilegeInfo {
		mapStringForPrivilegeInfo += fmt.Sprintf("%#v: %#v,", k, this.PrivilegeInfo[k])
	}
	mapStringForPrivilegeInfo += "}"
	if this.PrivilegeInfo != nil {
		s = append(s, "PrivilegeInfo: "+mapStringForPrivilegeInfo+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RspUserLogout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service.RspUserLogout{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStructures(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RspInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.ErrorId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Investor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Investor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Investor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvestorId) > 0 {
		i -= len(m.InvestorId)
		copy(dAtA[i:], m.InvestorId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InvestorId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BrokerId) > 0 {
		i -= len(m.BrokerId)
		copy(dAtA[i:], m.BrokerId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BrokerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundMortgage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundMortgage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundMortgage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mortgagable != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mortgagable))))
		i--
		dAtA[i] = 0x41
	}
	if m.Available != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Available))))
		i--
		dAtA[i] = 0x39
	}
	if m.Mortgage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mortgage))))
		i--
		dAtA[i] = 0x31
	}
	if m.CurrentOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentOut))))
		i--
		dAtA[i] = 0x29
	}
	if m.CurrentIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentIn))))
		i--
		dAtA[i] = 0x21
	}
	if m.PreMortgage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreMortgage))))
		i--
		dAtA[i] = 0x19
	}
	if m.PreOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.PreIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SpecProduct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecProduct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecProduct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExchangeMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeMargin))))
		i--
		dAtA[i] = 0x41
	}
	if m.PositionProfitByAlg != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfitByAlg))))
		i--
		dAtA[i] = 0x39
	}
	if m.CloseProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CloseProfit))))
		i--
		dAtA[i] = 0x31
	}
	if m.PositionProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfit))))
		i--
		dAtA[i] = 0x29
	}
	if m.FrozenCommission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCommission))))
		i--
		dAtA[i] = 0x21
	}
	if m.Commission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Commission))))
		i--
		dAtA[i] = 0x19
	}
	if m.FrozenMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenMargin))))
		i--
		dAtA[i] = 0x11
	}
	if m.Margin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Margin))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketValueEquity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MarketValueEquity))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb9
	}
	if m.Premium != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Premium))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb1
	}
	if m.DynamicMoney != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DynamicMoney))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa9
	}
	if m.OptionMarketValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionMarketValue))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa1
	}
	if m.StockMarketValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StockMarketValue))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x99
	}
	if m.RemainSwap != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RemainSwap))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x91
	}
	if m.FrozenSwap != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenSwap))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x89
	}
	if m.BusinessType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.BusinessType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SpecProductInfo != nil {
		{
			size, err := m.SpecProductInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.MortgageInfo != nil {
		{
			size, err := m.MortgageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.CurrencyId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.CurrencyId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ReserveBalance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReserveBalance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe1
	}
	if m.ExchangeDeliveryMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeDeliveryMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd9
	}
	if m.DeliveryMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd1
	}
	if m.ExchangeMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc9
	}
	if m.Credit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Credit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.SettlementId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Reserve != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Reserve))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.WithdrawQuota != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WithdrawQuota))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.Available != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Available))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.PositionProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.CloseProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CloseProfit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.Commission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Commission))))
		i--
		dAtA[i] = 0x79
	}
	if m.CashIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CashIn))))
		i--
		dAtA[i] = 0x71
	}
	if m.CurrentMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentMargin))))
		i--
		dAtA[i] = 0x69
	}
	if m.FrozenCommission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCommission))))
		i--
		dAtA[i] = 0x61
	}
	if m.FrozenCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCash))))
		i--
		dAtA[i] = 0x59
	}
	if m.FrozenMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenMargin))))
		i--
		dAtA[i] = 0x51
	}
	if m.Withdraw != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Withdraw))))
		i--
		dAtA[i] = 0x49
	}
	if m.Deposit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Deposit))))
		i--
		dAtA[i] = 0x41
	}
	if m.Interest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Interest))))
		i--
		dAtA[i] = 0x39
	}
	if m.InterestBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InterestBase))))
		i--
		dAtA[i] = 0x31
	}
	if m.PreMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreMargin))))
		i--
		dAtA[i] = 0x29
	}
	if m.PreBalance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreBalance))))
		i--
		dAtA[i] = 0x21
	}
	if m.PreDeposit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreDeposit))))
		i--
		dAtA[i] = 0x19
	}
	if m.PreCredit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreCredit))))
		i--
		dAtA[i] = 0x11
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EntryType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x60
	}
	if m.FrozenVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.FrozenVolume))
		i--
		dAtA[i] = 0x58
	}
	if m.TodayVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TodayVolume))
		i--
		dAtA[i] = 0x50
	}
	if m.AvgOpenPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgOpenPrice))))
		i--
		dAtA[i] = 0x49
	}
	if m.AvgOpenPriceByVol != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgOpenPriceByVol))))
		i--
		dAtA[i] = 0x41
	}
	if m.Margin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Margin))))
		i--
		dAtA[i] = 0x39
	}
	if m.Volume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Volume))
		i--
		dAtA[i] = 0x30
	}
	if m.Direction != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x28
	}
	if m.HedgeFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.HedgeFlag))
		i--
		dAtA[i] = 0x20
	}
	if len(m.InstrumentId) > 0 {
		i -= len(m.InstrumentId)
		copy(dAtA[i:], m.InstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InstrumentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvestorUnitId) > 0 {
		i -= len(m.InvestorUnitId)
		copy(dAtA[i:], m.InvestorUnitId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InvestorUnitId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.TradeSource != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradeSource))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.BrokerOrderSeqence != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.BrokerOrderSeqence))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SettlementId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SequenceNo != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SequenceNo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.BusinessUnit) > 0 {
		i -= len(m.BusinessUnit)
		copy(dAtA[i:], m.BusinessUnit)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BusinessUnit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ClearingPartId) > 0 {
		i -= len(m.ClearingPartId)
		copy(dAtA[i:], m.ClearingPartId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClearingPartId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.OrderLocalId) > 0 {
		i -= len(m.OrderLocalId)
		copy(dAtA[i:], m.OrderLocalId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderLocalId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.TraderId) > 0 {
		i -= len(m.TraderId)
		copy(dAtA[i:], m.TraderId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TraderId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.PriceSource != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.PriceSource))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TradeType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradeType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.TradeTime) > 0 {
		i -= len(m.TradeTime)
		copy(dAtA[i:], m.TradeTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.TradeDate) > 0 {
		i -= len(m.TradeDate)
		copy(dAtA[i:], m.TradeDate)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeDate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Volume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Volume))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x79
	}
	if m.HedgeFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.HedgeFlag))
		i--
		dAtA[i] = 0x70
	}
	if m.OffsetFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OffsetFlag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ExchangeInstrumentId) > 0 {
		i -= len(m.ExchangeInstrumentId)
		copy(dAtA[i:], m.ExchangeInstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeInstrumentId)))
		i--
		dAtA[i] = 0x62
	}
	if m.TradingRole != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradingRole))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ParticipantId) > 0 {
		i -= len(m.ParticipantId)
		copy(dAtA[i:], m.ParticipantId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ParticipantId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderSysId) > 0 {
		i -= len(m.OrderSysId)
		copy(dAtA[i:], m.OrderSysId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderSysId)))
		i--
		dAtA[i] = 0x42
	}
	if m.Direction != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TradeId) > 0 {
		i -= len(m.TradeId)
		copy(dAtA[i:], m.TradeId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExchangeId) > 0 {
		i -= len(m.ExchangeId)
		copy(dAtA[i:], m.ExchangeId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderRef) > 0 {
		i -= len(m.OrderRef)
		copy(dAtA[i:], m.OrderRef)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderRef)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstrumentId) > 0 {
		i -= len(m.InstrumentId)
		copy(dAtA[i:], m.InstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InstrumentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubInfoType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SubInfoType))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.AccountType))
		i--
		dAtA[i] = 0x10
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if len(m.IpAddress) > 0 {
		i -= len(m.IpAddress)
		copy(dAtA[i:], m.IpAddress)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.IpAddress)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	if m.CurrencyId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.CurrencyId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xda
	}
	if len(m.InvestUnitId) > 0 {
		i -= len(m.InvestUnitId)
		copy(dAtA[i:], m.InvestUnitId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InvestUnitId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd2
	}
	if len(m.BranchId) > 0 {
		i -= len(m.BranchId)
		copy(dAtA[i:], m.BranchId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BranchId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if m.IsSwapOrder {
		i--
		if m.IsSwapOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.ZceTotalTradedVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.ZceTotalTradedVolume))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if len(m.RelativeOrderSysId) > 0 {
		i -= len(m.RelativeOrderSysId)
		copy(dAtA[i:], m.RelativeOrderSysId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.RelativeOrderSysId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if m.BrokerOrderSequence != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.BrokerOrderSequence))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ActiveUserId) > 0 {
		i -= len(m.ActiveUserId)
		copy(dAtA[i:], m.ActiveUserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ActiveUserId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.UserForceClose {
		i--
		if m.UserForceClose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if len(m.StatusMessage) > 0 {
		i -= len(m.StatusMessage)
		copy(dAtA[i:], m.StatusMessage)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.StatusMessage)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if len(m.UserProductInfo) > 0 {
		i -= len(m.UserProductInfo)
		copy(dAtA[i:], m.UserProductInfo)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserProductInfo)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if m.SessionId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.FrontId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.FrontId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.SequenceNo != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SequenceNo))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if len(m.ClearingPartId) > 0 {
		i -= len(m.ClearingPartId)
		copy(dAtA[i:], m.ClearingPartId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClearingPartId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if len(m.ActiveTraderId) > 0 {
		i -= len(m.ActiveTraderId)
		copy(dAtA[i:], m.ActiveTraderId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ActiveTraderId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if len(m.CancelTime) > 0 {
		i -= len(m.CancelTime)
		copy(dAtA[i:], m.CancelTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.CancelTime)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.UpdateTime) > 0 {
		i -= len(m.UpdateTime)
		copy(dAtA[i:], m.UpdateTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UpdateTime)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.SuspendTime) > 0 {
		i -= len(m.SuspendTime)
		copy(dAtA[i:], m.SuspendTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.SuspendTime)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.ActiveTime) > 0 {
		i -= len(m.ActiveTime)
		copy(dAtA[i:], m.ActiveTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ActiveTime)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.InsertTime) > 0 {
		i -= len(m.InsertTime)
		copy(dAtA[i:], m.InsertTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InsertTime)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.InsertDate) > 0 {
		i -= len(m.InsertDate)
		copy(dAtA[i:], m.InsertDate)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InsertDate)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.VolumeTotal != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.VolumeTotal))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.VolumeTraded != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.VolumeTraded))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.OrderType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OrderType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.OrderStatus != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OrderStatus))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.OrderSource != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OrderSource))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if len(m.OrderSysId) > 0 {
		i -= len(m.OrderSysId)
		copy(dAtA[i:], m.OrderSysId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderSysId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.SettlementId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.NotifySequence != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.NotifySequence))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.OrderSubmitStatus != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OrderSubmitStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.InstallId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.InstallId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.TraderId) > 0 {
		i -= len(m.TraderId)
		copy(dAtA[i:], m.TraderId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TraderId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.ExchangeInstrumentId) > 0 {
		i -= len(m.ExchangeInstrumentId)
		copy(dAtA[i:], m.ExchangeInstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeInstrumentId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ParticipantId) > 0 {
		i -= len(m.ParticipantId)
		copy(dAtA[i:], m.ParticipantId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ParticipantId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ExchangeId) > 0 {
		i -= len(m.ExchangeId)
		copy(dAtA[i:], m.ExchangeId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.OrderLocalId) > 0 {
		i -= len(m.OrderLocalId)
		copy(dAtA[i:], m.OrderLocalId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderLocalId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.RequestId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.BusinessUnit) > 0 {
		i -= len(m.BusinessUnit)
		copy(dAtA[i:], m.BusinessUnit)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BusinessUnit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.IsAutoSuspend {
		i--
		if m.IsAutoSuspend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ForceCloseReason != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.ForceCloseReason))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.StopPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StopPrice))))
		i--
		dAtA[i] = 0x79
	}
	if m.ContingentCondition != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.ContingentCondition))
		i--
		dAtA[i] = 0x70
	}
	if m.MinVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.MinVolume))
		i--
		dAtA[i] = 0x68
	}
	if m.VolumeCondition != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.VolumeCondition))
		i--
		dAtA[i] = 0x60
	}
	if len(m.GtdDate) > 0 {
		i -= len(m.GtdDate)
		copy(dAtA[i:], m.GtdDate)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.GtdDate)))
		i--
		dAtA[i] = 0x5a
	}
	if m.TimeCondition != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TimeCondition))
		i--
		dAtA[i] = 0x50
	}
	if m.VolumeTotalOrigin != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.VolumeTotalOrigin))
		i--
		dAtA[i] = 0x48
	}
	if m.LimitPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LimitPrice))))
		i--
		dAtA[i] = 0x41
	}
	if m.Direction != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x28
	}
	if m.PriceType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OrderRef) > 0 {
		i -= len(m.OrderRef)
		copy(dAtA[i:], m.OrderRef)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderRef)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstrumentId) > 0 {
		i -= len(m.InstrumentId)
		copy(dAtA[i:], m.InstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InstrumentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RiskUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RiskUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RiskUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RspUserLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspUserLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspUserLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivilegeInfo) > 0 {
		for k := range m.PrivilegeInfo {
			v := m.PrivilegeInfo[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStructures(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStructures(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStructures(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PrivilegeType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.PrivilegeType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LoginTime) > 0 {
		i -= len(m.LoginTime)
		copy(dAtA[i:], m.LoginTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.LoginTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RspUserLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspUserLogout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspUserLogout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStructures(dAtA []byte, offset int, v uint64) int {
	offset -= sovStructures(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RspInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorId != 0 {
		n += 1 + sovStructures(uint64(m.ErrorId))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *Investor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BrokerId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InvestorId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *FundMortgage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreIn != 0 {
		n += 9
	}
	if m.PreOut != 0 {
		n += 9
	}
	if m.PreMortgage != 0 {
		n += 9
	}
	if m.CurrentIn != 0 {
		n += 9
	}
	if m.CurrentOut != 0 {
		n += 9
	}
	if m.Mortgage != 0 {
		n += 9
	}
	if m.Available != 0 {
		n += 9
	}
	if m.Mortgagable != 0 {
		n += 9
	}
	return n
}

func (m *SpecProduct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Margin != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.PositionProfit != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 9
	}
	if m.PositionProfitByAlg != 0 {
		n += 9
	}
	if m.ExchangeMargin != 0 {
		n += 9
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.PreCredit != 0 {
		n += 9
	}
	if m.PreDeposit != 0 {
		n += 9
	}
	if m.PreBalance != 0 {
		n += 9
	}
	if m.PreMargin != 0 {
		n += 9
	}
	if m.InterestBase != 0 {
		n += 9
	}
	if m.Interest != 0 {
		n += 9
	}
	if m.Deposit != 0 {
		n += 9
	}
	if m.Withdraw != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.FrozenCash != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.CurrentMargin != 0 {
		n += 9
	}
	if m.CashIn != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 10
	}
	if m.PositionProfit != 0 {
		n += 10
	}
	if m.Balance != 0 {
		n += 10
	}
	if m.Available != 0 {
		n += 10
	}
	if m.WithdrawQuota != 0 {
		n += 10
	}
	if m.Reserve != 0 {
		n += 10
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 2 + sovStructures(uint64(m.SettlementId))
	}
	if m.Credit != 0 {
		n += 10
	}
	if m.ExchangeMargin != 0 {
		n += 10
	}
	if m.DeliveryMargin != 0 {
		n += 10
	}
	if m.ExchangeDeliveryMargin != 0 {
		n += 10
	}
	if m.ReserveBalance != 0 {
		n += 10
	}
	if m.CurrencyId != 0 {
		n += 2 + sovStructures(uint64(m.CurrencyId))
	}
	if m.MortgageInfo != nil {
		l = m.MortgageInfo.Size()
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SpecProductInfo != nil {
		l = m.SpecProductInfo.Size()
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.BusinessType != 0 {
		n += 2 + sovStructures(uint64(m.BusinessType))
	}
	if m.FrozenSwap != 0 {
		n += 10
	}
	if m.RemainSwap != 0 {
		n += 10
	}
	if m.StockMarketValue != 0 {
		n += 10
	}
	if m.OptionMarketValue != 0 {
		n += 10
	}
	if m.DynamicMoney != 0 {
		n += 10
	}
	if m.Premium != 0 {
		n += 10
	}
	if m.MarketValueEquity != 0 {
		n += 10
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.HedgeFlag != 0 {
		n += 1 + sovStructures(uint64(m.HedgeFlag))
	}
	if m.Direction != 0 {
		n += 1 + sovStructures(uint64(m.Direction))
	}
	if m.Volume != 0 {
		n += 1 + sovStructures(uint64(m.Volume))
	}
	if m.Margin != 0 {
		n += 9
	}
	if m.AvgOpenPriceByVol != 0 {
		n += 9
	}
	if m.AvgOpenPrice != 0 {
		n += 9
	}
	if m.TodayVolume != 0 {
		n += 1 + sovStructures(uint64(m.TodayVolume))
	}
	if m.FrozenVolume != 0 {
		n += 1 + sovStructures(uint64(m.FrozenVolume))
	}
	if m.EntryType != 0 {
		n += 1 + sovStructures(uint64(m.EntryType))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.OrderRef)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ExchangeId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.TradeId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovStructures(uint64(m.Direction))
	}
	l = len(m.OrderSysId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ParticipantId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.TradingRole != 0 {
		n += 1 + sovStructures(uint64(m.TradingRole))
	}
	l = len(m.ExchangeInstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.OffsetFlag != 0 {
		n += 1 + sovStructures(uint64(m.OffsetFlag))
	}
	if m.HedgeFlag != 0 {
		n += 1 + sovStructures(uint64(m.HedgeFlag))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 2 + sovStructures(uint64(m.Volume))
	}
	l = len(m.TradeDate)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.TradeTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.TradeType != 0 {
		n += 2 + sovStructures(uint64(m.TradeType))
	}
	if m.PriceSource != 0 {
		n += 2 + sovStructures(uint64(m.PriceSource))
	}
	l = len(m.TraderId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.OrderLocalId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ClearingPartId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.BusinessUnit)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 2 + sovStructures(uint64(m.SequenceNo))
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 2 + sovStructures(uint64(m.SettlementId))
	}
	if m.BrokerOrderSeqence != 0 {
		n += 2 + sovStructures(uint64(m.BrokerOrderSeqence))
	}
	if m.TradeSource != 0 {
		n += 2 + sovStructures(uint64(m.TradeSource))
	}
	l = len(m.InvestorUnitId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *SubInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.AccountType != 0 {
		n += 1 + sovStructures(uint64(m.AccountType))
	}
	if m.SubInfoType != 0 {
		n += 1 + sovStructures(uint64(m.SubInfoType))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.OrderRef)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.PriceType != 0 {
		n += 1 + sovStructures(uint64(m.PriceType))
	}
	if m.Direction != 0 {
		n += 1 + sovStructures(uint64(m.Direction))
	}
	if m.LimitPrice != 0 {
		n += 9
	}
	if m.VolumeTotalOrigin != 0 {
		n += 1 + sovStructures(uint64(m.VolumeTotalOrigin))
	}
	if m.TimeCondition != 0 {
		n += 1 + sovStructures(uint64(m.TimeCondition))
	}
	l = len(m.GtdDate)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.VolumeCondition != 0 {
		n += 1 + sovStructures(uint64(m.VolumeCondition))
	}
	if m.MinVolume != 0 {
		n += 1 + sovStructures(uint64(m.MinVolume))
	}
	if m.ContingentCondition != 0 {
		n += 1 + sovStructures(uint64(m.ContingentCondition))
	}
	if m.StopPrice != 0 {
		n += 9
	}
	if m.ForceCloseReason != 0 {
		n += 2 + sovStructures(uint64(m.ForceCloseReason))
	}
	if m.IsAutoSuspend {
		n += 3
	}
	l = len(m.BusinessUnit)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.RequestId != 0 {
		n += 2 + sovStructures(uint64(m.RequestId))
	}
	l = len(m.OrderLocalId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ExchangeId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ParticipantId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ExchangeInstrumentId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.TraderId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.InstallId != 0 {
		n += 2 + sovStructures(uint64(m.InstallId))
	}
	if m.OrderSubmitStatus != 0 {
		n += 2 + sovStructures(uint64(m.OrderSubmitStatus))
	}
	if m.NotifySequence != 0 {
		n += 2 + sovStructures(uint64(m.NotifySequence))
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 2 + sovStructures(uint64(m.SettlementId))
	}
	l = len(m.OrderSysId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.OrderSource != 0 {
		n += 2 + sovStructures(uint64(m.OrderSource))
	}
	if m.OrderStatus != 0 {
		n += 2 + sovStructures(uint64(m.OrderStatus))
	}
	if m.OrderType != 0 {
		n += 2 + sovStructures(uint64(m.OrderType))
	}
	if m.VolumeTraded != 0 {
		n += 2 + sovStructures(uint64(m.VolumeTraded))
	}
	if m.VolumeTotal != 0 {
		n += 2 + sovStructures(uint64(m.VolumeTotal))
	}
	l = len(m.InsertDate)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.InsertTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ActiveTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.SuspendTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.UpdateTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.CancelTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ActiveTraderId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ClearingPartId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 2 + sovStructures(uint64(m.SequenceNo))
	}
	if m.FrontId != 0 {
		n += 2 + sovStructures(uint64(m.FrontId))
	}
	if m.SessionId != 0 {
		n += 2 + sovStructures(uint64(m.SessionId))
	}
	l = len(m.UserProductInfo)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.StatusMessage)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.UserForceClose {
		n += 3
	}
	l = len(m.ActiveUserId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.BrokerOrderSequence != 0 {
		n += 2 + sovStructures(uint64(m.BrokerOrderSequence))
	}
	l = len(m.RelativeOrderSysId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.ZceTotalTradedVolume != 0 {
		n += 2 + sovStructures(uint64(m.ZceTotalTradedVolume))
	}
	if m.IsSwapOrder {
		n += 3
	}
	l = len(m.BranchId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.InvestUnitId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.CurrencyId != 0 {
		n += 2 + sovStructures(uint64(m.CurrencyId))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *RiskUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *RspUserLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.LoginTime)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.PrivilegeType != 0 {
		n += 1 + sovStructures(uint64(m.PrivilegeType))
	}
	if len(m.PrivilegeInfo) > 0 {
		for k, v := range m.PrivilegeInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStructures(uint64(len(k))) + 1 + len(v) + sovStructures(uint64(len(v)))
			n += mapEntrySize + 1 + sovStructures(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RspUserLogout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func sovStructures(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStructures(x uint64) (n int) {
	return sovStructures(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RspInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RspInfo{`,
		`ErrorId:` + fmt.Sprintf("%v", this.ErrorId) + `,`,
		`ErrorMsg:` + fmt.Sprintf("%v", this.ErrorMsg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Investor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Investor{`,
		`BrokerId:` + fmt.Sprintf("%v", this.BrokerId) + `,`,
		`InvestorId:` + fmt.Sprintf("%v", this.InvestorId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FundMortgage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FundMortgage{`,
		`PreIn:` + fmt.Sprintf("%v", this.PreIn) + `,`,
		`PreOut:` + fmt.Sprintf("%v", this.PreOut) + `,`,
		`PreMortgage:` + fmt.Sprintf("%v", this.PreMortgage) + `,`,
		`CurrentIn:` + fmt.Sprintf("%v", this.CurrentIn) + `,`,
		`CurrentOut:` + fmt.Sprintf("%v", this.CurrentOut) + `,`,
		`Mortgage:` + fmt.Sprintf("%v", this.Mortgage) + `,`,
		`Available:` + fmt.Sprintf("%v", this.Available) + `,`,
		`Mortgagable:` + fmt.Sprintf("%v", this.Mortgagable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecProduct) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpecProduct{`,
		`Margin:` + fmt.Sprintf("%v", this.Margin) + `,`,
		`FrozenMargin:` + fmt.Sprintf("%v", this.FrozenMargin) + `,`,
		`Commission:` + fmt.Sprintf("%v", this.Commission) + `,`,
		`FrozenCommission:` + fmt.Sprintf("%v", this.FrozenCommission) + `,`,
		`PositionProfit:` + fmt.Sprintf("%v", this.PositionProfit) + `,`,
		`CloseProfit:` + fmt.Sprintf("%v", this.CloseProfit) + `,`,
		`PositionProfitByAlg:` + fmt.Sprintf("%v", this.PositionProfitByAlg) + `,`,
		`ExchangeMargin:` + fmt.Sprintf("%v", this.ExchangeMargin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Account) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Account{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`PreCredit:` + fmt.Sprintf("%v", this.PreCredit) + `,`,
		`PreDeposit:` + fmt.Sprintf("%v", this.PreDeposit) + `,`,
		`PreBalance:` + fmt.Sprintf("%v", this.PreBalance) + `,`,
		`PreMargin:` + fmt.Sprintf("%v", this.PreMargin) + `,`,
		`InterestBase:` + fmt.Sprintf("%v", this.InterestBase) + `,`,
		`Interest:` + fmt.Sprintf("%v", this.Interest) + `,`,
		`Deposit:` + fmt.Sprintf("%v", this.Deposit) + `,`,
		`Withdraw:` + fmt.Sprintf("%v", this.Withdraw) + `,`,
		`FrozenMargin:` + fmt.Sprintf("%v", this.FrozenMargin) + `,`,
		`FrozenCash:` + fmt.Sprintf("%v", this.FrozenCash) + `,`,
		`FrozenCommission:` + fmt.Sprintf("%v", this.FrozenCommission) + `,`,
		`CurrentMargin:` + fmt.Sprintf("%v", this.CurrentMargin) + `,`,
		`CashIn:` + fmt.Sprintf("%v", this.CashIn) + `,`,
		`Commission:` + fmt.Sprintf("%v", this.Commission) + `,`,
		`CloseProfit:` + fmt.Sprintf("%v", this.CloseProfit) + `,`,
		`PositionProfit:` + fmt.Sprintf("%v", this.PositionProfit) + `,`,
		`Balance:` + fmt.Sprintf("%v", this.Balance) + `,`,
		`Available:` + fmt.Sprintf("%v", this.Available) + `,`,
		`WithdrawQuota:` + fmt.Sprintf("%v", this.WithdrawQuota) + `,`,
		`Reserve:` + fmt.Sprintf("%v", this.Reserve) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`SettlementId:` + fmt.Sprintf("%v", this.SettlementId) + `,`,
		`Credit:` + fmt.Sprintf("%v", this.Credit) + `,`,
		`ExchangeMargin:` + fmt.Sprintf("%v", this.ExchangeMargin) + `,`,
		`DeliveryMargin:` + fmt.Sprintf("%v", this.DeliveryMargin) + `,`,
		`ExchangeDeliveryMargin:` + fmt.Sprintf("%v", this.ExchangeDeliveryMargin) + `,`,
		`ReserveBalance:` + fmt.Sprintf("%v", this.ReserveBalance) + `,`,
		`CurrencyId:` + fmt.Sprintf("%v", this.CurrencyId) + `,`,
		`MortgageInfo:` + strings.Replace(this.MortgageInfo.String(), "FundMortgage", "FundMortgage", 1) + `,`,
		`SpecProductInfo:` + strings.Replace(this.SpecProductInfo.String(), "SpecProduct", "SpecProduct", 1) + `,`,
		`BusinessType:` + fmt.Sprintf("%v", this.BusinessType) + `,`,
		`FrozenSwap:` + fmt.Sprintf("%v", this.FrozenSwap) + `,`,
		`RemainSwap:` + fmt.Sprintf("%v", this.RemainSwap) + `,`,
		`StockMarketValue:` + fmt.Sprintf("%v", this.StockMarketValue) + `,`,
		`OptionMarketValue:` + fmt.Sprintf("%v", this.OptionMarketValue) + `,`,
		`DynamicMoney:` + fmt.Sprintf("%v", this.DynamicMoney) + `,`,
		`Premium:` + fmt.Sprintf("%v", this.Premium) + `,`,
		`MarketValueEquity:` + fmt.Sprintf("%v", this.MarketValueEquity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`InstrumentId:` + fmt.Sprintf("%v", this.InstrumentId) + `,`,
		`HedgeFlag:` + fmt.Sprintf("%v", this.HedgeFlag) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Margin:` + fmt.Sprintf("%v", this.Margin) + `,`,
		`AvgOpenPriceByVol:` + fmt.Sprintf("%v", this.AvgOpenPriceByVol) + `,`,
		`AvgOpenPrice:` + fmt.Sprintf("%v", this.AvgOpenPrice) + `,`,
		`TodayVolume:` + fmt.Sprintf("%v", this.TodayVolume) + `,`,
		`FrozenVolume:` + fmt.Sprintf("%v", this.FrozenVolume) + `,`,
		`EntryType:` + fmt.Sprintf("%v", this.EntryType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Trade) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Trade{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`InstrumentId:` + fmt.Sprintf("%v", this.InstrumentId) + `,`,
		`OrderRef:` + fmt.Sprintf("%v", this.OrderRef) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`ExchangeId:` + fmt.Sprintf("%v", this.ExchangeId) + `,`,
		`TradeId:` + fmt.Sprintf("%v", this.TradeId) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`OrderSysId:` + fmt.Sprintf("%v", this.OrderSysId) + `,`,
		`ParticipantId:` + fmt.Sprintf("%v", this.ParticipantId) + `,`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`TradingRole:` + fmt.Sprintf("%v", this.TradingRole) + `,`,
		`ExchangeInstrumentId:` + fmt.Sprintf("%v", this.ExchangeInstrumentId) + `,`,
		`OffsetFlag:` + fmt.Sprintf("%v", this.OffsetFlag) + `,`,
		`HedgeFlag:` + fmt.Sprintf("%v", this.HedgeFlag) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`TradeDate:` + fmt.Sprintf("%v", this.TradeDate) + `,`,
		`TradeTime:` + fmt.Sprintf("%v", this.TradeTime) + `,`,
		`TradeType:` + fmt.Sprintf("%v", this.TradeType) + `,`,
		`PriceSource:` + fmt.Sprintf("%v", this.PriceSource) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`OrderLocalId:` + fmt.Sprintf("%v", this.OrderLocalId) + `,`,
		`ClearingPartId:` + fmt.Sprintf("%v", this.ClearingPartId) + `,`,
		`BusinessUnit:` + fmt.Sprintf("%v", this.BusinessUnit) + `,`,
		`SequenceNo:` + fmt.Sprintf("%v", this.SequenceNo) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`SettlementId:` + fmt.Sprintf("%v", this.SettlementId) + `,`,
		`BrokerOrderSeqence:` + fmt.Sprintf("%v", this.BrokerOrderSeqence) + `,`,
		`TradeSource:` + fmt.Sprintf("%v", this.TradeSource) + `,`,
		`InvestorUnitId:` + fmt.Sprintf("%v", this.InvestorUnitId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubInfo{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`AccountType:` + fmt.Sprintf("%v", this.AccountType) + `,`,
		`SubInfoType:` + fmt.Sprintf("%v", this.SubInfoType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`InstrumentId:` + fmt.Sprintf("%v", this.InstrumentId) + `,`,
		`OrderRef:` + fmt.Sprintf("%v", this.OrderRef) + `,`,
		`PriceType:` + fmt.Sprintf("%v", this.PriceType) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`LimitPrice:` + fmt.Sprintf("%v", this.LimitPrice) + `,`,
		`VolumeTotalOrigin:` + fmt.Sprintf("%v", this.VolumeTotalOrigin) + `,`,
		`TimeCondition:` + fmt.Sprintf("%v", this.TimeCondition) + `,`,
		`GtdDate:` + fmt.Sprintf("%v", this.GtdDate) + `,`,
		`VolumeCondition:` + fmt.Sprintf("%v", this.VolumeCondition) + `,`,
		`MinVolume:` + fmt.Sprintf("%v", this.MinVolume) + `,`,
		`ContingentCondition:` + fmt.Sprintf("%v", this.ContingentCondition) + `,`,
		`StopPrice:` + fmt.Sprintf("%v", this.StopPrice) + `,`,
		`ForceCloseReason:` + fmt.Sprintf("%v", this.ForceCloseReason) + `,`,
		`IsAutoSuspend:` + fmt.Sprintf("%v", this.IsAutoSuspend) + `,`,
		`BusinessUnit:` + fmt.Sprintf("%v", this.BusinessUnit) + `,`,
		`RequestId:` + fmt.Sprintf("%v", this.RequestId) + `,`,
		`OrderLocalId:` + fmt.Sprintf("%v", this.OrderLocalId) + `,`,
		`ExchangeId:` + fmt.Sprintf("%v", this.ExchangeId) + `,`,
		`ParticipantId:` + fmt.Sprintf("%v", this.ParticipantId) + `,`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`ExchangeInstrumentId:` + fmt.Sprintf("%v", this.ExchangeInstrumentId) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`InstallId:` + fmt.Sprintf("%v", this.InstallId) + `,`,
		`OrderSubmitStatus:` + fmt.Sprintf("%v", this.OrderSubmitStatus) + `,`,
		`NotifySequence:` + fmt.Sprintf("%v", this.NotifySequence) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`SettlementId:` + fmt.Sprintf("%v", this.SettlementId) + `,`,
		`OrderSysId:` + fmt.Sprintf("%v", this.OrderSysId) + `,`,
		`OrderSource:` + fmt.Sprintf("%v", this.OrderSource) + `,`,
		`OrderStatus:` + fmt.Sprintf("%v", this.OrderStatus) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`VolumeTraded:` + fmt.Sprintf("%v", this.VolumeTraded) + `,`,
		`VolumeTotal:` + fmt.Sprintf("%v", this.VolumeTotal) + `,`,
		`InsertDate:` + fmt.Sprintf("%v", this.InsertDate) + `,`,
		`InsertTime:` + fmt.Sprintf("%v", this.InsertTime) + `,`,
		`ActiveTime:` + fmt.Sprintf("%v", this.ActiveTime) + `,`,
		`SuspendTime:` + fmt.Sprintf("%v", this.SuspendTime) + `,`,
		`UpdateTime:` + fmt.Sprintf("%v", this.UpdateTime) + `,`,
		`CancelTime:` + fmt.Sprintf("%v", this.CancelTime) + `,`,
		`ActiveTraderId:` + fmt.Sprintf("%v", this.ActiveTraderId) + `,`,
		`ClearingPartId:` + fmt.Sprintf("%v", this.ClearingPartId) + `,`,
		`SequenceNo:` + fmt.Sprintf("%v", this.SequenceNo) + `,`,
		`FrontId:` + fmt.Sprintf("%v", this.FrontId) + `,`,
		`SessionId:` + fmt.Sprintf("%v", this.SessionId) + `,`,
		`UserProductInfo:` + fmt.Sprintf("%v", this.UserProductInfo) + `,`,
		`StatusMessage:` + fmt.Sprintf("%v", this.StatusMessage) + `,`,
		`UserForceClose:` + fmt.Sprintf("%v", this.UserForceClose) + `,`,
		`ActiveUserId:` + fmt.Sprintf("%v", this.ActiveUserId) + `,`,
		`BrokerOrderSequence:` + fmt.Sprintf("%v", this.BrokerOrderSequence) + `,`,
		`RelativeOrderSysId:` + fmt.Sprintf("%v", this.RelativeOrderSysId) + `,`,
		`ZceTotalTradedVolume:` + fmt.Sprintf("%v", this.ZceTotalTradedVolume) + `,`,
		`IsSwapOrder:` + fmt.Sprintf("%v", this.IsSwapOrder) + `,`,
		`BranchId:` + fmt.Sprintf("%v", this.BranchId) + `,`,
		`InvestUnitId:` + fmt.Sprintf("%v", this.InvestUnitId) + `,`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`CurrencyId:` + fmt.Sprintf("%v", this.CurrencyId) + `,`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`MacAddress:` + fmt.Sprintf("%v", this.MacAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RiskUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RiskUser{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`MacAddr:` + fmt.Sprintf("%v", this.MacAddr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RspUserLogin) String() string {
	if this == nil {
		return "nil"
	}
	keysForPrivilegeInfo := make([]string, 0, len(this.PrivilegeInfo))
	for k, _ := range this.PrivilegeInfo {
		keysForPrivilegeInfo = append(keysForPrivilegeInfo, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPrivilegeInfo)
	mapStringForPrivilegeInfo := "map[string]string{"
	for _, k := range keysForPrivilegeInfo {
		mapStringForPrivilegeInfo += fmt.Sprintf("%v: %v,", k, this.PrivilegeInfo[k])
	}
	mapStringForPrivilegeInfo += "}"
	s := strings.Join([]string{`&RspUserLogin{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`LoginTime:` + fmt.Sprintf("%v", this.LoginTime) + `,`,
		`PrivilegeType:` + fmt.Sprintf("%v", this.PrivilegeType) + `,`,
		`PrivilegeInfo:` + mapStringForPrivilegeInfo + `,`,
		`}`,
	}, "")
	return s
}
func (this *RspUserLogout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RspUserLogout{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStructures(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RspInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorId", wireType)
			}
			m.ErrorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Investor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Investor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Investor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundMortgage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundMortgage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundMortgage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMortgage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreMortgage = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentIn = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentOut = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mortgage = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Available = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgagable", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mortgagable = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecProduct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecProduct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecProduct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Margin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Commission = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfit = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CloseProfit = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfitByAlg", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfitByAlg = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeMargin = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCredit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreCredit = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreDeposit = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreBalance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreMargin = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestBase", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InterestBase = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Interest = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Deposit = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdraw", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Withdraw = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCash = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentMargin = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CashIn = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Commission = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CloseProfit = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfit = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Available = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawQuota", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WithdrawQuota = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Reserve = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Credit = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeMargin = float64(math.Float64frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryMargin = float64(math.Float64frombits(v))
		case 27:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeDeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeDeliveryMargin = float64(math.Float64frombits(v))
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReserveBalance = float64(math.Float64frombits(v))
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			m.CurrencyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyId |= CurrencyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MortgageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MortgageInfo == nil {
				m.MortgageInfo = &FundMortgage{}
			}
			if err := m.MortgageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecProductInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecProductInfo == nil {
				m.SpecProductInfo = &SpecProduct{}
			}
			if err := m.SpecProductInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessType", wireType)
			}
			m.BusinessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessType |= BusinessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenSwap", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenSwap = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainSwap", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RemainSwap = float64(math.Float64frombits(v))
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockMarketValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StockMarketValue = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionMarketValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionMarketValue = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicMoney", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DynamicMoney = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Premium", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Premium = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketValueEquity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MarketValueEquity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeFlag", wireType)
			}
			m.HedgeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HedgeFlag |= HedgeFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Margin = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgOpenPriceByVol", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgOpenPriceByVol = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgOpenPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgOpenPrice = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayVolume", wireType)
			}
			m.TodayVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenVolume", wireType)
			}
			m.FrozenVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrozenVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderSysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingRole", wireType)
			}
			m.TradingRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingRole |= TradingRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeInstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeInstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetFlag", wireType)
			}
			m.OffsetFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetFlag |= OffsetFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeFlag", wireType)
			}
			m.HedgeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HedgeFlag |= HedgeFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeType", wireType)
			}
			m.TradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeType |= TradeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSource", wireType)
			}
			m.PriceSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceSource |= PriceSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLocalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderLocalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingPartId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingPartId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusinessUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerOrderSeqence", wireType)
			}
			m.BrokerOrderSeqence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokerOrderSeqence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeSource", wireType)
			}
			m.TradeSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeSource |= TradeSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestorUnitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestorUnitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			m.AccountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountType |= AccountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubInfoType", wireType)
			}
			m.SubInfoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubInfoType |= SubInfoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= OrderPriceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LimitPrice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeTotalOrigin", wireType)
			}
			m.VolumeTotalOrigin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeTotalOrigin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCondition", wireType)
			}
			m.TimeCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCondition |= TimeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GtdDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GtdDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeCondition", wireType)
			}
			m.VolumeCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeCondition |= VolumeCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVolume", wireType)
			}
			m.MinVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContingentCondition", wireType)
			}
			m.ContingentCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContingentCondition |= ContingentCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StopPrice = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceCloseReason", wireType)
			}
			m.ForceCloseReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceCloseReason |= ForceCloseReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAutoSuspend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAutoSuspend = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusinessUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLocalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderLocalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeInstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeInstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallId", wireType)
			}
			m.InstallId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstallId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSubmitStatus", wireType)
			}
			m.OrderSubmitStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderSubmitStatus |= OrderSubmitStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifySequence", wireType)
			}
			m.NotifySequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotifySequence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderSysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSource", wireType)
			}
			m.OrderSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderSource |= OrderSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			m.OrderStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderStatus |= OrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeTraded", wireType)
			}
			m.VolumeTraded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeTraded |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeTotal", wireType)
			}
			m.VolumeTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspendTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuspendTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTraderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveTraderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingPartId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingPartId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontId", wireType)
			}
			m.FrontId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProductInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProductInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserForceClose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserForceClose = bool(v != 0)
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveUserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveUserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerOrderSequence", wireType)
			}
			m.BrokerOrderSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokerOrderSequence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeOrderSysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeOrderSysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZceTotalTradedVolume", wireType)
			}
			m.ZceTotalTradedVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZceTotalTradedVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSwapOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSwapOrder = bool(v != 0)
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestUnitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestUnitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			m.CurrencyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyId |= CurrencyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RiskUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RiskUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RiskUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspUserLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspUserLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspUserLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeType", wireType)
			}
			m.PrivilegeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegeType |= PrivilegeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivilegeInfo == nil {
				m.PrivilegeInfo = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStructures
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStructures
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStructures
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStructures
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStructures
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStructures
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStructures(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStructures
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PrivilegeInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspUserLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspUserLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspUserLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructures(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStructures
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStructures
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStructures
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStructures        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructures          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStructures = fmt.Errorf("proto: unexpected end of group")
)
