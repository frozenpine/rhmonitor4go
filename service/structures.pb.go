// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: structures.proto

package service

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CurrencyID int32

const (
	CNY CurrencyID = 0
	USD CurrencyID = 1
)

var CurrencyID_name = map[int32]string{
	0: "CNY",
	1: "USD",
}

var CurrencyID_value = map[string]int32{
	"CNY": 0,
	"USD": 1,
}

func (CurrencyID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{0}
}

type BusinessType int32

const (
	future BusinessType = 0
	stock  BusinessType = 1
)

var BusinessType_name = map[int32]string{
	0: "future",
	1: "stock",
}

var BusinessType_value = map[string]int32{
	"future": 0,
	"stock":  1,
}

func (BusinessType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{1}
}

type HedgeFlag int32

const (
	speculation  HedgeFlag = 0
	arbitrage    HedgeFlag = 1
	hedge        HedgeFlag = 2
	market_maker HedgeFlag = 3
)

var HedgeFlag_name = map[int32]string{
	0: "speculation",
	1: "arbitrage",
	2: "hedge",
	3: "market_maker",
}

var HedgeFlag_value = map[string]int32{
	"speculation":  0,
	"arbitrage":    1,
	"hedge":        2,
	"market_maker": 3,
}

func (HedgeFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{2}
}

type Direction int32

const (
	buy   Direction = 0
	long  Direction = 0
	sell  Direction = 1
	short Direction = 1
)

var Direction_name = map[int32]string{
	0: "buy",
	// Duplicate value: 0: "long",
	1: "sell",
	// Duplicate value: 1: "short",
}

var Direction_value = map[string]int32{
	"buy":   0,
	"long":  0,
	"sell":  1,
	"short": 1,
}

func (Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{3}
}

type OrderPriceType int32

const (
	any_price           OrderPriceType = 0
	limit_price         OrderPriceType = 1
	best_price          OrderPriceType = 2
	last_price          OrderPriceType = 3
	last_price_plus1    OrderPriceType = 4
	last_price_plus2    OrderPriceType = 5
	last_price_plus3    OrderPriceType = 6
	ask_price           OrderPriceType = 7
	ask_price_plus1     OrderPriceType = 8
	ask_price_plus2     OrderPriceType = 9
	ask_price_plus3     OrderPriceType = 10
	bid_price           OrderPriceType = 11
	bid_price_plus1     OrderPriceType = 12
	bid_price_plus2     OrderPriceType = 13
	bid_price_plus3     OrderPriceType = 14
	five_level_price    OrderPriceType = 15
	stop_loss_market    OrderPriceType = 16
	stop_loss_limit     OrderPriceType = 17
	gtc_limit           OrderPriceType = 18
	stock_lend          OrderPriceType = 19
	stock_financing_buy OrderPriceType = 20
	repay_stock         OrderPriceType = 21
	etf_purchase        OrderPriceType = 22
	etf_redemption      OrderPriceType = 23
)

var OrderPriceType_name = map[int32]string{
	0:  "any_price",
	1:  "limit_price",
	2:  "best_price",
	3:  "last_price",
	4:  "last_price_plus1",
	5:  "last_price_plus2",
	6:  "last_price_plus3",
	7:  "ask_price",
	8:  "ask_price_plus1",
	9:  "ask_price_plus2",
	10: "ask_price_plus3",
	11: "bid_price",
	12: "bid_price_plus1",
	13: "bid_price_plus2",
	14: "bid_price_plus3",
	15: "five_level_price",
	16: "stop_loss_market",
	17: "stop_loss_limit",
	18: "gtc_limit",
	19: "stock_lend",
	20: "stock_financing_buy",
	21: "repay_stock",
	22: "etf_purchase",
	23: "etf_redemption",
}

var OrderPriceType_value = map[string]int32{
	"any_price":           0,
	"limit_price":         1,
	"best_price":          2,
	"last_price":          3,
	"last_price_plus1":    4,
	"last_price_plus2":    5,
	"last_price_plus3":    6,
	"ask_price":           7,
	"ask_price_plus1":     8,
	"ask_price_plus2":     9,
	"ask_price_plus3":     10,
	"bid_price":           11,
	"bid_price_plus1":     12,
	"bid_price_plus2":     13,
	"bid_price_plus3":     14,
	"five_level_price":    15,
	"stop_loss_market":    16,
	"stop_loss_limit":     17,
	"gtc_limit":           18,
	"stock_lend":          19,
	"stock_financing_buy": 20,
	"repay_stock":         21,
	"etf_purchase":        22,
	"etf_redemption":      23,
}

func (OrderPriceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{4}
}

type TradingRole int32

const (
	broker TradingRole = 0
	host   TradingRole = 1
	maker  TradingRole = 2
)

var TradingRole_name = map[int32]string{
	0: "broker",
	1: "host",
	2: "maker",
}

var TradingRole_value = map[string]int32{
	"broker": 0,
	"host":   1,
	"maker":  2,
}

func (TradingRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{5}
}

type OffsetFlag int32

const (
	open            OffsetFlag = 0
	close           OffsetFlag = 1
	force_close     OffsetFlag = 2
	close_today     OffsetFlag = 3
	close_yesterday OffsetFlag = 4
	force_off       OffsetFlag = 5
	local_force_off OffsetFlag = 6
)

var OffsetFlag_name = map[int32]string{
	0: "open",
	1: "close",
	2: "force_close",
	3: "close_today",
	4: "close_yesterday",
	5: "force_off",
	6: "local_force_off",
}

var OffsetFlag_value = map[string]int32{
	"open":            0,
	"close":           1,
	"force_close":     2,
	"close_today":     3,
	"close_yesterday": 4,
	"force_off":       5,
	"local_force_off": 6,
}

func (OffsetFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{6}
}

type TradeType int32

const (
	split_combination   TradeType = 0
	common              TradeType = 1
	options_execution   TradeType = 2
	otc                 TradeType = 3
	efp_derived         TradeType = 4
	combination_derived TradeType = 5
	finacing_buy        TradeType = 6
	repay_stock_auto    TradeType = 7
	repay_stock_manual  TradeType = 8
)

var TradeType_name = map[int32]string{
	0: "split_combination",
	1: "common",
	2: "options_execution",
	3: "otc",
	4: "efp_derived",
	5: "combination_derived",
	6: "finacing_buy",
	7: "repay_stock_auto",
	8: "repay_stock_manual",
}

var TradeType_value = map[string]int32{
	"split_combination":   0,
	"common":              1,
	"options_execution":   2,
	"otc":                 3,
	"efp_derived":         4,
	"combination_derived": 5,
	"finacing_buy":        6,
	"repay_stock_auto":    7,
	"repay_stock_manual":  8,
}

func (TradeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{7}
}

type PriceSource int32

const (
	ps_last_price PriceSource = 0
	ps_buy        PriceSource = 1
	ps_sell       PriceSource = 2
)

var PriceSource_name = map[int32]string{
	0: "ps_last_price",
	1: "ps_buy",
	2: "ps_sell",
}

var PriceSource_value = map[string]int32{
	"ps_last_price": 0,
	"ps_buy":        1,
	"ps_sell":       2,
}

func (PriceSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{8}
}

type TradeSource int32

const (
	ts_normal TradeSource = 0
	ts_query  TradeSource = 1
)

var TradeSource_name = map[int32]string{
	0: "ts_normal",
	1: "ts_query",
}

var TradeSource_value = map[string]int32{
	"ts_normal": 0,
	"ts_query":  1,
}

func (TradeSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{9}
}

type AccountType int32

const (
	virtual    AccountType = 0
	real       AccountType = 1
	real_group AccountType = 2
)

var AccountType_name = map[int32]string{
	0: "virtual",
	1: "real",
	2: "real_group",
}

var AccountType_value = map[string]int32{
	"virtual":    0,
	"real":       1,
	"real_group": 2,
}

func (AccountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{10}
}

type SubInfoType int32

const (
	order SubInfoType = 0
	trade SubInfoType = 1
)

var SubInfoType_name = map[int32]string{
	0: "order",
	1: "trade",
}

var SubInfoType_value = map[string]int32{
	"order": 0,
	"trade": 1,
}

func (SubInfoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{11}
}

type PrivilegeType int32

const (
	admin  PrivilegeType = 0
	normal PrivilegeType = 1
)

var PrivilegeType_name = map[int32]string{
	0: "admin",
	1: "normal",
}

var PrivilegeType_value = map[string]int32{
	"admin":  0,
	"normal": 1,
}

func (PrivilegeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{12}
}

type RspInfo struct {
	ErrorId  int32  `protobuf:"varint,1,opt,name=error_id,json=errorId,proto3" json:"error_id,omitempty"`
	ErrorMsg string `protobuf:"bytes,2,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
}

func (m *RspInfo) Reset()      { *m = RspInfo{} }
func (*RspInfo) ProtoMessage() {}
func (*RspInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{0}
}
func (m *RspInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspInfo.Merge(m, src)
}
func (m *RspInfo) XXX_Size() int {
	return m.Size()
}
func (m *RspInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RspInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RspInfo proto.InternalMessageInfo

func (m *RspInfo) GetErrorId() int32 {
	if m != nil {
		return m.ErrorId
	}
	return 0
}

func (m *RspInfo) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type Investor struct {
	BrokerId   string `protobuf:"bytes,1,opt,name=broker_id,json=brokerId,proto3" json:"broker_id,omitempty"`
	InvestorId string `protobuf:"bytes,2,opt,name=investor_id,json=investorId,proto3" json:"investor_id,omitempty"`
}

func (m *Investor) Reset()      { *m = Investor{} }
func (*Investor) ProtoMessage() {}
func (*Investor) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{1}
}
func (m *Investor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Investor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Investor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Investor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Investor.Merge(m, src)
}
func (m *Investor) XXX_Size() int {
	return m.Size()
}
func (m *Investor) XXX_DiscardUnknown() {
	xxx_messageInfo_Investor.DiscardUnknown(m)
}

var xxx_messageInfo_Investor proto.InternalMessageInfo

func (m *Investor) GetBrokerId() string {
	if m != nil {
		return m.BrokerId
	}
	return ""
}

func (m *Investor) GetInvestorId() string {
	if m != nil {
		return m.InvestorId
	}
	return ""
}

type FundMortgage struct {
	PreIn       float64 `protobuf:"fixed64,1,opt,name=pre_in,json=preIn,proto3" json:"pre_in,omitempty"`
	PreOut      float64 `protobuf:"fixed64,2,opt,name=pre_out,json=preOut,proto3" json:"pre_out,omitempty"`
	PreMortgage float64 `protobuf:"fixed64,3,opt,name=pre_mortgage,json=preMortgage,proto3" json:"pre_mortgage,omitempty"`
	CurrentIn   float64 `protobuf:"fixed64,4,opt,name=current_in,json=currentIn,proto3" json:"current_in,omitempty"`
	CurrentOut  float64 `protobuf:"fixed64,5,opt,name=current_out,json=currentOut,proto3" json:"current_out,omitempty"`
	Mortgage    float64 `protobuf:"fixed64,6,opt,name=mortgage,proto3" json:"mortgage,omitempty"`
	Available   float64 `protobuf:"fixed64,7,opt,name=available,proto3" json:"available,omitempty"`
	Mortgagable float64 `protobuf:"fixed64,8,opt,name=mortgagable,proto3" json:"mortgagable,omitempty"`
}

func (m *FundMortgage) Reset()      { *m = FundMortgage{} }
func (*FundMortgage) ProtoMessage() {}
func (*FundMortgage) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{2}
}
func (m *FundMortgage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundMortgage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundMortgage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundMortgage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundMortgage.Merge(m, src)
}
func (m *FundMortgage) XXX_Size() int {
	return m.Size()
}
func (m *FundMortgage) XXX_DiscardUnknown() {
	xxx_messageInfo_FundMortgage.DiscardUnknown(m)
}

var xxx_messageInfo_FundMortgage proto.InternalMessageInfo

func (m *FundMortgage) GetPreIn() float64 {
	if m != nil {
		return m.PreIn
	}
	return 0
}

func (m *FundMortgage) GetPreOut() float64 {
	if m != nil {
		return m.PreOut
	}
	return 0
}

func (m *FundMortgage) GetPreMortgage() float64 {
	if m != nil {
		return m.PreMortgage
	}
	return 0
}

func (m *FundMortgage) GetCurrentIn() float64 {
	if m != nil {
		return m.CurrentIn
	}
	return 0
}

func (m *FundMortgage) GetCurrentOut() float64 {
	if m != nil {
		return m.CurrentOut
	}
	return 0
}

func (m *FundMortgage) GetMortgage() float64 {
	if m != nil {
		return m.Mortgage
	}
	return 0
}

func (m *FundMortgage) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *FundMortgage) GetMortgagable() float64 {
	if m != nil {
		return m.Mortgagable
	}
	return 0
}

type SpecProduct struct {
	Margin              float64 `protobuf:"fixed64,1,opt,name=margin,proto3" json:"margin,omitempty"`
	FrozenMargin        float64 `protobuf:"fixed64,2,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozen_margin,omitempty"`
	Commission          float64 `protobuf:"fixed64,3,opt,name=commission,proto3" json:"commission,omitempty"`
	FrozenCommission    float64 `protobuf:"fixed64,4,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozen_commission,omitempty"`
	PositionProfit      float64 `protobuf:"fixed64,5,opt,name=position_profit,json=positionProfit,proto3" json:"position_profit,omitempty"`
	CloseProfit         float64 `protobuf:"fixed64,6,opt,name=close_profit,json=closeProfit,proto3" json:"close_profit,omitempty"`
	PositionProfitByAlg float64 `protobuf:"fixed64,7,opt,name=position_profit_by_alg,json=positionProfitByAlg,proto3" json:"position_profit_by_alg,omitempty"`
	ExchangeMargin      float64 `protobuf:"fixed64,8,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchange_margin,omitempty"`
}

func (m *SpecProduct) Reset()      { *m = SpecProduct{} }
func (*SpecProduct) ProtoMessage() {}
func (*SpecProduct) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{3}
}
func (m *SpecProduct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecProduct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecProduct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecProduct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecProduct.Merge(m, src)
}
func (m *SpecProduct) XXX_Size() int {
	return m.Size()
}
func (m *SpecProduct) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecProduct.DiscardUnknown(m)
}

var xxx_messageInfo_SpecProduct proto.InternalMessageInfo

func (m *SpecProduct) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *SpecProduct) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *SpecProduct) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *SpecProduct) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *SpecProduct) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *SpecProduct) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *SpecProduct) GetPositionProfitByAlg() float64 {
	if m != nil {
		return m.PositionProfitByAlg
	}
	return 0
}

func (m *SpecProduct) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

type Account struct {
	Investor               *Investor     `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	PreCredit              float64       `protobuf:"fixed64,2,opt,name=pre_credit,json=preCredit,proto3" json:"pre_credit,omitempty"`
	PreDeposit             float64       `protobuf:"fixed64,3,opt,name=pre_deposit,json=preDeposit,proto3" json:"pre_deposit,omitempty"`
	PreBalance             float64       `protobuf:"fixed64,4,opt,name=pre_balance,json=preBalance,proto3" json:"pre_balance,omitempty"`
	PreMargin              float64       `protobuf:"fixed64,5,opt,name=pre_margin,json=preMargin,proto3" json:"pre_margin,omitempty"`
	InterestBase           float64       `protobuf:"fixed64,6,opt,name=interest_base,json=interestBase,proto3" json:"interest_base,omitempty"`
	Interest               float64       `protobuf:"fixed64,7,opt,name=interest,proto3" json:"interest,omitempty"`
	Deposit                float64       `protobuf:"fixed64,8,opt,name=deposit,proto3" json:"deposit,omitempty"`
	Withdraw               float64       `protobuf:"fixed64,9,opt,name=withdraw,proto3" json:"withdraw,omitempty"`
	FrozenMargin           float64       `protobuf:"fixed64,10,opt,name=frozen_margin,json=frozenMargin,proto3" json:"frozen_margin,omitempty"`
	FrozenCash             float64       `protobuf:"fixed64,11,opt,name=frozen_cash,json=frozenCash,proto3" json:"frozen_cash,omitempty"`
	FrozenCommission       float64       `protobuf:"fixed64,12,opt,name=frozen_commission,json=frozenCommission,proto3" json:"frozen_commission,omitempty"`
	CurrentMargin          float64       `protobuf:"fixed64,13,opt,name=current_margin,json=currentMargin,proto3" json:"current_margin,omitempty"`
	CashIn                 float64       `protobuf:"fixed64,14,opt,name=cash_in,json=cashIn,proto3" json:"cash_in,omitempty"`
	Commission             float64       `protobuf:"fixed64,15,opt,name=commission,proto3" json:"commission,omitempty"`
	CloseProfit            float64       `protobuf:"fixed64,16,opt,name=close_profit,json=closeProfit,proto3" json:"close_profit,omitempty"`
	PositionProfit         float64       `protobuf:"fixed64,17,opt,name=position_profit,json=positionProfit,proto3" json:"position_profit,omitempty"`
	Balance                float64       `protobuf:"fixed64,18,opt,name=balance,proto3" json:"balance,omitempty"`
	Available              float64       `protobuf:"fixed64,19,opt,name=available,proto3" json:"available,omitempty"`
	WithdrawQuota          float64       `protobuf:"fixed64,20,opt,name=withdraw_quota,json=withdrawQuota,proto3" json:"withdraw_quota,omitempty"`
	Reserve                float64       `protobuf:"fixed64,21,opt,name=reserve,proto3" json:"reserve,omitempty"`
	TradingDay             string        `protobuf:"bytes,22,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	SettlementId           int32         `protobuf:"varint,23,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	Credit                 float64       `protobuf:"fixed64,24,opt,name=credit,proto3" json:"credit,omitempty"`
	ExchangeMargin         float64       `protobuf:"fixed64,25,opt,name=exchange_margin,json=exchangeMargin,proto3" json:"exchange_margin,omitempty"`
	DeliveryMargin         float64       `protobuf:"fixed64,26,opt,name=delivery_margin,json=deliveryMargin,proto3" json:"delivery_margin,omitempty"`
	ExchangeDeliveryMargin float64       `protobuf:"fixed64,27,opt,name=exchange_delivery_margin,json=exchangeDeliveryMargin,proto3" json:"exchange_delivery_margin,omitempty"`
	ReserveBalance         float64       `protobuf:"fixed64,28,opt,name=reserve_balance,json=reserveBalance,proto3" json:"reserve_balance,omitempty"`
	CurrencyId             CurrencyID    `protobuf:"varint,29,opt,name=currency_id,json=currencyId,proto3,enum=service.CurrencyID" json:"currency_id,omitempty"`
	MortgageInfo           *FundMortgage `protobuf:"bytes,30,opt,name=mortgage_info,json=mortgageInfo,proto3" json:"mortgage_info,omitempty"`
	SpecProductInfo        *SpecProduct  `protobuf:"bytes,31,opt,name=spec_product_info,json=specProductInfo,proto3" json:"spec_product_info,omitempty"`
	BusinessType           BusinessType  `protobuf:"varint,32,opt,name=business_type,json=businessType,proto3,enum=service.BusinessType" json:"business_type,omitempty"`
	FrozenSwap             float64       `protobuf:"fixed64,33,opt,name=frozen_swap,json=frozenSwap,proto3" json:"frozen_swap,omitempty"`
	RemainSwap             float64       `protobuf:"fixed64,34,opt,name=remain_swap,json=remainSwap,proto3" json:"remain_swap,omitempty"`
	StockMarketValue       float64       `protobuf:"fixed64,35,opt,name=stock_market_value,json=stockMarketValue,proto3" json:"stock_market_value,omitempty"`
	OptionMarketValue      float64       `protobuf:"fixed64,36,opt,name=option_market_value,json=optionMarketValue,proto3" json:"option_market_value,omitempty"`
	DynamicMoney           float64       `protobuf:"fixed64,37,opt,name=dynamic_money,json=dynamicMoney,proto3" json:"dynamic_money,omitempty"`
	Premium                float64       `protobuf:"fixed64,38,opt,name=premium,proto3" json:"premium,omitempty"`
	MarketValueEquity      float64       `protobuf:"fixed64,39,opt,name=market_value_equity,json=marketValueEquity,proto3" json:"market_value_equity,omitempty"`
}

func (m *Account) Reset()      { *m = Account{} }
func (*Account) ProtoMessage() {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{4}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Account) GetPreCredit() float64 {
	if m != nil {
		return m.PreCredit
	}
	return 0
}

func (m *Account) GetPreDeposit() float64 {
	if m != nil {
		return m.PreDeposit
	}
	return 0
}

func (m *Account) GetPreBalance() float64 {
	if m != nil {
		return m.PreBalance
	}
	return 0
}

func (m *Account) GetPreMargin() float64 {
	if m != nil {
		return m.PreMargin
	}
	return 0
}

func (m *Account) GetInterestBase() float64 {
	if m != nil {
		return m.InterestBase
	}
	return 0
}

func (m *Account) GetInterest() float64 {
	if m != nil {
		return m.Interest
	}
	return 0
}

func (m *Account) GetDeposit() float64 {
	if m != nil {
		return m.Deposit
	}
	return 0
}

func (m *Account) GetWithdraw() float64 {
	if m != nil {
		return m.Withdraw
	}
	return 0
}

func (m *Account) GetFrozenMargin() float64 {
	if m != nil {
		return m.FrozenMargin
	}
	return 0
}

func (m *Account) GetFrozenCash() float64 {
	if m != nil {
		return m.FrozenCash
	}
	return 0
}

func (m *Account) GetFrozenCommission() float64 {
	if m != nil {
		return m.FrozenCommission
	}
	return 0
}

func (m *Account) GetCurrentMargin() float64 {
	if m != nil {
		return m.CurrentMargin
	}
	return 0
}

func (m *Account) GetCashIn() float64 {
	if m != nil {
		return m.CashIn
	}
	return 0
}

func (m *Account) GetCommission() float64 {
	if m != nil {
		return m.Commission
	}
	return 0
}

func (m *Account) GetCloseProfit() float64 {
	if m != nil {
		return m.CloseProfit
	}
	return 0
}

func (m *Account) GetPositionProfit() float64 {
	if m != nil {
		return m.PositionProfit
	}
	return 0
}

func (m *Account) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetAvailable() float64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *Account) GetWithdrawQuota() float64 {
	if m != nil {
		return m.WithdrawQuota
	}
	return 0
}

func (m *Account) GetReserve() float64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *Account) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *Account) GetSettlementId() int32 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Account) GetCredit() float64 {
	if m != nil {
		return m.Credit
	}
	return 0
}

func (m *Account) GetExchangeMargin() float64 {
	if m != nil {
		return m.ExchangeMargin
	}
	return 0
}

func (m *Account) GetDeliveryMargin() float64 {
	if m != nil {
		return m.DeliveryMargin
	}
	return 0
}

func (m *Account) GetExchangeDeliveryMargin() float64 {
	if m != nil {
		return m.ExchangeDeliveryMargin
	}
	return 0
}

func (m *Account) GetReserveBalance() float64 {
	if m != nil {
		return m.ReserveBalance
	}
	return 0
}

func (m *Account) GetCurrencyId() CurrencyID {
	if m != nil {
		return m.CurrencyId
	}
	return CNY
}

func (m *Account) GetMortgageInfo() *FundMortgage {
	if m != nil {
		return m.MortgageInfo
	}
	return nil
}

func (m *Account) GetSpecProductInfo() *SpecProduct {
	if m != nil {
		return m.SpecProductInfo
	}
	return nil
}

func (m *Account) GetBusinessType() BusinessType {
	if m != nil {
		return m.BusinessType
	}
	return future
}

func (m *Account) GetFrozenSwap() float64 {
	if m != nil {
		return m.FrozenSwap
	}
	return 0
}

func (m *Account) GetRemainSwap() float64 {
	if m != nil {
		return m.RemainSwap
	}
	return 0
}

func (m *Account) GetStockMarketValue() float64 {
	if m != nil {
		return m.StockMarketValue
	}
	return 0
}

func (m *Account) GetOptionMarketValue() float64 {
	if m != nil {
		return m.OptionMarketValue
	}
	return 0
}

func (m *Account) GetDynamicMoney() float64 {
	if m != nil {
		return m.DynamicMoney
	}
	return 0
}

func (m *Account) GetPremium() float64 {
	if m != nil {
		return m.Premium
	}
	return 0
}

func (m *Account) GetMarketValueEquity() float64 {
	if m != nil {
		return m.MarketValueEquity
	}
	return 0
}

type Position struct {
	Investor          *Investor `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	ProductId         string    `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	InstrumentId      string    `protobuf:"bytes,3,opt,name=instrument_id,json=instrumentId,proto3" json:"instrument_id,omitempty"`
	HedgeFlag         HedgeFlag `protobuf:"varint,4,opt,name=hedge_flag,json=hedgeFlag,proto3,enum=service.HedgeFlag" json:"hedge_flag,omitempty"`
	Direction         Direction `protobuf:"varint,5,opt,name=direction,proto3,enum=service.Direction" json:"direction,omitempty"`
	Volume            int32     `protobuf:"varint,6,opt,name=volume,proto3" json:"volume,omitempty"`
	Margin            float64   `protobuf:"fixed64,7,opt,name=margin,proto3" json:"margin,omitempty"`
	AvgOpenPriceByVol float64   `protobuf:"fixed64,8,opt,name=avg_open_price_by_vol,json=avgOpenPriceByVol,proto3" json:"avg_open_price_by_vol,omitempty"`
	AvgOpenPrice      float64   `protobuf:"fixed64,9,opt,name=avg_open_price,json=avgOpenPrice,proto3" json:"avg_open_price,omitempty"`
	TodayVolume       int32     `protobuf:"varint,10,opt,name=today_volume,json=todayVolume,proto3" json:"today_volume,omitempty"`
	FrozenVolume      int32     `protobuf:"varint,11,opt,name=frozen_volume,json=frozenVolume,proto3" json:"frozen_volume,omitempty"`
	EntryType         uint32    `protobuf:"varint,12,opt,name=entry_type,json=entryType,proto3" json:"entry_type,omitempty"`
}

func (m *Position) Reset()      { *m = Position{} }
func (*Position) ProtoMessage() {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{5}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Position) GetProductId() string {
	if m != nil {
		return m.ProductId
	}
	return ""
}

func (m *Position) GetInstrumentId() string {
	if m != nil {
		return m.InstrumentId
	}
	return ""
}

func (m *Position) GetHedgeFlag() HedgeFlag {
	if m != nil {
		return m.HedgeFlag
	}
	return speculation
}

func (m *Position) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return buy
}

func (m *Position) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Position) GetMargin() float64 {
	if m != nil {
		return m.Margin
	}
	return 0
}

func (m *Position) GetAvgOpenPriceByVol() float64 {
	if m != nil {
		return m.AvgOpenPriceByVol
	}
	return 0
}

func (m *Position) GetAvgOpenPrice() float64 {
	if m != nil {
		return m.AvgOpenPrice
	}
	return 0
}

func (m *Position) GetTodayVolume() int32 {
	if m != nil {
		return m.TodayVolume
	}
	return 0
}

func (m *Position) GetFrozenVolume() int32 {
	if m != nil {
		return m.FrozenVolume
	}
	return 0
}

func (m *Position) GetEntryType() uint32 {
	if m != nil {
		return m.EntryType
	}
	return 0
}

type Trade struct {
	Investor             *Investor   `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	InstrumentId         string      `protobuf:"bytes,2,opt,name=instrument_id,json=instrumentId,proto3" json:"instrument_id,omitempty"`
	OrderRef             string      `protobuf:"bytes,3,opt,name=order_ref,json=orderRef,proto3" json:"order_ref,omitempty"`
	UserId               string      `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ExchangeId           string      `protobuf:"bytes,5,opt,name=exchange_id,json=exchangeId,proto3" json:"exchange_id,omitempty"`
	TradeId              string      `protobuf:"bytes,6,opt,name=trade_id,json=tradeId,proto3" json:"trade_id,omitempty"`
	Direction            Direction   `protobuf:"varint,7,opt,name=direction,proto3,enum=service.Direction" json:"direction,omitempty"`
	OrderSysId           string      `protobuf:"bytes,8,opt,name=order_sys_id,json=orderSysId,proto3" json:"order_sys_id,omitempty"`
	ParticipantId        string      `protobuf:"bytes,9,opt,name=participant_id,json=participantId,proto3" json:"participant_id,omitempty"`
	ClientId             string      `protobuf:"bytes,10,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	TradingRole          TradingRole `protobuf:"varint,11,opt,name=trading_role,json=tradingRole,proto3,enum=service.TradingRole" json:"trading_role,omitempty"`
	ExchangeInstrumentId string      `protobuf:"bytes,12,opt,name=exchange_instrument_id,json=exchangeInstrumentId,proto3" json:"exchange_instrument_id,omitempty"`
	OffsetFlag           OffsetFlag  `protobuf:"varint,13,opt,name=offset_flag,json=offsetFlag,proto3,enum=service.OffsetFlag" json:"offset_flag,omitempty"`
	HedgeFlag            HedgeFlag   `protobuf:"varint,14,opt,name=hedge_flag,json=hedgeFlag,proto3,enum=service.HedgeFlag" json:"hedge_flag,omitempty"`
	Price                float64     `protobuf:"fixed64,15,opt,name=price,proto3" json:"price,omitempty"`
	Volume               int32       `protobuf:"varint,16,opt,name=volume,proto3" json:"volume,omitempty"`
	TradeDate            string      `protobuf:"bytes,17,opt,name=trade_date,json=tradeDate,proto3" json:"trade_date,omitempty"`
	TradeTime            string      `protobuf:"bytes,18,opt,name=trade_time,json=tradeTime,proto3" json:"trade_time,omitempty"`
	TradeType            TradeType   `protobuf:"varint,19,opt,name=trade_type,json=tradeType,proto3,enum=service.TradeType" json:"trade_type,omitempty"`
	PriceSource          PriceSource `protobuf:"varint,20,opt,name=price_source,json=priceSource,proto3,enum=service.PriceSource" json:"price_source,omitempty"`
	TraderId             string      `protobuf:"bytes,21,opt,name=trader_id,json=traderId,proto3" json:"trader_id,omitempty"`
	OrderLocalId         string      `protobuf:"bytes,22,opt,name=order_local_id,json=orderLocalId,proto3" json:"order_local_id,omitempty"`
	ClearingPartId       string      `protobuf:"bytes,23,opt,name=clearing_part_id,json=clearingPartId,proto3" json:"clearing_part_id,omitempty"`
	BusinessUnit         string      `protobuf:"bytes,24,opt,name=business_unit,json=businessUnit,proto3" json:"business_unit,omitempty"`
	SequenceNo           int32       `protobuf:"varint,25,opt,name=sequence_no,json=sequenceNo,proto3" json:"sequence_no,omitempty"`
	TradingDay           string      `protobuf:"bytes,26,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	SettlementId         int32       `protobuf:"varint,27,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	BrokerOrderSeqence   int32       `protobuf:"varint,28,opt,name=broker_order_seqence,json=brokerOrderSeqence,proto3" json:"broker_order_seqence,omitempty"`
	TradeSource          TradeSource `protobuf:"varint,29,opt,name=trade_source,json=tradeSource,proto3,enum=service.TradeSource" json:"trade_source,omitempty"`
	InvestorUnitId       string      `protobuf:"bytes,30,opt,name=investor_unit_id,json=investorUnitId,proto3" json:"investor_unit_id,omitempty"`
}

func (m *Trade) Reset()      { *m = Trade{} }
func (*Trade) ProtoMessage() {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{6}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *Trade) GetInstrumentId() string {
	if m != nil {
		return m.InstrumentId
	}
	return ""
}

func (m *Trade) GetOrderRef() string {
	if m != nil {
		return m.OrderRef
	}
	return ""
}

func (m *Trade) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Trade) GetExchangeId() string {
	if m != nil {
		return m.ExchangeId
	}
	return ""
}

func (m *Trade) GetTradeId() string {
	if m != nil {
		return m.TradeId
	}
	return ""
}

func (m *Trade) GetDirection() Direction {
	if m != nil {
		return m.Direction
	}
	return buy
}

func (m *Trade) GetOrderSysId() string {
	if m != nil {
		return m.OrderSysId
	}
	return ""
}

func (m *Trade) GetParticipantId() string {
	if m != nil {
		return m.ParticipantId
	}
	return ""
}

func (m *Trade) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Trade) GetTradingRole() TradingRole {
	if m != nil {
		return m.TradingRole
	}
	return broker
}

func (m *Trade) GetExchangeInstrumentId() string {
	if m != nil {
		return m.ExchangeInstrumentId
	}
	return ""
}

func (m *Trade) GetOffsetFlag() OffsetFlag {
	if m != nil {
		return m.OffsetFlag
	}
	return open
}

func (m *Trade) GetHedgeFlag() HedgeFlag {
	if m != nil {
		return m.HedgeFlag
	}
	return speculation
}

func (m *Trade) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Trade) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Trade) GetTradeDate() string {
	if m != nil {
		return m.TradeDate
	}
	return ""
}

func (m *Trade) GetTradeTime() string {
	if m != nil {
		return m.TradeTime
	}
	return ""
}

func (m *Trade) GetTradeType() TradeType {
	if m != nil {
		return m.TradeType
	}
	return split_combination
}

func (m *Trade) GetPriceSource() PriceSource {
	if m != nil {
		return m.PriceSource
	}
	return ps_last_price
}

func (m *Trade) GetTraderId() string {
	if m != nil {
		return m.TraderId
	}
	return ""
}

func (m *Trade) GetOrderLocalId() string {
	if m != nil {
		return m.OrderLocalId
	}
	return ""
}

func (m *Trade) GetClearingPartId() string {
	if m != nil {
		return m.ClearingPartId
	}
	return ""
}

func (m *Trade) GetBusinessUnit() string {
	if m != nil {
		return m.BusinessUnit
	}
	return ""
}

func (m *Trade) GetSequenceNo() int32 {
	if m != nil {
		return m.SequenceNo
	}
	return 0
}

func (m *Trade) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *Trade) GetSettlementId() int32 {
	if m != nil {
		return m.SettlementId
	}
	return 0
}

func (m *Trade) GetBrokerOrderSeqence() int32 {
	if m != nil {
		return m.BrokerOrderSeqence
	}
	return 0
}

func (m *Trade) GetTradeSource() TradeSource {
	if m != nil {
		return m.TradeSource
	}
	return ts_normal
}

func (m *Trade) GetInvestorUnitId() string {
	if m != nil {
		return m.InvestorUnitId
	}
	return ""
}

type SubInfo struct {
	Investor    *Investor   `protobuf:"bytes,1,opt,name=investor,proto3" json:"investor,omitempty"`
	AccountType AccountType `protobuf:"varint,2,opt,name=account_type,json=accountType,proto3,enum=service.AccountType" json:"account_type,omitempty"`
	SubInfoType SubInfoType `protobuf:"varint,3,opt,name=sub_info_type,json=subInfoType,proto3,enum=service.SubInfoType" json:"sub_info_type,omitempty"`
}

func (m *SubInfo) Reset()      { *m = SubInfo{} }
func (*SubInfo) ProtoMessage() {}
func (*SubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{7}
}
func (m *SubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubInfo.Merge(m, src)
}
func (m *SubInfo) XXX_Size() int {
	return m.Size()
}
func (m *SubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SubInfo proto.InternalMessageInfo

func (m *SubInfo) GetInvestor() *Investor {
	if m != nil {
		return m.Investor
	}
	return nil
}

func (m *SubInfo) GetAccountType() AccountType {
	if m != nil {
		return m.AccountType
	}
	return virtual
}

func (m *SubInfo) GetSubInfoType() SubInfoType {
	if m != nil {
		return m.SubInfoType
	}
	return order
}

type RiskUser struct {
	UserId   string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	MacAddr  string `protobuf:"bytes,3,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
}

func (m *RiskUser) Reset()      { *m = RiskUser{} }
func (*RiskUser) ProtoMessage() {}
func (*RiskUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{8}
}
func (m *RiskUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RiskUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RiskUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RiskUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RiskUser.Merge(m, src)
}
func (m *RiskUser) XXX_Size() int {
	return m.Size()
}
func (m *RiskUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RiskUser.DiscardUnknown(m)
}

var xxx_messageInfo_RiskUser proto.InternalMessageInfo

func (m *RiskUser) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *RiskUser) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RiskUser) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

type RspUserLogin struct {
	UserId        string        `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	TradingDay    string        `protobuf:"bytes,2,opt,name=trading_day,json=tradingDay,proto3" json:"trading_day,omitempty"`
	LoginTime     string        `protobuf:"bytes,3,opt,name=login_time,json=loginTime,proto3" json:"login_time,omitempty"`
	PrivilegeType PrivilegeType `protobuf:"varint,4,opt,name=privilege_type,json=privilegeType,proto3,enum=service.PrivilegeType" json:"privilege_type,omitempty"`
	PrivilegeInfo string        `protobuf:"bytes,5,opt,name=privilege_info,json=privilegeInfo,proto3" json:"privilege_info,omitempty"`
}

func (m *RspUserLogin) Reset()      { *m = RspUserLogin{} }
func (*RspUserLogin) ProtoMessage() {}
func (*RspUserLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{9}
}
func (m *RspUserLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspUserLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspUserLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspUserLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspUserLogin.Merge(m, src)
}
func (m *RspUserLogin) XXX_Size() int {
	return m.Size()
}
func (m *RspUserLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_RspUserLogin.DiscardUnknown(m)
}

var xxx_messageInfo_RspUserLogin proto.InternalMessageInfo

func (m *RspUserLogin) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *RspUserLogin) GetTradingDay() string {
	if m != nil {
		return m.TradingDay
	}
	return ""
}

func (m *RspUserLogin) GetLoginTime() string {
	if m != nil {
		return m.LoginTime
	}
	return ""
}

func (m *RspUserLogin) GetPrivilegeType() PrivilegeType {
	if m != nil {
		return m.PrivilegeType
	}
	return admin
}

func (m *RspUserLogin) GetPrivilegeInfo() string {
	if m != nil {
		return m.PrivilegeInfo
	}
	return ""
}

type RspUserLogout struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *RspUserLogout) Reset()      { *m = RspUserLogout{} }
func (*RspUserLogout) ProtoMessage() {}
func (*RspUserLogout) Descriptor() ([]byte, []int) {
	return fileDescriptor_66ea84bc81126bff, []int{10}
}
func (m *RspUserLogout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspUserLogout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspUserLogout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspUserLogout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspUserLogout.Merge(m, src)
}
func (m *RspUserLogout) XXX_Size() int {
	return m.Size()
}
func (m *RspUserLogout) XXX_DiscardUnknown() {
	xxx_messageInfo_RspUserLogout.DiscardUnknown(m)
}

var xxx_messageInfo_RspUserLogout proto.InternalMessageInfo

func (m *RspUserLogout) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func init() {
	proto.RegisterEnum("service.CurrencyID", CurrencyID_name, CurrencyID_value)
	proto.RegisterEnum("service.BusinessType", BusinessType_name, BusinessType_value)
	proto.RegisterEnum("service.HedgeFlag", HedgeFlag_name, HedgeFlag_value)
	proto.RegisterEnum("service.Direction", Direction_name, Direction_value)
	proto.RegisterEnum("service.OrderPriceType", OrderPriceType_name, OrderPriceType_value)
	proto.RegisterEnum("service.TradingRole", TradingRole_name, TradingRole_value)
	proto.RegisterEnum("service.OffsetFlag", OffsetFlag_name, OffsetFlag_value)
	proto.RegisterEnum("service.TradeType", TradeType_name, TradeType_value)
	proto.RegisterEnum("service.PriceSource", PriceSource_name, PriceSource_value)
	proto.RegisterEnum("service.TradeSource", TradeSource_name, TradeSource_value)
	proto.RegisterEnum("service.AccountType", AccountType_name, AccountType_value)
	proto.RegisterEnum("service.SubInfoType", SubInfoType_name, SubInfoType_value)
	proto.RegisterEnum("service.PrivilegeType", PrivilegeType_name, PrivilegeType_value)
	proto.RegisterType((*RspInfo)(nil), "service.RspInfo")
	proto.RegisterType((*Investor)(nil), "service.Investor")
	proto.RegisterType((*FundMortgage)(nil), "service.FundMortgage")
	proto.RegisterType((*SpecProduct)(nil), "service.SpecProduct")
	proto.RegisterType((*Account)(nil), "service.Account")
	proto.RegisterType((*Position)(nil), "service.Position")
	proto.RegisterType((*Trade)(nil), "service.Trade")
	proto.RegisterType((*SubInfo)(nil), "service.SubInfo")
	proto.RegisterType((*RiskUser)(nil), "service.RiskUser")
	proto.RegisterType((*RspUserLogin)(nil), "service.RspUserLogin")
	proto.RegisterType((*RspUserLogout)(nil), "service.RspUserLogout")
}

func init() { proto.RegisterFile("structures.proto", fileDescriptor_66ea84bc81126bff) }

var fileDescriptor_66ea84bc81126bff = []byte{
	// 2442 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x52, 0xa2, 0xc8, 0x7d, 0xfc, 0xa3, 0xd5, 0xea, 0x8f, 0x19, 0x3b, 0x62, 0x14, 0x3a,
	0x4e, 0x0c, 0xb6, 0x35, 0x12, 0xd9, 0x80, 0xd3, 0x00, 0x05, 0x6a, 0x59, 0x0d, 0x42, 0x20, 0x8a,
	0xdd, 0x95, 0x13, 0xa0, 0xbd, 0x2c, 0x86, 0xbb, 0x43, 0x6a, 0xa1, 0xdd, 0x9d, 0xf5, 0xcc, 0x2e,
	0x1d, 0x16, 0x3d, 0xf4, 0x23, 0xf4, 0x3b, 0xf4, 0x52, 0xa0, 0x5f, 0xa0, 0xd7, 0xde, 0x7a, 0x29,
	0x90, 0xde, 0xd2, 0x4b, 0xd1, 0xc8, 0x97, 0x1e, 0xf3, 0x05, 0x0a, 0x14, 0x6f, 0xfe, 0x2c, 0x57,
	0x14, 0x83, 0x26, 0xbd, 0xf1, 0xfd, 0xde, 0x9b, 0x37, 0x6f, 0xde, 0xff, 0x25, 0x38, 0x22, 0xe7,
	0x45, 0x90, 0x17, 0x9c, 0x8a, 0x07, 0x19, 0x67, 0x39, 0x73, 0x9b, 0x82, 0xf2, 0x79, 0x14, 0xd0,
	0xe1, 0x13, 0x68, 0x7a, 0x22, 0x1b, 0xa7, 0x53, 0xe6, 0xbe, 0x01, 0x2d, 0xca, 0x39, 0xe3, 0x7e,
	0x14, 0xf6, 0xad, 0x23, 0xeb, 0x7e, 0xc3, 0x6b, 0x4a, 0x7a, 0x1c, 0xba, 0x77, 0xc0, 0x56, 0xac,
	0x44, 0xcc, 0xfa, 0xf5, 0x23, 0xeb, 0xbe, 0xed, 0x29, 0xd9, 0x33, 0x31, 0x1b, 0x7e, 0x02, 0xad,
	0x71, 0x3a, 0xa7, 0x22, 0x67, 0x1c, 0x05, 0x27, 0x9c, 0x5d, 0xd2, 0x52, 0x89, 0xed, 0xb5, 0x14,
	0x30, 0x0e, 0xdd, 0xb7, 0xa0, 0x1d, 0x69, 0x41, 0x64, 0x2b, 0x3d, 0x60, 0xa0, 0x71, 0x38, 0xfc,
	0x8f, 0x05, 0x9d, 0x8f, 0x8b, 0x34, 0x3c, 0x63, 0x3c, 0x9f, 0x91, 0x19, 0x75, 0xf7, 0x61, 0x2b,
	0xe3, 0xd4, 0x8f, 0x52, 0xa9, 0xcb, 0xf2, 0x1a, 0x19, 0xa7, 0xe3, 0xd4, 0xbd, 0x05, 0x4d, 0x84,
	0x59, 0x91, 0x4b, 0x25, 0x96, 0x87, 0x52, 0xcf, 0x8a, 0xdc, 0x7d, 0x1b, 0x3a, 0xc8, 0x48, 0xf4,
	0xf9, 0xfe, 0x86, 0xe4, 0xb6, 0x33, 0x4e, 0x4b, 0x95, 0x87, 0x00, 0x41, 0xc1, 0x39, 0x4d, 0x73,
	0x54, 0xbb, 0x29, 0x05, 0x6c, 0x8d, 0x8c, 0x53, 0xb4, 0xd1, 0xb0, 0x51, 0x7d, 0x43, 0xf2, 0xcd,
	0x09, 0xbc, 0xe2, 0x36, 0xb4, 0x4a, 0xf5, 0x5b, 0x92, 0x5b, 0xd2, 0xee, 0x9b, 0x60, 0x93, 0x39,
	0x89, 0x62, 0x32, 0x89, 0x69, 0xbf, 0xa9, 0x54, 0x97, 0x80, 0x7b, 0x04, 0x6d, 0x2d, 0x29, 0xf9,
	0x2d, 0x65, 0x5b, 0x05, 0x1a, 0xfe, 0xa5, 0x0e, 0xed, 0xf3, 0x8c, 0x06, 0xcf, 0x39, 0x0b, 0x8b,
	0x20, 0x77, 0x0f, 0x60, 0x2b, 0x21, 0x7c, 0x56, 0x3e, 0x5f, 0x53, 0xee, 0x5d, 0xe8, 0x4e, 0x39,
	0xfb, 0x0d, 0x4d, 0x7d, 0xcd, 0x56, 0x5e, 0xe8, 0x28, 0xf0, 0x4c, 0x09, 0x0d, 0x00, 0x02, 0x96,
	0x24, 0x91, 0x10, 0x11, 0x4b, 0xb5, 0x27, 0x2a, 0x88, 0xfb, 0x23, 0xd8, 0xd1, 0x4a, 0x2a, 0x62,
	0xca, 0x1f, 0x8e, 0x62, 0x3c, 0x5d, 0x0a, 0xbf, 0x07, 0xdb, 0x19, 0x13, 0x51, 0x1e, 0xb1, 0xd4,
	0xcf, 0x38, 0x9b, 0x46, 0xc6, 0x35, 0x3d, 0x03, 0x3f, 0x97, 0x28, 0x46, 0x20, 0x88, 0x99, 0xa0,
	0x46, 0x4a, 0xb9, 0xa8, 0x2d, 0x31, 0x2d, 0xf2, 0x10, 0x0e, 0x56, 0x74, 0xf9, 0x93, 0x85, 0x4f,
	0xe2, 0x99, 0x76, 0xd9, 0xee, 0x75, 0x95, 0x27, 0x8b, 0x27, 0xf1, 0x0c, 0x0d, 0xa0, 0x5f, 0x06,
	0x17, 0x24, 0x9d, 0x51, 0xf3, 0x68, 0xe5, 0xc0, 0x9e, 0x81, 0xd5, 0xb3, 0x87, 0xff, 0x68, 0x43,
	0xf3, 0x49, 0x10, 0xb0, 0x22, 0xcd, 0xdd, 0x9f, 0x40, 0xcb, 0x64, 0x97, 0xf4, 0x60, 0xfb, 0x78,
	0xe7, 0x81, 0x4e, 0xfc, 0x07, 0x26, 0x65, 0xbd, 0x52, 0x04, 0x53, 0x03, 0xb3, 0x27, 0xe0, 0x34,
	0x8c, 0x4c, 0x66, 0xd9, 0x19, 0xa7, 0x4f, 0x25, 0x80, 0xa9, 0x81, 0xec, 0x90, 0x4a, 0xfb, 0x8c,
	0x47, 0x33, 0x4e, 0x4f, 0x15, 0x62, 0x04, 0x26, 0x24, 0x26, 0x69, 0x40, 0xb5, 0x2f, 0x51, 0xe0,
	0x44, 0x21, 0xe6, 0x02, 0x6d, 0x7f, 0xa3, 0xbc, 0xe0, 0xac, 0x0c, 0x6b, 0x94, 0xe6, 0x94, 0x53,
	0x91, 0xfb, 0x13, 0x22, 0x4c, 0x7e, 0x75, 0x0c, 0x78, 0x42, 0x04, 0xc5, 0xfc, 0x33, 0xb4, 0xf6,
	0x57, 0x49, 0xbb, 0x7d, 0x68, 0x1a, 0xeb, 0x94, 0x73, 0x0c, 0x89, 0xa7, 0x5e, 0x45, 0xf9, 0x45,
	0xc8, 0xc9, 0xab, 0xbe, 0xad, 0x4e, 0x19, 0xfa, 0x66, 0x36, 0xc1, 0x9a, 0x6c, 0x7a, 0x0b, 0xda,
	0x26, 0x5b, 0x88, 0xb8, 0xe8, 0xb7, 0xd5, 0xdb, 0x74, 0x9e, 0x10, 0x71, 0xb1, 0x3e, 0x9d, 0x3a,
	0xdf, 0x91, 0x4e, 0xf7, 0xa0, 0x67, 0xaa, 0x4c, 0xdf, 0xd9, 0x95, 0x92, 0x5d, 0x8d, 0xea, 0x4b,
	0x6f, 0x41, 0x13, 0x6f, 0xc3, 0x42, 0xed, 0xa9, 0x02, 0x40, 0x72, 0xbc, 0x9a, 0xdb, 0xdb, 0x37,
	0x72, 0x7b, 0x35, 0x0b, 0x9d, 0x9b, 0x59, 0xb8, 0x26, 0xa3, 0x77, 0xd6, 0x66, 0x74, 0x1f, 0x9a,
	0x26, 0xa2, 0xae, 0x72, 0xaa, 0x26, 0xaf, 0x97, 0xfb, 0xee, 0x6a, 0xb9, 0xdf, 0x83, 0x9e, 0x71,
	0xb1, 0xff, 0xb2, 0x60, 0x39, 0xe9, 0xef, 0xa9, 0x37, 0x1a, 0xf4, 0x97, 0x08, 0xa2, 0x7a, 0x4e,
	0x31, 0x29, 0x69, 0x7f, 0x5f, 0xa9, 0xd7, 0x24, 0xba, 0x3c, 0xe7, 0x24, 0x8c, 0xd2, 0x99, 0x1f,
	0x92, 0x45, 0xff, 0x40, 0xb5, 0x4b, 0x0d, 0x9d, 0x92, 0x05, 0x06, 0x4e, 0xd0, 0x3c, 0x8f, 0x69,
	0x22, 0xbb, 0x59, 0xd8, 0xbf, 0x25, 0xbb, 0x76, 0x67, 0x09, 0x8e, 0x43, 0xec, 0x21, 0x3a, 0xa1,
	0xfb, 0xda, 0x85, 0x2a, 0x9b, 0xd7, 0x14, 0xd4, 0x1b, 0xeb, 0x0a, 0x0a, 0x05, 0x43, 0x1a, 0x47,
	0x73, 0xca, 0x17, 0x46, 0xf0, 0xb6, 0x12, 0x34, 0xb0, 0x16, 0xfc, 0x10, 0xfa, 0xa5, 0xc6, 0xd5,
	0x13, 0x77, 0xe4, 0x89, 0x03, 0xc3, 0x3f, 0xbd, 0x7e, 0xf2, 0x3d, 0xd8, 0xd6, 0x8f, 0x2e, 0x8b,
	0xe7, 0x4d, 0x75, 0x85, 0x86, 0x4d, 0x01, 0x3d, 0x32, 0xdd, 0x39, 0x58, 0xe0, 0x7b, 0x0f, 0x8f,
	0xac, 0xfb, 0xbd, 0xe3, 0xdd, 0xb2, 0xa6, 0x9f, 0x6a, 0xde, 0xf8, 0xd4, 0xb4, 0xec, 0x60, 0x31,
	0x0e, 0xdd, 0x8f, 0xa0, 0x6b, 0x5a, 0xb4, 0x1f, 0xa5, 0x53, 0xd6, 0x1f, 0xc8, 0x5e, 0xb0, 0x5f,
	0x9e, 0xab, 0xce, 0x1c, 0xaf, 0x63, 0x64, 0xe5, 0x50, 0xfc, 0x39, 0xec, 0x88, 0x8c, 0x06, 0x98,
	0x22, 0xd8, 0x92, 0xd5, 0xf9, 0xb7, 0xe4, 0xf9, 0xbd, 0xf2, 0x7c, 0xa5, 0x67, 0x7b, 0xdb, 0x62,
	0x49, 0x48, 0x0d, 0x1f, 0x41, 0x77, 0x52, 0x88, 0x28, 0xa5, 0x42, 0xf8, 0xf9, 0x22, 0xa3, 0xfd,
	0x23, 0x69, 0xf5, 0xf2, 0xf6, 0x13, 0xcd, 0x7d, 0xb1, 0xc8, 0xa8, 0xd7, 0x99, 0x54, 0xa8, 0x4a,
	0xd5, 0x89, 0x57, 0x24, 0xeb, 0xbf, 0x5d, 0xad, 0xba, 0xf3, 0x57, 0x24, 0x43, 0x01, 0x4e, 0x13,
	0x12, 0x69, 0x81, 0xa1, 0x12, 0x50, 0x90, 0x14, 0xf8, 0x31, 0xb8, 0x22, 0x67, 0xc1, 0x25, 0x06,
	0xe2, 0x92, 0xe6, 0xfe, 0x9c, 0xc4, 0x05, 0xed, 0xdf, 0x55, 0x75, 0x29, 0x39, 0x67, 0x92, 0xf1,
	0x05, 0xe2, 0xee, 0x03, 0xd8, 0x65, 0x99, 0x2c, 0x89, 0x6b, 0xe2, 0xef, 0x48, 0xf1, 0x1d, 0xc5,
	0xaa, 0xca, 0xdf, 0x85, 0x6e, 0xb8, 0x48, 0x49, 0x12, 0x05, 0x7e, 0xc2, 0x52, 0xba, 0xe8, 0xdf,
	0x53, 0xad, 0x43, 0x83, 0x67, 0x88, 0x61, 0x86, 0x67, 0x9c, 0x26, 0x51, 0x91, 0xf4, 0xdf, 0x55,
	0x19, 0xae, 0x49, 0xbc, 0xae, 0x7a, 0x8f, 0x4f, 0x5f, 0x16, 0x51, 0xbe, 0xe8, 0xbf, 0xa7, 0xae,
	0x4b, 0x96, 0x17, 0xfd, 0x42, 0x32, 0x86, 0x7f, 0xdf, 0x80, 0xd6, 0x73, 0x5d, 0x9d, 0xff, 0x57,
	0x73, 0xd7, 0x31, 0x34, 0xbb, 0x87, 0xad, 0x91, 0x71, 0xa8, 0x7a, 0x2f, 0xae, 0x49, 0xa6, 0x96,
	0x36, 0xa4, 0x44, 0x67, 0x09, 0x8e, 0x43, 0xf7, 0x03, 0x80, 0x0b, 0x1a, 0xce, 0xa8, 0x3f, 0x8d,
	0xc9, 0x4c, 0xf6, 0xf7, 0xde, 0xb1, 0x5b, 0x5e, 0xfa, 0x09, 0xb2, 0x3e, 0x8e, 0xc9, 0xcc, 0xb3,
	0x2f, 0xcc, 0x4f, 0xf7, 0x7d, 0xb0, 0xc3, 0x88, 0xd3, 0x00, 0x4d, 0x96, 0x1d, 0xbf, 0x7a, 0xe2,
	0xd4, 0x70, 0xbc, 0xa5, 0x10, 0x16, 0xec, 0x9c, 0xc5, 0x45, 0xa2, 0xda, 0x7f, 0xc3, 0xd3, 0x54,
	0x65, 0x19, 0x68, 0x5e, 0x5b, 0x06, 0xde, 0x87, 0x7d, 0x32, 0x9f, 0xf9, 0x2c, 0xa3, 0xd8, 0xc8,
	0xa2, 0x80, 0xe2, 0x34, 0x9d, 0xb3, 0x58, 0x8f, 0x80, 0x1d, 0x32, 0x9f, 0x3d, 0xcb, 0x68, 0xfa,
	0x1c, 0x59, 0x27, 0x8b, 0x2f, 0x58, 0xec, 0xbe, 0x03, 0xbd, 0xeb, 0x27, 0xf4, 0x48, 0xe8, 0x54,
	0x45, 0xb1, 0x87, 0xe6, 0x2c, 0x24, 0x52, 0x17, 0x5a, 0x03, 0xd2, 0x9a, 0xb6, 0xc4, 0xbe, 0x50,
	0x26, 0x2d, 0x27, 0x87, 0x96, 0x69, 0xab, 0x06, 0xa4, 0x40, 0x2d, 0x74, 0x08, 0x40, 0xd3, 0x9c,
	0x2f, 0x54, 0xf2, 0xe3, 0x44, 0xe8, 0x7a, 0xb6, 0x44, 0x30, 0xc5, 0x87, 0x7f, 0xb0, 0xa1, 0xf1,
	0x82, 0x93, 0x90, 0xfe, 0xd0, 0x80, 0xde, 0x88, 0x58, 0x7d, 0x4d, 0xc4, 0xee, 0x80, 0xcd, 0x78,
	0x48, 0xb9, 0xcf, 0xe9, 0x54, 0x87, 0xb4, 0x25, 0x01, 0x8f, 0x4e, 0x71, 0xbc, 0x14, 0x42, 0xad,
	0xaa, 0x9b, 0x92, 0xb5, 0x85, 0xa4, 0x5a, 0x54, 0xcb, 0x4e, 0x16, 0x85, 0x32, 0x6c, 0xb6, 0x07,
	0x06, 0x1a, 0x87, 0xb8, 0x2a, 0x63, 0x1f, 0x96, 0xdc, 0x2d, 0xc9, 0x6d, 0x4a, 0x7a, 0x1c, 0x5e,
	0x0f, 0x78, 0xf3, 0xfb, 0x04, 0xfc, 0x08, 0x3a, 0xca, 0x46, 0xb1, 0x10, 0xa8, 0xb0, 0xa5, 0xae,
	0x93, 0xd8, 0xf9, 0x42, 0x8c, 0x43, 0x1c, 0x25, 0x19, 0xe1, 0x79, 0x14, 0x44, 0x19, 0x51, 0x6f,
	0xb5, 0xa5, 0x4c, 0xb7, 0x82, 0xaa, 0xc7, 0x06, 0x71, 0xa4, 0xbd, 0x01, 0xea, 0xb1, 0x0a, 0x18,
	0x87, 0xee, 0x63, 0xe8, 0x98, 0x69, 0xc2, 0x59, 0xac, 0x42, 0xd5, 0xab, 0xf4, 0xb0, 0x17, 0x8a,
	0xe9, 0xb1, 0x98, 0x7a, 0x66, 0xee, 0x20, 0xe1, 0x3e, 0x82, 0x83, 0xa5, 0x33, 0xae, 0x39, 0xbc,
	0x23, 0xaf, 0xd8, 0x2b, 0xfd, 0x52, 0x75, 0xfc, 0x23, 0x68, 0xb3, 0xe9, 0x54, 0xd0, 0x5c, 0xd5,
	0x4a, 0x77, 0xa5, 0x53, 0x3f, 0x93, 0x3c, 0x59, 0x2c, 0xc0, 0xca, 0xdf, 0x2b, 0x05, 0xd6, 0xfb,
	0x3e, 0x05, 0xb6, 0x07, 0x0d, 0x95, 0xc3, 0xdb, 0xe6, 0x0b, 0x01, 0x93, 0x77, 0x59, 0x44, 0xce,
	0xb5, 0x22, 0x3a, 0x04, 0x50, 0x81, 0x0b, 0x49, 0x4e, 0xe5, 0xc0, 0xb7, 0x3d, 0x5b, 0x22, 0xa7,
	0x24, 0xaf, 0xb0, 0xf3, 0x28, 0x51, 0xe3, 0xde, 0xb0, 0x5f, 0x44, 0x09, 0x45, 0xf3, 0x34, 0x1b,
	0x53, 0x79, 0x77, 0xc5, 0x3c, 0x99, 0xc5, 0xb2, 0x89, 0xeb, 0x23, 0xd8, 0xc1, 0x1f, 0xe3, 0x17,
	0x09, 0x16, 0xa5, 0x60, 0x05, 0x0f, 0xa8, 0xdc, 0x01, 0xaa, 0x6e, 0x97, 0xb5, 0x76, 0x2e, 0x79,
	0xf8, 0x9d, 0x52, 0x12, 0x18, 0x4c, 0xa9, 0x45, 0xa6, 0xe7, 0xbe, 0x0a, 0xa6, 0x02, 0xc6, 0x21,
	0x56, 0xb0, 0x4a, 0x99, 0x98, 0x05, 0x24, 0x46, 0x09, 0xb5, 0x1d, 0xa8, 0x44, 0xfa, 0x14, 0xc1,
	0x71, 0xe8, 0xde, 0x07, 0x27, 0x88, 0x29, 0xe1, 0x18, 0x73, 0xcc, 0x14, 0xb3, 0x22, 0xd8, 0x5e,
	0xcf, 0xe0, 0xcf, 0x09, 0xd7, 0xdd, 0xaf, 0x9c, 0x51, 0x45, 0xaa, 0x77, 0x05, 0x7b, 0x39, 0x8c,
	0x3e, 0x4f, 0xd5, 0x7a, 0x2b, 0xe8, 0xcb, 0x82, 0xa6, 0x01, 0xf5, 0x53, 0x26, 0xb7, 0x85, 0x86,
	0x07, 0x06, 0xfa, 0x8c, 0xad, 0x2e, 0x2c, 0xb7, 0xff, 0xf7, 0xc2, 0x72, 0x67, 0xcd, 0xc2, 0xf2,
	0x3e, 0xec, 0xe9, 0x4f, 0x48, 0x5d, 0x15, 0xf4, 0x25, 0x35, 0x1b, 0x41, 0xc3, 0x73, 0x15, 0xef,
	0x99, 0x2c, 0x0e, 0xc5, 0x31, 0xa9, 0x5d, 0xfa, 0xf8, 0x70, 0x4d, 0x6a, 0x97, 0x3e, 0xce, 0x97,
	0x04, 0x3a, 0xa8, 0xfc, 0x20, 0xc5, 0x67, 0xa3, 0x49, 0x03, 0xe5, 0x20, 0x83, 0xe3, 0xcb, 0xc7,
	0xe1, 0xf0, 0x4f, 0x16, 0x34, 0xcf, 0x8b, 0x89, 0x1c, 0xe8, 0x3f, 0xb0, 0x4f, 0x3d, 0x86, 0x0e,
	0x51, 0xdf, 0x23, 0x2a, 0x6d, 0xea, 0x2b, 0xd6, 0xe9, 0x8f, 0x15, 0x99, 0x38, 0x6d, 0xb2, 0x24,
	0xdc, 0x0f, 0xa1, 0x2b, 0x8a, 0x89, 0xdc, 0x38, 0xd4, 0xc9, 0x8d, 0x95, 0x93, 0xda, 0x20, 0x75,
	0x52, 0x2c, 0x89, 0xe1, 0xaf, 0xa1, 0xe5, 0x45, 0xe2, 0xf2, 0x73, 0x41, 0x79, 0xb5, 0xc9, 0x59,
	0xd7, 0x9a, 0xdc, 0x6d, 0x68, 0x65, 0x44, 0x88, 0x57, 0x8c, 0x9b, 0xd6, 0x59, 0xd2, 0xd8, 0xdf,
	0x12, 0x12, 0xf8, 0x24, 0x0c, 0xb9, 0xee, 0x9a, 0xcd, 0x84, 0x04, 0x4f, 0xc2, 0x90, 0x0f, 0xff,
	0x66, 0x41, 0xc7, 0x13, 0x19, 0xea, 0xfe, 0x94, 0xe9, 0x25, 0x7d, 0xfd, 0x05, 0x2b, 0xe9, 0x50,
	0xbf, 0x91, 0x0e, 0x87, 0x00, 0x31, 0xaa, 0x50, 0xd5, 0xa6, 0xee, 0xb1, 0x25, 0x22, 0xab, 0xed,
	0x67, 0xd0, 0xcb, 0x78, 0x34, 0x8f, 0x62, 0x3a, 0xd3, 0x15, 0xa7, 0x26, 0xee, 0x41, 0xb5, 0x78,
	0x14, 0x5b, 0xba, 0xa0, 0x9b, 0x55, 0x49, 0xd9, 0x34, 0xcb, 0xe3, 0x72, 0x6d, 0x6b, 0xe8, 0xa6,
	0x69, 0x50, 0xf4, 0xd7, 0xf0, 0x3e, 0x74, 0x97, 0xcf, 0x61, 0x45, 0xfe, 0x9d, 0xef, 0x19, 0x0d,
	0x00, 0x96, 0x0b, 0xa6, 0xdb, 0x84, 0x8d, 0xa7, 0x9f, 0xfd, 0xca, 0xa9, 0xe1, 0x8f, 0xcf, 0xcf,
	0x4f, 0x1d, 0x6b, 0x74, 0x0f, 0x3a, 0xd5, 0x55, 0xce, 0x05, 0xd8, 0x9a, 0x16, 0x79, 0xc1, 0xa9,
	0x53, 0x73, 0x6d, 0x68, 0xc8, 0x65, 0xcb, 0xb1, 0x46, 0x9f, 0x80, 0x5d, 0x36, 0x32, 0x77, 0x1b,
	0xda, 0xb8, 0x2f, 0x16, 0x31, 0xc1, 0x51, 0xe0, 0xd4, 0xdc, 0x2e, 0xd8, 0x84, 0x4f, 0xa2, 0x9c,
	0x93, 0x19, 0x75, 0x2c, 0x3c, 0x27, 0x5b, 0x9d, 0x53, 0x77, 0x1d, 0xe8, 0xe8, 0x65, 0x29, 0x21,
	0x97, 0x94, 0x3b, 0x1b, 0xa3, 0xc7, 0x60, 0x97, 0x03, 0x05, 0xcd, 0x98, 0x14, 0x0b, 0xa7, 0xe6,
	0xb6, 0x60, 0x33, 0x66, 0xe9, 0x4c, 0xfd, 0x12, 0x34, 0x8e, 0x95, 0x1a, 0x71, 0xc1, 0x78, 0xee,
	0x58, 0xb7, 0xeb, 0x8e, 0x35, 0xfa, 0xe7, 0x06, 0xf4, 0x64, 0x05, 0xc9, 0xee, 0x23, 0x8d, 0xc5,
	0x7b, 0xd3, 0x85, 0x5a, 0x07, 0x9c, 0x1a, 0xda, 0x15, 0x47, 0x49, 0x94, 0x6b, 0xc0, 0x72, 0x7b,
	0x00, 0x13, 0xfc, 0x2e, 0x55, 0x74, 0x1d, 0xe9, 0x98, 0x94, 0xf4, 0x86, 0xbb, 0x07, 0xce, 0x92,
	0xf6, 0xb3, 0xb8, 0x10, 0x1f, 0x38, 0x9b, 0x6b, 0xd0, 0x63, 0xa7, 0xb1, 0x06, 0x7d, 0xe8, 0x6c,
	0x49, 0x0b, 0xc4, 0xa5, 0x56, 0xd8, 0x74, 0x77, 0x61, 0xbb, 0x24, 0xb5, 0xbe, 0xd6, 0x4d, 0xf0,
	0xd8, 0xb1, 0x6f, 0x82, 0x0f, 0x1d, 0x40, 0x6d, 0x93, 0x28, 0xd4, 0xda, 0xda, 0x28, 0x53, 0x92,
	0x5a, 0x5b, 0xe7, 0x26, 0x78, 0xec, 0x74, 0x6f, 0x82, 0x0f, 0x9d, 0x1e, 0x5a, 0x3c, 0x8d, 0xe6,
	0xd4, 0x8f, 0xe9, 0x9c, 0xc6, 0x5a, 0xe9, 0x36, 0xa2, 0x22, 0x67, 0x99, 0x1f, 0x33, 0x21, 0xf4,
	0xc2, 0xec, 0x38, 0xa8, 0x60, 0x89, 0x4a, 0x27, 0x3a, 0x3b, 0x68, 0xce, 0x2c, 0x0f, 0x34, 0xe9,
	0xa2, 0xf7, 0xd4, 0x56, 0x1e, 0xd3, 0x34, 0x74, 0x76, 0xdd, 0x5b, 0xb0, 0xab, 0xe8, 0x69, 0x94,
	0x92, 0x34, 0xc0, 0x92, 0xc1, 0x60, 0xee, 0x61, 0x1c, 0x38, 0xcd, 0xc8, 0xc2, 0x57, 0xd9, 0xb3,
	0x8f, 0x59, 0x40, 0xf3, 0xa9, 0x9f, 0x15, 0x3c, 0xb8, 0x20, 0x82, 0x3a, 0x07, 0xae, 0x0b, 0x3d,
	0x44, 0x38, 0x0d, 0x69, 0x22, 0x17, 0x74, 0xe7, 0xd6, 0xe8, 0x01, 0xb4, 0x2b, 0xf3, 0x1c, 0x33,
	0x51, 0xb5, 0x4d, 0x95, 0x14, 0x17, 0x4c, 0xe4, 0x2a, 0x29, 0x54, 0x26, 0xd5, 0x47, 0xbf, 0x05,
	0x58, 0x4e, 0x64, 0x14, 0xc1, 0xdd, 0x50, 0xa5, 0xad, 0xfc, 0x66, 0x76, 0x2c, 0xb4, 0x64, 0xca,
	0x78, 0x40, 0x7d, 0x05, 0xd4, 0x11, 0x50, 0xdf, 0xd8, 0x72, 0x23, 0x74, 0x36, 0xf0, 0xe1, 0x0a,
	0x58, 0x50, 0x91, 0x53, 0x8e, 0xe0, 0x26, 0x3e, 0x5c, 0x1d, 0x63, 0xd3, 0xa9, 0xd3, 0x40, 0x19,
	0x35, 0xb2, 0x96, 0xe0, 0xd6, 0xe8, 0xcf, 0x16, 0xd8, 0xe5, 0xf0, 0x74, 0xf7, 0xf1, 0x8b, 0x2b,
	0x8e, 0x72, 0x3f, 0x60, 0xc9, 0x24, 0x4a, 0x4d, 0x61, 0x00, 0x6c, 0xe1, 0x07, 0x3e, 0x4b, 0x1d,
	0x0b, 0x45, 0xd4, 0xb7, 0x88, 0xf0, 0xe9, 0x97, 0x34, 0x28, 0xa4, 0x48, 0x1d, 0x4b, 0x80, 0xe5,
	0x81, 0xb3, 0x81, 0xa6, 0xd1, 0x69, 0xe6, 0x87, 0x94, 0x47, 0x73, 0x1a, 0x3a, 0x9b, 0xe8, 0xdf,
	0x8a, 0xb6, 0x92, 0xd1, 0x40, 0x77, 0xa2, 0xcb, 0x4b, 0x8f, 0x6f, 0x61, 0x50, 0x2b, 0x1e, 0xf7,
	0x49, 0x91, 0x33, 0xa7, 0xe9, 0x1e, 0x80, 0x5b, 0x45, 0x13, 0x92, 0x16, 0x24, 0x76, 0x5a, 0xa3,
	0x9f, 0x42, 0xbb, 0x32, 0xc1, 0xdd, 0x1d, 0xe8, 0x66, 0xc2, 0xaf, 0x14, 0x86, 0xb4, 0x3b, 0x13,
	0x52, 0xb7, 0xe5, 0xb6, 0xa1, 0x99, 0x09, 0x5f, 0xd6, 0x64, 0x7d, 0x34, 0x52, 0x31, 0x32, 0x47,
	0xbb, 0x60, 0xe7, 0xc2, 0x4f, 0x19, 0x4f, 0x48, 0xec, 0xd4, 0xdc, 0x0e, 0xb4, 0x72, 0xe1, 0xbf,
	0x2c, 0x28, 0x5f, 0x38, 0xd6, 0xe8, 0x11, 0xb4, 0x2b, 0x63, 0x02, 0xf5, 0xcc, 0x23, 0x9e, 0x17,
	0x52, 0xb2, 0x05, 0x9b, 0x9c, 0x92, 0x58, 0xd5, 0x28, 0xfe, 0xf2, 0x67, 0x9c, 0x15, 0x99, 0x53,
	0x1f, 0xdd, 0x85, 0x76, 0x65, 0x44, 0x60, 0x30, 0xe5, 0x44, 0x55, 0x71, 0x95, 0x73, 0xd0, 0xb1,
	0x46, 0xef, 0x42, 0xf7, 0x5a, 0x1b, 0x45, 0x1e, 0x09, 0x93, 0x48, 0xfb, 0x5c, 0x1b, 0x64, 0x9d,
	0x3c, 0xfa, 0xea, 0x9b, 0x41, 0xed, 0xeb, 0x6f, 0x06, 0xb5, 0x6f, 0xbf, 0x19, 0x58, 0xbf, 0xbb,
	0x1a, 0x58, 0x7f, 0xbc, 0x1a, 0x58, 0x7f, 0xbd, 0x1a, 0x58, 0x5f, 0x5d, 0x0d, 0xac, 0x7f, 0x5d,
	0x0d, 0xac, 0x7f, 0x5f, 0x0d, 0x6a, 0xdf, 0x5e, 0x0d, 0xac, 0xdf, 0xbf, 0x1e, 0xd4, 0xbe, 0x7a,
	0x3d, 0xa8, 0x7d, 0xfd, 0x7a, 0x50, 0x9b, 0x6c, 0xc9, 0xbf, 0x9b, 0x1f, 0xfe, 0x37, 0x00, 0x00,
	0xff, 0xff, 0xa8, 0xab, 0xfc, 0x81, 0x82, 0x16, 0x00, 0x00,
}

func (x CurrencyID) String() string {
	s, ok := CurrencyID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BusinessType) String() string {
	s, ok := BusinessType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HedgeFlag) String() string {
	s, ok := HedgeFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Direction) String() string {
	s, ok := Direction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OrderPriceType) String() string {
	s, ok := OrderPriceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradingRole) String() string {
	s, ok := TradingRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OffsetFlag) String() string {
	s, ok := OffsetFlag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradeType) String() string {
	s, ok := TradeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PriceSource) String() string {
	s, ok := PriceSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TradeSource) String() string {
	s, ok := TradeSource_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AccountType) String() string {
	s, ok := AccountType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SubInfoType) String() string {
	s, ok := SubInfoType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PrivilegeType) String() string {
	s, ok := PrivilegeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *RspInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspInfo)
	if !ok {
		that2, ok := that.(RspInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ErrorId != that1.ErrorId {
		return false
	}
	if this.ErrorMsg != that1.ErrorMsg {
		return false
	}
	return true
}
func (this *Investor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Investor)
	if !ok {
		that2, ok := that.(Investor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BrokerId != that1.BrokerId {
		return false
	}
	if this.InvestorId != that1.InvestorId {
		return false
	}
	return true
}
func (this *FundMortgage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FundMortgage)
	if !ok {
		that2, ok := that.(FundMortgage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PreIn != that1.PreIn {
		return false
	}
	if this.PreOut != that1.PreOut {
		return false
	}
	if this.PreMortgage != that1.PreMortgage {
		return false
	}
	if this.CurrentIn != that1.CurrentIn {
		return false
	}
	if this.CurrentOut != that1.CurrentOut {
		return false
	}
	if this.Mortgage != that1.Mortgage {
		return false
	}
	if this.Available != that1.Available {
		return false
	}
	if this.Mortgagable != that1.Mortgagable {
		return false
	}
	return true
}
func (this *SpecProduct) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecProduct)
	if !ok {
		that2, ok := that.(SpecProduct)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Margin != that1.Margin {
		return false
	}
	if this.FrozenMargin != that1.FrozenMargin {
		return false
	}
	if this.Commission != that1.Commission {
		return false
	}
	if this.FrozenCommission != that1.FrozenCommission {
		return false
	}
	if this.PositionProfit != that1.PositionProfit {
		return false
	}
	if this.CloseProfit != that1.CloseProfit {
		return false
	}
	if this.PositionProfitByAlg != that1.PositionProfitByAlg {
		return false
	}
	if this.ExchangeMargin != that1.ExchangeMargin {
		return false
	}
	return true
}
func (this *Account) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Account)
	if !ok {
		that2, ok := that.(Account)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.PreCredit != that1.PreCredit {
		return false
	}
	if this.PreDeposit != that1.PreDeposit {
		return false
	}
	if this.PreBalance != that1.PreBalance {
		return false
	}
	if this.PreMargin != that1.PreMargin {
		return false
	}
	if this.InterestBase != that1.InterestBase {
		return false
	}
	if this.Interest != that1.Interest {
		return false
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	if this.Withdraw != that1.Withdraw {
		return false
	}
	if this.FrozenMargin != that1.FrozenMargin {
		return false
	}
	if this.FrozenCash != that1.FrozenCash {
		return false
	}
	if this.FrozenCommission != that1.FrozenCommission {
		return false
	}
	if this.CurrentMargin != that1.CurrentMargin {
		return false
	}
	if this.CashIn != that1.CashIn {
		return false
	}
	if this.Commission != that1.Commission {
		return false
	}
	if this.CloseProfit != that1.CloseProfit {
		return false
	}
	if this.PositionProfit != that1.PositionProfit {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if this.Available != that1.Available {
		return false
	}
	if this.WithdrawQuota != that1.WithdrawQuota {
		return false
	}
	if this.Reserve != that1.Reserve {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.SettlementId != that1.SettlementId {
		return false
	}
	if this.Credit != that1.Credit {
		return false
	}
	if this.ExchangeMargin != that1.ExchangeMargin {
		return false
	}
	if this.DeliveryMargin != that1.DeliveryMargin {
		return false
	}
	if this.ExchangeDeliveryMargin != that1.ExchangeDeliveryMargin {
		return false
	}
	if this.ReserveBalance != that1.ReserveBalance {
		return false
	}
	if this.CurrencyId != that1.CurrencyId {
		return false
	}
	if !this.MortgageInfo.Equal(that1.MortgageInfo) {
		return false
	}
	if !this.SpecProductInfo.Equal(that1.SpecProductInfo) {
		return false
	}
	if this.BusinessType != that1.BusinessType {
		return false
	}
	if this.FrozenSwap != that1.FrozenSwap {
		return false
	}
	if this.RemainSwap != that1.RemainSwap {
		return false
	}
	if this.StockMarketValue != that1.StockMarketValue {
		return false
	}
	if this.OptionMarketValue != that1.OptionMarketValue {
		return false
	}
	if this.DynamicMoney != that1.DynamicMoney {
		return false
	}
	if this.Premium != that1.Premium {
		return false
	}
	if this.MarketValueEquity != that1.MarketValueEquity {
		return false
	}
	return true
}
func (this *Position) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Position)
	if !ok {
		that2, ok := that.(Position)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.ProductId != that1.ProductId {
		return false
	}
	if this.InstrumentId != that1.InstrumentId {
		return false
	}
	if this.HedgeFlag != that1.HedgeFlag {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Margin != that1.Margin {
		return false
	}
	if this.AvgOpenPriceByVol != that1.AvgOpenPriceByVol {
		return false
	}
	if this.AvgOpenPrice != that1.AvgOpenPrice {
		return false
	}
	if this.TodayVolume != that1.TodayVolume {
		return false
	}
	if this.FrozenVolume != that1.FrozenVolume {
		return false
	}
	if this.EntryType != that1.EntryType {
		return false
	}
	return true
}
func (this *Trade) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Trade)
	if !ok {
		that2, ok := that.(Trade)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.InstrumentId != that1.InstrumentId {
		return false
	}
	if this.OrderRef != that1.OrderRef {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.ExchangeId != that1.ExchangeId {
		return false
	}
	if this.TradeId != that1.TradeId {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.OrderSysId != that1.OrderSysId {
		return false
	}
	if this.ParticipantId != that1.ParticipantId {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if this.TradingRole != that1.TradingRole {
		return false
	}
	if this.ExchangeInstrumentId != that1.ExchangeInstrumentId {
		return false
	}
	if this.OffsetFlag != that1.OffsetFlag {
		return false
	}
	if this.HedgeFlag != that1.HedgeFlag {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.TradeDate != that1.TradeDate {
		return false
	}
	if this.TradeTime != that1.TradeTime {
		return false
	}
	if this.TradeType != that1.TradeType {
		return false
	}
	if this.PriceSource != that1.PriceSource {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.OrderLocalId != that1.OrderLocalId {
		return false
	}
	if this.ClearingPartId != that1.ClearingPartId {
		return false
	}
	if this.BusinessUnit != that1.BusinessUnit {
		return false
	}
	if this.SequenceNo != that1.SequenceNo {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.SettlementId != that1.SettlementId {
		return false
	}
	if this.BrokerOrderSeqence != that1.BrokerOrderSeqence {
		return false
	}
	if this.TradeSource != that1.TradeSource {
		return false
	}
	if this.InvestorUnitId != that1.InvestorUnitId {
		return false
	}
	return true
}
func (this *SubInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubInfo)
	if !ok {
		that2, ok := that.(SubInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Investor.Equal(that1.Investor) {
		return false
	}
	if this.AccountType != that1.AccountType {
		return false
	}
	if this.SubInfoType != that1.SubInfoType {
		return false
	}
	return true
}
func (this *RiskUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RiskUser)
	if !ok {
		that2, ok := that.(RiskUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.MacAddr != that1.MacAddr {
		return false
	}
	return true
}
func (this *RspUserLogin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspUserLogin)
	if !ok {
		that2, ok := that.(RspUserLogin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.TradingDay != that1.TradingDay {
		return false
	}
	if this.LoginTime != that1.LoginTime {
		return false
	}
	if this.PrivilegeType != that1.PrivilegeType {
		return false
	}
	if this.PrivilegeInfo != that1.PrivilegeInfo {
		return false
	}
	return true
}
func (this *RspUserLogout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RspUserLogout)
	if !ok {
		that2, ok := that.(RspUserLogout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	return true
}
func (this *RspInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service.RspInfo{")
	s = append(s, "ErrorId: "+fmt.Sprintf("%#v", this.ErrorId)+",\n")
	s = append(s, "ErrorMsg: "+fmt.Sprintf("%#v", this.ErrorMsg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Investor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service.Investor{")
	s = append(s, "BrokerId: "+fmt.Sprintf("%#v", this.BrokerId)+",\n")
	s = append(s, "InvestorId: "+fmt.Sprintf("%#v", this.InvestorId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FundMortgage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&service.FundMortgage{")
	s = append(s, "PreIn: "+fmt.Sprintf("%#v", this.PreIn)+",\n")
	s = append(s, "PreOut: "+fmt.Sprintf("%#v", this.PreOut)+",\n")
	s = append(s, "PreMortgage: "+fmt.Sprintf("%#v", this.PreMortgage)+",\n")
	s = append(s, "CurrentIn: "+fmt.Sprintf("%#v", this.CurrentIn)+",\n")
	s = append(s, "CurrentOut: "+fmt.Sprintf("%#v", this.CurrentOut)+",\n")
	s = append(s, "Mortgage: "+fmt.Sprintf("%#v", this.Mortgage)+",\n")
	s = append(s, "Available: "+fmt.Sprintf("%#v", this.Available)+",\n")
	s = append(s, "Mortgagable: "+fmt.Sprintf("%#v", this.Mortgagable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpecProduct) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&service.SpecProduct{")
	s = append(s, "Margin: "+fmt.Sprintf("%#v", this.Margin)+",\n")
	s = append(s, "FrozenMargin: "+fmt.Sprintf("%#v", this.FrozenMargin)+",\n")
	s = append(s, "Commission: "+fmt.Sprintf("%#v", this.Commission)+",\n")
	s = append(s, "FrozenCommission: "+fmt.Sprintf("%#v", this.FrozenCommission)+",\n")
	s = append(s, "PositionProfit: "+fmt.Sprintf("%#v", this.PositionProfit)+",\n")
	s = append(s, "CloseProfit: "+fmt.Sprintf("%#v", this.CloseProfit)+",\n")
	s = append(s, "PositionProfitByAlg: "+fmt.Sprintf("%#v", this.PositionProfitByAlg)+",\n")
	s = append(s, "ExchangeMargin: "+fmt.Sprintf("%#v", this.ExchangeMargin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Account) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 43)
	s = append(s, "&service.Account{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "PreCredit: "+fmt.Sprintf("%#v", this.PreCredit)+",\n")
	s = append(s, "PreDeposit: "+fmt.Sprintf("%#v", this.PreDeposit)+",\n")
	s = append(s, "PreBalance: "+fmt.Sprintf("%#v", this.PreBalance)+",\n")
	s = append(s, "PreMargin: "+fmt.Sprintf("%#v", this.PreMargin)+",\n")
	s = append(s, "InterestBase: "+fmt.Sprintf("%#v", this.InterestBase)+",\n")
	s = append(s, "Interest: "+fmt.Sprintf("%#v", this.Interest)+",\n")
	s = append(s, "Deposit: "+fmt.Sprintf("%#v", this.Deposit)+",\n")
	s = append(s, "Withdraw: "+fmt.Sprintf("%#v", this.Withdraw)+",\n")
	s = append(s, "FrozenMargin: "+fmt.Sprintf("%#v", this.FrozenMargin)+",\n")
	s = append(s, "FrozenCash: "+fmt.Sprintf("%#v", this.FrozenCash)+",\n")
	s = append(s, "FrozenCommission: "+fmt.Sprintf("%#v", this.FrozenCommission)+",\n")
	s = append(s, "CurrentMargin: "+fmt.Sprintf("%#v", this.CurrentMargin)+",\n")
	s = append(s, "CashIn: "+fmt.Sprintf("%#v", this.CashIn)+",\n")
	s = append(s, "Commission: "+fmt.Sprintf("%#v", this.Commission)+",\n")
	s = append(s, "CloseProfit: "+fmt.Sprintf("%#v", this.CloseProfit)+",\n")
	s = append(s, "PositionProfit: "+fmt.Sprintf("%#v", this.PositionProfit)+",\n")
	s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	s = append(s, "Available: "+fmt.Sprintf("%#v", this.Available)+",\n")
	s = append(s, "WithdrawQuota: "+fmt.Sprintf("%#v", this.WithdrawQuota)+",\n")
	s = append(s, "Reserve: "+fmt.Sprintf("%#v", this.Reserve)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "SettlementId: "+fmt.Sprintf("%#v", this.SettlementId)+",\n")
	s = append(s, "Credit: "+fmt.Sprintf("%#v", this.Credit)+",\n")
	s = append(s, "ExchangeMargin: "+fmt.Sprintf("%#v", this.ExchangeMargin)+",\n")
	s = append(s, "DeliveryMargin: "+fmt.Sprintf("%#v", this.DeliveryMargin)+",\n")
	s = append(s, "ExchangeDeliveryMargin: "+fmt.Sprintf("%#v", this.ExchangeDeliveryMargin)+",\n")
	s = append(s, "ReserveBalance: "+fmt.Sprintf("%#v", this.ReserveBalance)+",\n")
	s = append(s, "CurrencyId: "+fmt.Sprintf("%#v", this.CurrencyId)+",\n")
	if this.MortgageInfo != nil {
		s = append(s, "MortgageInfo: "+fmt.Sprintf("%#v", this.MortgageInfo)+",\n")
	}
	if this.SpecProductInfo != nil {
		s = append(s, "SpecProductInfo: "+fmt.Sprintf("%#v", this.SpecProductInfo)+",\n")
	}
	s = append(s, "BusinessType: "+fmt.Sprintf("%#v", this.BusinessType)+",\n")
	s = append(s, "FrozenSwap: "+fmt.Sprintf("%#v", this.FrozenSwap)+",\n")
	s = append(s, "RemainSwap: "+fmt.Sprintf("%#v", this.RemainSwap)+",\n")
	s = append(s, "StockMarketValue: "+fmt.Sprintf("%#v", this.StockMarketValue)+",\n")
	s = append(s, "OptionMarketValue: "+fmt.Sprintf("%#v", this.OptionMarketValue)+",\n")
	s = append(s, "DynamicMoney: "+fmt.Sprintf("%#v", this.DynamicMoney)+",\n")
	s = append(s, "Premium: "+fmt.Sprintf("%#v", this.Premium)+",\n")
	s = append(s, "MarketValueEquity: "+fmt.Sprintf("%#v", this.MarketValueEquity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Position) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&service.Position{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "ProductId: "+fmt.Sprintf("%#v", this.ProductId)+",\n")
	s = append(s, "InstrumentId: "+fmt.Sprintf("%#v", this.InstrumentId)+",\n")
	s = append(s, "HedgeFlag: "+fmt.Sprintf("%#v", this.HedgeFlag)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Margin: "+fmt.Sprintf("%#v", this.Margin)+",\n")
	s = append(s, "AvgOpenPriceByVol: "+fmt.Sprintf("%#v", this.AvgOpenPriceByVol)+",\n")
	s = append(s, "AvgOpenPrice: "+fmt.Sprintf("%#v", this.AvgOpenPrice)+",\n")
	s = append(s, "TodayVolume: "+fmt.Sprintf("%#v", this.TodayVolume)+",\n")
	s = append(s, "FrozenVolume: "+fmt.Sprintf("%#v", this.FrozenVolume)+",\n")
	s = append(s, "EntryType: "+fmt.Sprintf("%#v", this.EntryType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Trade) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 34)
	s = append(s, "&service.Trade{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "InstrumentId: "+fmt.Sprintf("%#v", this.InstrumentId)+",\n")
	s = append(s, "OrderRef: "+fmt.Sprintf("%#v", this.OrderRef)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ExchangeId: "+fmt.Sprintf("%#v", this.ExchangeId)+",\n")
	s = append(s, "TradeId: "+fmt.Sprintf("%#v", this.TradeId)+",\n")
	s = append(s, "Direction: "+fmt.Sprintf("%#v", this.Direction)+",\n")
	s = append(s, "OrderSysId: "+fmt.Sprintf("%#v", this.OrderSysId)+",\n")
	s = append(s, "ParticipantId: "+fmt.Sprintf("%#v", this.ParticipantId)+",\n")
	s = append(s, "ClientId: "+fmt.Sprintf("%#v", this.ClientId)+",\n")
	s = append(s, "TradingRole: "+fmt.Sprintf("%#v", this.TradingRole)+",\n")
	s = append(s, "ExchangeInstrumentId: "+fmt.Sprintf("%#v", this.ExchangeInstrumentId)+",\n")
	s = append(s, "OffsetFlag: "+fmt.Sprintf("%#v", this.OffsetFlag)+",\n")
	s = append(s, "HedgeFlag: "+fmt.Sprintf("%#v", this.HedgeFlag)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "TradeDate: "+fmt.Sprintf("%#v", this.TradeDate)+",\n")
	s = append(s, "TradeTime: "+fmt.Sprintf("%#v", this.TradeTime)+",\n")
	s = append(s, "TradeType: "+fmt.Sprintf("%#v", this.TradeType)+",\n")
	s = append(s, "PriceSource: "+fmt.Sprintf("%#v", this.PriceSource)+",\n")
	s = append(s, "TraderId: "+fmt.Sprintf("%#v", this.TraderId)+",\n")
	s = append(s, "OrderLocalId: "+fmt.Sprintf("%#v", this.OrderLocalId)+",\n")
	s = append(s, "ClearingPartId: "+fmt.Sprintf("%#v", this.ClearingPartId)+",\n")
	s = append(s, "BusinessUnit: "+fmt.Sprintf("%#v", this.BusinessUnit)+",\n")
	s = append(s, "SequenceNo: "+fmt.Sprintf("%#v", this.SequenceNo)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "SettlementId: "+fmt.Sprintf("%#v", this.SettlementId)+",\n")
	s = append(s, "BrokerOrderSeqence: "+fmt.Sprintf("%#v", this.BrokerOrderSeqence)+",\n")
	s = append(s, "TradeSource: "+fmt.Sprintf("%#v", this.TradeSource)+",\n")
	s = append(s, "InvestorUnitId: "+fmt.Sprintf("%#v", this.InvestorUnitId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&service.SubInfo{")
	if this.Investor != nil {
		s = append(s, "Investor: "+fmt.Sprintf("%#v", this.Investor)+",\n")
	}
	s = append(s, "AccountType: "+fmt.Sprintf("%#v", this.AccountType)+",\n")
	s = append(s, "SubInfoType: "+fmt.Sprintf("%#v", this.SubInfoType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RiskUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&service.RiskUser{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "MacAddr: "+fmt.Sprintf("%#v", this.MacAddr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RspUserLogin) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&service.RspUserLogin{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "TradingDay: "+fmt.Sprintf("%#v", this.TradingDay)+",\n")
	s = append(s, "LoginTime: "+fmt.Sprintf("%#v", this.LoginTime)+",\n")
	s = append(s, "PrivilegeType: "+fmt.Sprintf("%#v", this.PrivilegeType)+",\n")
	s = append(s, "PrivilegeInfo: "+fmt.Sprintf("%#v", this.PrivilegeInfo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RspUserLogout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service.RspUserLogout{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStructures(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RspInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.ErrorId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Investor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Investor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Investor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvestorId) > 0 {
		i -= len(m.InvestorId)
		copy(dAtA[i:], m.InvestorId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InvestorId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BrokerId) > 0 {
		i -= len(m.BrokerId)
		copy(dAtA[i:], m.BrokerId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BrokerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundMortgage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundMortgage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundMortgage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mortgagable != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mortgagable))))
		i--
		dAtA[i] = 0x41
	}
	if m.Available != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Available))))
		i--
		dAtA[i] = 0x39
	}
	if m.Mortgage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mortgage))))
		i--
		dAtA[i] = 0x31
	}
	if m.CurrentOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentOut))))
		i--
		dAtA[i] = 0x29
	}
	if m.CurrentIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentIn))))
		i--
		dAtA[i] = 0x21
	}
	if m.PreMortgage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreMortgage))))
		i--
		dAtA[i] = 0x19
	}
	if m.PreOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.PreIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SpecProduct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecProduct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecProduct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExchangeMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeMargin))))
		i--
		dAtA[i] = 0x41
	}
	if m.PositionProfitByAlg != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfitByAlg))))
		i--
		dAtA[i] = 0x39
	}
	if m.CloseProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CloseProfit))))
		i--
		dAtA[i] = 0x31
	}
	if m.PositionProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfit))))
		i--
		dAtA[i] = 0x29
	}
	if m.FrozenCommission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCommission))))
		i--
		dAtA[i] = 0x21
	}
	if m.Commission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Commission))))
		i--
		dAtA[i] = 0x19
	}
	if m.FrozenMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenMargin))))
		i--
		dAtA[i] = 0x11
	}
	if m.Margin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Margin))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MarketValueEquity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MarketValueEquity))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb9
	}
	if m.Premium != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Premium))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb1
	}
	if m.DynamicMoney != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DynamicMoney))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa9
	}
	if m.OptionMarketValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OptionMarketValue))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa1
	}
	if m.StockMarketValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StockMarketValue))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x99
	}
	if m.RemainSwap != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RemainSwap))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x91
	}
	if m.FrozenSwap != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenSwap))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x89
	}
	if m.BusinessType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.BusinessType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.SpecProductInfo != nil {
		{
			size, err := m.SpecProductInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.MortgageInfo != nil {
		{
			size, err := m.MortgageInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.CurrencyId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.CurrencyId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ReserveBalance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReserveBalance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe1
	}
	if m.ExchangeDeliveryMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeDeliveryMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd9
	}
	if m.DeliveryMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd1
	}
	if m.ExchangeMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExchangeMargin))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc9
	}
	if m.Credit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Credit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.SettlementId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Reserve != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Reserve))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.WithdrawQuota != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WithdrawQuota))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.Available != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Available))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.PositionProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PositionProfit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.CloseProfit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CloseProfit))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.Commission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Commission))))
		i--
		dAtA[i] = 0x79
	}
	if m.CashIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CashIn))))
		i--
		dAtA[i] = 0x71
	}
	if m.CurrentMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentMargin))))
		i--
		dAtA[i] = 0x69
	}
	if m.FrozenCommission != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCommission))))
		i--
		dAtA[i] = 0x61
	}
	if m.FrozenCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenCash))))
		i--
		dAtA[i] = 0x59
	}
	if m.FrozenMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FrozenMargin))))
		i--
		dAtA[i] = 0x51
	}
	if m.Withdraw != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Withdraw))))
		i--
		dAtA[i] = 0x49
	}
	if m.Deposit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Deposit))))
		i--
		dAtA[i] = 0x41
	}
	if m.Interest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Interest))))
		i--
		dAtA[i] = 0x39
	}
	if m.InterestBase != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InterestBase))))
		i--
		dAtA[i] = 0x31
	}
	if m.PreMargin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreMargin))))
		i--
		dAtA[i] = 0x29
	}
	if m.PreBalance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreBalance))))
		i--
		dAtA[i] = 0x21
	}
	if m.PreDeposit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreDeposit))))
		i--
		dAtA[i] = 0x19
	}
	if m.PreCredit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PreCredit))))
		i--
		dAtA[i] = 0x11
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EntryType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x60
	}
	if m.FrozenVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.FrozenVolume))
		i--
		dAtA[i] = 0x58
	}
	if m.TodayVolume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TodayVolume))
		i--
		dAtA[i] = 0x50
	}
	if m.AvgOpenPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgOpenPrice))))
		i--
		dAtA[i] = 0x49
	}
	if m.AvgOpenPriceByVol != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgOpenPriceByVol))))
		i--
		dAtA[i] = 0x41
	}
	if m.Margin != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Margin))))
		i--
		dAtA[i] = 0x39
	}
	if m.Volume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Volume))
		i--
		dAtA[i] = 0x30
	}
	if m.Direction != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x28
	}
	if m.HedgeFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.HedgeFlag))
		i--
		dAtA[i] = 0x20
	}
	if len(m.InstrumentId) > 0 {
		i -= len(m.InstrumentId)
		copy(dAtA[i:], m.InstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InstrumentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductId) > 0 {
		i -= len(m.ProductId)
		copy(dAtA[i:], m.ProductId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ProductId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvestorUnitId) > 0 {
		i -= len(m.InvestorUnitId)
		copy(dAtA[i:], m.InvestorUnitId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InvestorUnitId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.TradeSource != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradeSource))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.BrokerOrderSeqence != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.BrokerOrderSeqence))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SettlementId != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SettlementId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SequenceNo != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SequenceNo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.BusinessUnit) > 0 {
		i -= len(m.BusinessUnit)
		copy(dAtA[i:], m.BusinessUnit)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.BusinessUnit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ClearingPartId) > 0 {
		i -= len(m.ClearingPartId)
		copy(dAtA[i:], m.ClearingPartId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClearingPartId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.OrderLocalId) > 0 {
		i -= len(m.OrderLocalId)
		copy(dAtA[i:], m.OrderLocalId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderLocalId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.TraderId) > 0 {
		i -= len(m.TraderId)
		copy(dAtA[i:], m.TraderId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TraderId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.PriceSource != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.PriceSource))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TradeType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradeType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.TradeTime) > 0 {
		i -= len(m.TradeTime)
		copy(dAtA[i:], m.TradeTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.TradeDate) > 0 {
		i -= len(m.TradeDate)
		copy(dAtA[i:], m.TradeDate)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeDate)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Volume != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Volume))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x79
	}
	if m.HedgeFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.HedgeFlag))
		i--
		dAtA[i] = 0x70
	}
	if m.OffsetFlag != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.OffsetFlag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ExchangeInstrumentId) > 0 {
		i -= len(m.ExchangeInstrumentId)
		copy(dAtA[i:], m.ExchangeInstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeInstrumentId)))
		i--
		dAtA[i] = 0x62
	}
	if m.TradingRole != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.TradingRole))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ParticipantId) > 0 {
		i -= len(m.ParticipantId)
		copy(dAtA[i:], m.ParticipantId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ParticipantId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OrderSysId) > 0 {
		i -= len(m.OrderSysId)
		copy(dAtA[i:], m.OrderSysId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderSysId)))
		i--
		dAtA[i] = 0x42
	}
	if m.Direction != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TradeId) > 0 {
		i -= len(m.TradeId)
		copy(dAtA[i:], m.TradeId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradeId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExchangeId) > 0 {
		i -= len(m.ExchangeId)
		copy(dAtA[i:], m.ExchangeId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.ExchangeId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderRef) > 0 {
		i -= len(m.OrderRef)
		copy(dAtA[i:], m.OrderRef)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.OrderRef)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstrumentId) > 0 {
		i -= len(m.InstrumentId)
		copy(dAtA[i:], m.InstrumentId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.InstrumentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubInfoType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.SubInfoType))
		i--
		dAtA[i] = 0x18
	}
	if m.AccountType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.AccountType))
		i--
		dAtA[i] = 0x10
	}
	if m.Investor != nil {
		{
			size, err := m.Investor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStructures(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RiskUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RiskUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RiskUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MacAddr) > 0 {
		i -= len(m.MacAddr)
		copy(dAtA[i:], m.MacAddr)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.MacAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RspUserLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspUserLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspUserLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivilegeInfo) > 0 {
		i -= len(m.PrivilegeInfo)
		copy(dAtA[i:], m.PrivilegeInfo)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.PrivilegeInfo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PrivilegeType != 0 {
		i = encodeVarintStructures(dAtA, i, uint64(m.PrivilegeType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LoginTime) > 0 {
		i -= len(m.LoginTime)
		copy(dAtA[i:], m.LoginTime)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.LoginTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradingDay) > 0 {
		i -= len(m.TradingDay)
		copy(dAtA[i:], m.TradingDay)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.TradingDay)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RspUserLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspUserLogout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspUserLogout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintStructures(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStructures(dAtA []byte, offset int, v uint64) int {
	offset -= sovStructures(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RspInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorId != 0 {
		n += 1 + sovStructures(uint64(m.ErrorId))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *Investor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BrokerId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InvestorId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *FundMortgage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreIn != 0 {
		n += 9
	}
	if m.PreOut != 0 {
		n += 9
	}
	if m.PreMortgage != 0 {
		n += 9
	}
	if m.CurrentIn != 0 {
		n += 9
	}
	if m.CurrentOut != 0 {
		n += 9
	}
	if m.Mortgage != 0 {
		n += 9
	}
	if m.Available != 0 {
		n += 9
	}
	if m.Mortgagable != 0 {
		n += 9
	}
	return n
}

func (m *SpecProduct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Margin != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.PositionProfit != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 9
	}
	if m.PositionProfitByAlg != 0 {
		n += 9
	}
	if m.ExchangeMargin != 0 {
		n += 9
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.PreCredit != 0 {
		n += 9
	}
	if m.PreDeposit != 0 {
		n += 9
	}
	if m.PreBalance != 0 {
		n += 9
	}
	if m.PreMargin != 0 {
		n += 9
	}
	if m.InterestBase != 0 {
		n += 9
	}
	if m.Interest != 0 {
		n += 9
	}
	if m.Deposit != 0 {
		n += 9
	}
	if m.Withdraw != 0 {
		n += 9
	}
	if m.FrozenMargin != 0 {
		n += 9
	}
	if m.FrozenCash != 0 {
		n += 9
	}
	if m.FrozenCommission != 0 {
		n += 9
	}
	if m.CurrentMargin != 0 {
		n += 9
	}
	if m.CashIn != 0 {
		n += 9
	}
	if m.Commission != 0 {
		n += 9
	}
	if m.CloseProfit != 0 {
		n += 10
	}
	if m.PositionProfit != 0 {
		n += 10
	}
	if m.Balance != 0 {
		n += 10
	}
	if m.Available != 0 {
		n += 10
	}
	if m.WithdrawQuota != 0 {
		n += 10
	}
	if m.Reserve != 0 {
		n += 10
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 2 + sovStructures(uint64(m.SettlementId))
	}
	if m.Credit != 0 {
		n += 10
	}
	if m.ExchangeMargin != 0 {
		n += 10
	}
	if m.DeliveryMargin != 0 {
		n += 10
	}
	if m.ExchangeDeliveryMargin != 0 {
		n += 10
	}
	if m.ReserveBalance != 0 {
		n += 10
	}
	if m.CurrencyId != 0 {
		n += 2 + sovStructures(uint64(m.CurrencyId))
	}
	if m.MortgageInfo != nil {
		l = m.MortgageInfo.Size()
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SpecProductInfo != nil {
		l = m.SpecProductInfo.Size()
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.BusinessType != 0 {
		n += 2 + sovStructures(uint64(m.BusinessType))
	}
	if m.FrozenSwap != 0 {
		n += 10
	}
	if m.RemainSwap != 0 {
		n += 10
	}
	if m.StockMarketValue != 0 {
		n += 10
	}
	if m.OptionMarketValue != 0 {
		n += 10
	}
	if m.DynamicMoney != 0 {
		n += 10
	}
	if m.Premium != 0 {
		n += 10
	}
	if m.MarketValueEquity != 0 {
		n += 10
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ProductId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.HedgeFlag != 0 {
		n += 1 + sovStructures(uint64(m.HedgeFlag))
	}
	if m.Direction != 0 {
		n += 1 + sovStructures(uint64(m.Direction))
	}
	if m.Volume != 0 {
		n += 1 + sovStructures(uint64(m.Volume))
	}
	if m.Margin != 0 {
		n += 9
	}
	if m.AvgOpenPriceByVol != 0 {
		n += 9
	}
	if m.AvgOpenPrice != 0 {
		n += 9
	}
	if m.TodayVolume != 0 {
		n += 1 + sovStructures(uint64(m.TodayVolume))
	}
	if m.FrozenVolume != 0 {
		n += 1 + sovStructures(uint64(m.FrozenVolume))
	}
	if m.EntryType != 0 {
		n += 1 + sovStructures(uint64(m.EntryType))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.InstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.OrderRef)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ExchangeId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.TradeId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovStructures(uint64(m.Direction))
	}
	l = len(m.OrderSysId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ParticipantId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.TradingRole != 0 {
		n += 1 + sovStructures(uint64(m.TradingRole))
	}
	l = len(m.ExchangeInstrumentId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.OffsetFlag != 0 {
		n += 1 + sovStructures(uint64(m.OffsetFlag))
	}
	if m.HedgeFlag != 0 {
		n += 1 + sovStructures(uint64(m.HedgeFlag))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 2 + sovStructures(uint64(m.Volume))
	}
	l = len(m.TradeDate)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.TradeTime)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.TradeType != 0 {
		n += 2 + sovStructures(uint64(m.TradeType))
	}
	if m.PriceSource != 0 {
		n += 2 + sovStructures(uint64(m.PriceSource))
	}
	l = len(m.TraderId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.OrderLocalId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.ClearingPartId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	l = len(m.BusinessUnit)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SequenceNo != 0 {
		n += 2 + sovStructures(uint64(m.SequenceNo))
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	if m.SettlementId != 0 {
		n += 2 + sovStructures(uint64(m.SettlementId))
	}
	if m.BrokerOrderSeqence != 0 {
		n += 2 + sovStructures(uint64(m.BrokerOrderSeqence))
	}
	if m.TradeSource != 0 {
		n += 2 + sovStructures(uint64(m.TradeSource))
	}
	l = len(m.InvestorUnitId)
	if l > 0 {
		n += 2 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *SubInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Investor != nil {
		l = m.Investor.Size()
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.AccountType != 0 {
		n += 1 + sovStructures(uint64(m.AccountType))
	}
	if m.SubInfoType != 0 {
		n += 1 + sovStructures(uint64(m.SubInfoType))
	}
	return n
}

func (m *RiskUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *RspUserLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.TradingDay)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	l = len(m.LoginTime)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	if m.PrivilegeType != 0 {
		n += 1 + sovStructures(uint64(m.PrivilegeType))
	}
	l = len(m.PrivilegeInfo)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func (m *RspUserLogout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovStructures(uint64(l))
	}
	return n
}

func sovStructures(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStructures(x uint64) (n int) {
	return sovStructures(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RspInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RspInfo{`,
		`ErrorId:` + fmt.Sprintf("%v", this.ErrorId) + `,`,
		`ErrorMsg:` + fmt.Sprintf("%v", this.ErrorMsg) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Investor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Investor{`,
		`BrokerId:` + fmt.Sprintf("%v", this.BrokerId) + `,`,
		`InvestorId:` + fmt.Sprintf("%v", this.InvestorId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FundMortgage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FundMortgage{`,
		`PreIn:` + fmt.Sprintf("%v", this.PreIn) + `,`,
		`PreOut:` + fmt.Sprintf("%v", this.PreOut) + `,`,
		`PreMortgage:` + fmt.Sprintf("%v", this.PreMortgage) + `,`,
		`CurrentIn:` + fmt.Sprintf("%v", this.CurrentIn) + `,`,
		`CurrentOut:` + fmt.Sprintf("%v", this.CurrentOut) + `,`,
		`Mortgage:` + fmt.Sprintf("%v", this.Mortgage) + `,`,
		`Available:` + fmt.Sprintf("%v", this.Available) + `,`,
		`Mortgagable:` + fmt.Sprintf("%v", this.Mortgagable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpecProduct) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpecProduct{`,
		`Margin:` + fmt.Sprintf("%v", this.Margin) + `,`,
		`FrozenMargin:` + fmt.Sprintf("%v", this.FrozenMargin) + `,`,
		`Commission:` + fmt.Sprintf("%v", this.Commission) + `,`,
		`FrozenCommission:` + fmt.Sprintf("%v", this.FrozenCommission) + `,`,
		`PositionProfit:` + fmt.Sprintf("%v", this.PositionProfit) + `,`,
		`CloseProfit:` + fmt.Sprintf("%v", this.CloseProfit) + `,`,
		`PositionProfitByAlg:` + fmt.Sprintf("%v", this.PositionProfitByAlg) + `,`,
		`ExchangeMargin:` + fmt.Sprintf("%v", this.ExchangeMargin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Account) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Account{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`PreCredit:` + fmt.Sprintf("%v", this.PreCredit) + `,`,
		`PreDeposit:` + fmt.Sprintf("%v", this.PreDeposit) + `,`,
		`PreBalance:` + fmt.Sprintf("%v", this.PreBalance) + `,`,
		`PreMargin:` + fmt.Sprintf("%v", this.PreMargin) + `,`,
		`InterestBase:` + fmt.Sprintf("%v", this.InterestBase) + `,`,
		`Interest:` + fmt.Sprintf("%v", this.Interest) + `,`,
		`Deposit:` + fmt.Sprintf("%v", this.Deposit) + `,`,
		`Withdraw:` + fmt.Sprintf("%v", this.Withdraw) + `,`,
		`FrozenMargin:` + fmt.Sprintf("%v", this.FrozenMargin) + `,`,
		`FrozenCash:` + fmt.Sprintf("%v", this.FrozenCash) + `,`,
		`FrozenCommission:` + fmt.Sprintf("%v", this.FrozenCommission) + `,`,
		`CurrentMargin:` + fmt.Sprintf("%v", this.CurrentMargin) + `,`,
		`CashIn:` + fmt.Sprintf("%v", this.CashIn) + `,`,
		`Commission:` + fmt.Sprintf("%v", this.Commission) + `,`,
		`CloseProfit:` + fmt.Sprintf("%v", this.CloseProfit) + `,`,
		`PositionProfit:` + fmt.Sprintf("%v", this.PositionProfit) + `,`,
		`Balance:` + fmt.Sprintf("%v", this.Balance) + `,`,
		`Available:` + fmt.Sprintf("%v", this.Available) + `,`,
		`WithdrawQuota:` + fmt.Sprintf("%v", this.WithdrawQuota) + `,`,
		`Reserve:` + fmt.Sprintf("%v", this.Reserve) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`SettlementId:` + fmt.Sprintf("%v", this.SettlementId) + `,`,
		`Credit:` + fmt.Sprintf("%v", this.Credit) + `,`,
		`ExchangeMargin:` + fmt.Sprintf("%v", this.ExchangeMargin) + `,`,
		`DeliveryMargin:` + fmt.Sprintf("%v", this.DeliveryMargin) + `,`,
		`ExchangeDeliveryMargin:` + fmt.Sprintf("%v", this.ExchangeDeliveryMargin) + `,`,
		`ReserveBalance:` + fmt.Sprintf("%v", this.ReserveBalance) + `,`,
		`CurrencyId:` + fmt.Sprintf("%v", this.CurrencyId) + `,`,
		`MortgageInfo:` + strings.Replace(this.MortgageInfo.String(), "FundMortgage", "FundMortgage", 1) + `,`,
		`SpecProductInfo:` + strings.Replace(this.SpecProductInfo.String(), "SpecProduct", "SpecProduct", 1) + `,`,
		`BusinessType:` + fmt.Sprintf("%v", this.BusinessType) + `,`,
		`FrozenSwap:` + fmt.Sprintf("%v", this.FrozenSwap) + `,`,
		`RemainSwap:` + fmt.Sprintf("%v", this.RemainSwap) + `,`,
		`StockMarketValue:` + fmt.Sprintf("%v", this.StockMarketValue) + `,`,
		`OptionMarketValue:` + fmt.Sprintf("%v", this.OptionMarketValue) + `,`,
		`DynamicMoney:` + fmt.Sprintf("%v", this.DynamicMoney) + `,`,
		`Premium:` + fmt.Sprintf("%v", this.Premium) + `,`,
		`MarketValueEquity:` + fmt.Sprintf("%v", this.MarketValueEquity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Position) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Position{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`ProductId:` + fmt.Sprintf("%v", this.ProductId) + `,`,
		`InstrumentId:` + fmt.Sprintf("%v", this.InstrumentId) + `,`,
		`HedgeFlag:` + fmt.Sprintf("%v", this.HedgeFlag) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Margin:` + fmt.Sprintf("%v", this.Margin) + `,`,
		`AvgOpenPriceByVol:` + fmt.Sprintf("%v", this.AvgOpenPriceByVol) + `,`,
		`AvgOpenPrice:` + fmt.Sprintf("%v", this.AvgOpenPrice) + `,`,
		`TodayVolume:` + fmt.Sprintf("%v", this.TodayVolume) + `,`,
		`FrozenVolume:` + fmt.Sprintf("%v", this.FrozenVolume) + `,`,
		`EntryType:` + fmt.Sprintf("%v", this.EntryType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Trade) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Trade{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`InstrumentId:` + fmt.Sprintf("%v", this.InstrumentId) + `,`,
		`OrderRef:` + fmt.Sprintf("%v", this.OrderRef) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`ExchangeId:` + fmt.Sprintf("%v", this.ExchangeId) + `,`,
		`TradeId:` + fmt.Sprintf("%v", this.TradeId) + `,`,
		`Direction:` + fmt.Sprintf("%v", this.Direction) + `,`,
		`OrderSysId:` + fmt.Sprintf("%v", this.OrderSysId) + `,`,
		`ParticipantId:` + fmt.Sprintf("%v", this.ParticipantId) + `,`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`TradingRole:` + fmt.Sprintf("%v", this.TradingRole) + `,`,
		`ExchangeInstrumentId:` + fmt.Sprintf("%v", this.ExchangeInstrumentId) + `,`,
		`OffsetFlag:` + fmt.Sprintf("%v", this.OffsetFlag) + `,`,
		`HedgeFlag:` + fmt.Sprintf("%v", this.HedgeFlag) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`TradeDate:` + fmt.Sprintf("%v", this.TradeDate) + `,`,
		`TradeTime:` + fmt.Sprintf("%v", this.TradeTime) + `,`,
		`TradeType:` + fmt.Sprintf("%v", this.TradeType) + `,`,
		`PriceSource:` + fmt.Sprintf("%v", this.PriceSource) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`OrderLocalId:` + fmt.Sprintf("%v", this.OrderLocalId) + `,`,
		`ClearingPartId:` + fmt.Sprintf("%v", this.ClearingPartId) + `,`,
		`BusinessUnit:` + fmt.Sprintf("%v", this.BusinessUnit) + `,`,
		`SequenceNo:` + fmt.Sprintf("%v", this.SequenceNo) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`SettlementId:` + fmt.Sprintf("%v", this.SettlementId) + `,`,
		`BrokerOrderSeqence:` + fmt.Sprintf("%v", this.BrokerOrderSeqence) + `,`,
		`TradeSource:` + fmt.Sprintf("%v", this.TradeSource) + `,`,
		`InvestorUnitId:` + fmt.Sprintf("%v", this.InvestorUnitId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubInfo{`,
		`Investor:` + strings.Replace(this.Investor.String(), "Investor", "Investor", 1) + `,`,
		`AccountType:` + fmt.Sprintf("%v", this.AccountType) + `,`,
		`SubInfoType:` + fmt.Sprintf("%v", this.SubInfoType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RiskUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RiskUser{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`MacAddr:` + fmt.Sprintf("%v", this.MacAddr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RspUserLogin) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RspUserLogin{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`TradingDay:` + fmt.Sprintf("%v", this.TradingDay) + `,`,
		`LoginTime:` + fmt.Sprintf("%v", this.LoginTime) + `,`,
		`PrivilegeType:` + fmt.Sprintf("%v", this.PrivilegeType) + `,`,
		`PrivilegeInfo:` + fmt.Sprintf("%v", this.PrivilegeInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RspUserLogout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RspUserLogout{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStructures(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RspInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorId", wireType)
			}
			m.ErrorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Investor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Investor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Investor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundMortgage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundMortgage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundMortgage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMortgage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreMortgage = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentIn = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentOut = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mortgage = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Available = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mortgagable", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mortgagable = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecProduct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecProduct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecProduct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Margin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Commission = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfit = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CloseProfit = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfitByAlg", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfitByAlg = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeMargin = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreCredit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreCredit = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreDeposit = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreBalance = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PreMargin = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestBase", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InterestBase = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Interest = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Deposit = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdraw", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Withdraw = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenMargin = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCash = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenCommission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenCommission = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentMargin = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CashIn = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Commission = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CloseProfit = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionProfit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PositionProfit = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Available = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawQuota", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WithdrawQuota = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Reserve = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Credit = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeMargin = float64(math.Float64frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryMargin = float64(math.Float64frombits(v))
		case 27:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeDeliveryMargin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExchangeDeliveryMargin = float64(math.Float64frombits(v))
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveBalance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReserveBalance = float64(math.Float64frombits(v))
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			m.CurrencyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyId |= CurrencyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MortgageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MortgageInfo == nil {
				m.MortgageInfo = &FundMortgage{}
			}
			if err := m.MortgageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecProductInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecProductInfo == nil {
				m.SpecProductInfo = &SpecProduct{}
			}
			if err := m.SpecProductInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessType", wireType)
			}
			m.BusinessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessType |= BusinessType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenSwap", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FrozenSwap = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainSwap", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RemainSwap = float64(math.Float64frombits(v))
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockMarketValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StockMarketValue = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionMarketValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OptionMarketValue = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicMoney", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DynamicMoney = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Premium", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Premium = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketValueEquity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MarketValueEquity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeFlag", wireType)
			}
			m.HedgeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HedgeFlag |= HedgeFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Margin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Margin = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgOpenPriceByVol", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgOpenPriceByVol = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgOpenPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgOpenPrice = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TodayVolume", wireType)
			}
			m.TodayVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TodayVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenVolume", wireType)
			}
			m.FrozenVolume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrozenVolume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSysId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderSysId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingRole", wireType)
			}
			m.TradingRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradingRole |= TradingRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeInstrumentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeInstrumentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetFlag", wireType)
			}
			m.OffsetFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetFlag |= OffsetFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HedgeFlag", wireType)
			}
			m.HedgeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HedgeFlag |= HedgeFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeType", wireType)
			}
			m.TradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeType |= TradeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceSource", wireType)
			}
			m.PriceSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceSource |= PriceSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLocalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderLocalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingPartId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearingPartId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusinessUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNo", wireType)
			}
			m.SequenceNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			m.SettlementId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerOrderSeqence", wireType)
			}
			m.BrokerOrderSeqence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokerOrderSeqence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeSource", wireType)
			}
			m.TradeSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TradeSource |= TradeSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvestorUnitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvestorUnitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Investor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Investor == nil {
				m.Investor = &Investor{}
			}
			if err := m.Investor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			m.AccountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountType |= AccountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubInfoType", wireType)
			}
			m.SubInfoType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubInfoType |= SubInfoType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RiskUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RiskUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RiskUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspUserLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspUserLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspUserLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradingDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradingDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeType", wireType)
			}
			m.PrivilegeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegeType |= PrivilegeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivilegeInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspUserLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspUserLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspUserLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStructures
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStructures
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStructures(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStructures
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStructures(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStructures
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStructures
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStructures
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStructures
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStructures
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStructures        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStructures          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStructures = fmt.Errorf("proto: unexpected end of group")
)
